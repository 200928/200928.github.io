[{"categories":["博客","随笔"],"content":"代码块 代码块格式如下 int main() { return 0; } 对应的 MarkDown 写法 ```C int main() { return 0; } ``` 如果想要添加行号：{linenos=table} 有两个参数 inline：代码行号内联在代码块里，鼠标框选代码时会选中行号 table：鼠标框选代码时不会选中行号，方便复制粘贴 table 目前有个小瑕疵就是行号和代码对不齐，需要在文章的 CSS 中设置一下 line-height： 添加行号和设置起始行：{linenos=table, linenostart=21} 行高亮：{linenos=table, hl_lines=[2 “5-6”]} 打字动画 本文参考： https://hugoloveit.com/ ","date":"2024-01-12","objectID":"/posts/%E5%86%99%E6%96%87%E7%AB%A0%E7%94%A8%E5%88%B0%E7%9A%84%E8%AF%AD%E6%B3%95/:0:0","tags":["MarkDown"],"title":"写文章用到的语法","uri":"/posts/%E5%86%99%E6%96%87%E7%AB%A0%E7%94%A8%E5%88%B0%E7%9A%84%E8%AF%AD%E6%B3%95/"},{"categories":["博客"],"content":"Hello 好久不见，最近我也将博客从 Hexo 框架迁移到了 Hugo 框架，为什么要用 Hugo 框架从新构建博客呢？距离第一次搭建博客已经也快 2 年多了，期间会写写文章记录自己的学习，期间也一直在写（没发布），可能由于审美的变化，觉得之前的博客太过臃肿了，所以一直想重新构建一下自己博客（其实这个念头已经有了一段时间，只是最近才开始） 现在您看到的就是新博客的样子了，我感觉挺简洁的，你觉得呢？挑主题的过程中，总是难以找到自己满意的，自己写吧，又写不出，也许后面有时间会研究一下，不过都是后话了。折腾是愉悦的、繁琐的、费时的…，之前也折腾过 VIm, NeoVim, ArchLinux, VsCode, Tmux, Oh My Zsh, Suckless 系列工具，各种配置，后面发现还不如老老实实注重内容，折腾工具永远都没有尽头，找到一款适合的慢慢使用就能熟练操作了 后面我也会将之前写的比较看得过去的博文放出来（顺便整理整理），其实都是一些记录罢了，没多少干货，但还是想丰富一下，留下一点以往的东西在这里。（习惯性的打了句号，感觉没有句号更好看😂） 开心! 😄 对了这是我之前博客搭建写的文章：Hexo博客搭建记录 和 博客部署到服务器，可惜的是之前图片是存储到 Gitee 当图床使用，后面 Gitee 设置了防盗链，由此在阿里云配置了 OSS 存储服务没有写文章记录 Abstract 下面是博客美化的记录 期间参考了下面这些博主的文章 https://hugoloveit.com/（LoveIt 主题的作者） https://lewky233.top/ 添加自定义JS 引用自：https://lewky233.top/posts/hugo-3.html/ LoveIt主题并没有提供一个文件来让我们自定义JavaScript，所以需要自己创建一个js文件来自定义JavaScript。 首先在站点根目录下创建一个自定义的JavaScript文件：\\static\\js\\custom.js。这个文件需要在body的闭合标签之前引入，并且要在theme.min.js的引入顺序之后。这样可以防止样式被其他文件覆盖，并且不会因为JavaScript文件假装太久导致页面长时间的空白。 对于LoveIt主题，custom.js添加在\\themes\\LoveIt\\layouts\\partials\\assets.html里。 首先把该文件拷贝到根目录下的\\layouts\\partials\\assets.html，然后打开拷贝后的文件，把自定义的JavaScript文件添加到最末尾的{{- partial \"plugin/analytics.html\" . -}}的上一行： {{- /* 自定义的js文件 */ -}} \u003cscript type=\"text/javascript\" src=\"/js/custom.js\"\u003e\u003c/script\u003e footer添加网站运行时间 在自定义custom.js文件中添加下面函数 /* 站点运行时间 */ (function() { const runtime = () =\u003e { window.setTimeout(runtime, 1000); /* 请修改这里的起始时间 */ let startTime = new Date('01/08/2024 15:00:00'); let endTime = new Date(); let usedTime = endTime - startTime; let days = Math.floor(usedTime / (24 * 3600 * 1000)); let leavel = usedTime % (24 * 3600 * 1000); let hours = Math.floor(leavel / (3600 * 1000)); let leavel2 = leavel % (3600 * 1000); let minutes = Math.floor(leavel2 / (60 * 1000)); let leavel3 = leavel2 % (60 * 1000); let seconds = Math.floor(leavel3 / (1000)); let runbox = document.getElementById('run-time'); runbox.innerHTML = '本站已运行\u003ci class=\"far fa-clock fa-fw\"\u003e\u003c/i\u003e ' + ((days \u003c 10) ? '0' : '') + days + ' 天 ' + ((hours \u003c 10) ? '0' : '') + hours + ' 时 ' + ((minutes \u003c 10) ? '0' : '') + minutes + ' 分 ' + ((seconds \u003c 10) ? '0' : '') + seconds + ' 秒 '; }; runtime(); })(); 文章过期提醒 在根目录的hugo.toml文件中添加 # Display a message at the beginning of an article to warn the readers that it's content may be outdated. # 在文章末尾显示提示信息，提醒读者文章内容可能过时。 [params.outdatedInfoWarning] enable = true hint = 90 # Display hint if the last modified time is more than these days ago. # 如果文章最后更新于这天数之前，显示提醒 warn = 180 # Display warning if the last modified time is more than these days ago. # 如果文章最后更新于这天数之前，显示警告 侧边栏 ","date":"2024-01-11","objectID":"/posts/%E4%BB%8Ehexo%E5%88%B0hugo/:0:0","tags":["Hugo","MarkDown"],"title":"从 Hexo 迁移到 Hugo","uri":"/posts/%E4%BB%8Ehexo%E5%88%B0hugo/"},{"categories":["博客"],"content":"目录 默认不显示一级标题 解决方案，在根目录的hugo.toml文件中添加 [markup] [markup.tableOfContents] endLevel = 5 ordered = false startLevel = 1 代码高亮 在hugo.toml文件中添加 [markup.highlight] guessSyntax = true # 猜测语法，如果你没有设置要显示的语言则会自动匹配 codeFences = true # 代码围栏功能 style = 'monokai' # 样式参考 https://swapoff.org/chroma/playground noClasses = false # 设置为true的话不可以通过外联样式调整 lineNos = true # 行号 lineNumbersInTable = true # 如果设为 false，那么生成带有行数的代码块时，行数会和代码混合在一起，不方便复制 参考 https://gohugo.io/getting-started/configuration-markup/#highlight https://gohugo.io/functions/transform/highlight/ https://xyproto.github.io/splash/docs/all.html 主页的文章列表CSS 根据主题变化颜色 article.single.summary { padding: 10px; margin-bottom: 15px; border: 1px none #ddd; // border-radius: 5px; /* 或者使用其他数值，根据需要调整 */ // box-shadow: 0 4px 4px rgba(0, 0, 0, 0.1); /* 调整阴影的颜色和大小 */ background-color: #f9f9f9; /* 调整背景颜色 */ } /* 切换到 light 主题 */ body[theme=\"light\"] article.single.summary { background-color: #f9f9f9; /* light 主题颜色 */ } /* 切换到 dark 主题 */ body[theme=\"dark\"] article.single.summary { background-color: #333; /* dark 主题颜色 */ } 后面发现并不美观，给文章列表下面加上实线 article.single.summary { border-bottom: 1px solid #96969657 !important; /* 使用 !important 来强制应用样式 */ } 给博客增加访问统计 注册 Umami，登录后添加一个站点 点击Edit查看需要内嵌的 JavaScript 代码 放到/layouts/partials/assets.html \u003cscript defer src=\"https://us.umami.is/script.js\" data-website-id=\"xxx\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js\"\u003e\u003c/script\u003e \u003c!-- {{- /* 自定义的js文件 */ -}} --\u003e \u003cscript type=\"text/javascript\" src=\"/js/custom.js\"\u003e\u003c/script\u003e {{- partial \"plugin/analytics.html\" . -}} 统计功能 参考自：https://stilig.me/posts/hugo-adds-busuanzi/ 在/layouts/partials/plugin/添加文件busuanzi.html，内容如下 {{ if .params.enable }} {{ if eq .bsz_type \"footer\" }} {{/* 只有 footer 才刷新，防止页面进行多次调用，计数重复; 只要启用就计数，显示与否看具体设置 */}} \u003cscript async src=\" //busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js \"\u003e\u003c/script\u003e {{ end }} {{ if or (eq .params.site_pv true) (eq .params.site_uv true) (eq .params.page_pv true) }} {{ if eq .bsz_type \"footer\" }} \u003csection\u003e {{ if eq .params.site_pv true }} \u003cspan id=\"busuanzi_container_value_site_pv\"\u003e {{- with .params.page_pv_pre -}} {{ . | safeHTML }} {{ end }} \u003cspan id=\"busuanzi_value_site_pv\"\u003e\u003c/span\u003e \u003c/span\u003e {{ end }} {{ if and (eq .params.site_pv true) (eq .params.site_uv true) }} \u0026nbsp;|\u0026nbsp; {{ end }} {{ if eq .params.site_uv true }} \u003cspan id=\"busuanzi_container_value_site_uv\"\u003e {{- with .params.site_uv_pre -}} {{ . | safeHTML }} {{ end }} \u003cspan id=\"busuanzi_value_site_uv\"\u003e\u003c/span\u003e \u003c/span\u003e {{ end }} \u003c/section\u003e {{ end }} {{/* page pv 只在 page 显示 */}} {{ if and (eq .params.page_pv true) (eq .bsz_type \"page-reading\") }} \u003cspan id=\"busuanzi_container_value_page_pv\"\u003e {{- with .params.page_pv_pre -}} {{ . | safeHTML }} {{ end }} \u003cspan id=\"busuanzi_value_page_pv\"\u003e\u003c/span\u003e\u0026nbsp; {{- T \"views\" -}} \u003c/span\u003e {{ end }} {{ end }} {{ end }} 然后在Hugo.toml添加如下内容 # 添加不蒜子计数 [params.busuanzi] enable = true # 是否开启全站独立访客数 site_uv = true # 全站独立访客数前的图标或提示语 site_uv_pre = '\u003ci class=\"fa fa-user\"\u003e\u003c/i\u003e' # 全站独立访客数后的图标或提示语 site_uv_post = '' # 是否开启全站浏览量 site_pv = true # 全站浏览量前的图标或提示语 site_pv_pre = '\u003ci class=\"fa fa-eye\"\u003e\u003c/i\u003e' # 全站浏览量后的图标或提示语 site_pv_post = '' # 是否开启单页浏览量 page_pv = true # 单页浏览量前的图标或提示语 page_pv_pre = '\u003ci class=\"far fa-eye fa-fw\"\u003e\u003c/i\u003e' # 单页浏览量后的图标或提示语 page_pv_post = '' 然后在需要的地方引入不蒜子 ","date":"2024-01-11","objectID":"/posts/%E4%BB%8Ehexo%E5%88%B0hugo/:1:0","tags":["Hugo","MarkDown"],"title":"从 Hexo 迁移到 Hugo","uri":"/posts/%E4%BB%8Ehexo%E5%88%B0hugo/"},{"categories":["博客"],"content":"开启页脚全站统计 在/layouts/partials/footer.html文件中加入高亮行 \u003c/div\u003e {{- /* busuanzi plugin */ -}} {{- partial \"plugin/busuanzi.html\" (dict \"params\" .Site.Params.busuanzi \"bsz_type\" \"footer\") -}} \u003c/div\u003e \u003c/footer\u003e {{- end -}} ","date":"2024-01-11","objectID":"/posts/%E4%BB%8Ehexo%E5%88%B0hugo/:2:0","tags":["Hugo","MarkDown"],"title":"从 Hexo 迁移到 Hugo","uri":"/posts/%E4%BB%8Ehexo%E5%88%B0hugo/"},{"categories":["博客"],"content":"开启文章页统计 在/layouts/posts/single.html文件中加入高亮行 \u003cdiv class=\"post-meta-line\"\u003e {{- with .Site.Params.dateformat | default \"2006-01-02\" | .PublishDate.Format -}} \u003ci class=\"far fa-calendar-alt fa-fw\" aria-hidden=\"true\"\u003e\u003c/i\u003e\u0026nbsp;\u003ctime datetime=\"{{ . }}\"\u003e{{ . }}\u003c/time\u003e\u0026nbsp; {{- end -}} \u003ci class=\"fas fa-pencil-alt fa-fw\" aria-hidden=\"true\"\u003e\u003c/i\u003e\u0026nbsp;{{ T \"wordCount\" .WordCount }}\u0026nbsp; \u003ci class=\"far fa-clock fa-fw\" aria-hidden=\"true\"\u003e\u003c/i\u003e\u0026nbsp;{{ T \"readingTime\" .ReadingTime }}\u0026nbsp; {{- $comment := .Scratch.Get \"comment\" | default dict -}} {{- if $comment.enable | and $comment.valine.enable | and $comment.valine.visitor -}} \u003cspan id=\"{{ .RelPermalink }}\" class=\"leancloud_visitors\" data-flag-title=\"{{ .Title }}\"\u003e \u003ci class=\"far fa-eye fa-fw\" aria-hidden=\"true\"\u003e\u003c/i\u003e\u0026nbsp;\u003cspan class=leancloud-visitors-count\u003e\u003c/span\u003e\u0026nbsp;{{ T \"views\" }} \u003c/span\u003e\u0026nbsp; {{- end -}} {{- /* busuanzi plugin */ -}} {{- partial \"plugin/busuanzi.html\" (dict \"params\" .Site.Params.busuanzi \"bsz_type\" \"page-reading\") -}} \u003c/div\u003e ","date":"2024-01-11","objectID":"/posts/%E4%BB%8Ehexo%E5%88%B0hugo/:3:0","tags":["Hugo","MarkDown"],"title":"从 Hexo 迁移到 Hugo","uri":"/posts/%E4%BB%8Ehexo%E5%88%B0hugo/"},{"categories":["学习"],"content":"引入依赖 \u003c!--日志输出--\u003e \u003cdependency\u003e \u003cgroupId\u003ech.qos.logback\u003c/groupId\u003e \u003cartifactId\u003elogback-core\u003c/artifactId\u003e \u003cversion\u003e1.2.6\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.slf4j\u003c/groupId\u003e \u003cartifactId\u003eslf4j-api\u003c/artifactId\u003e \u003cversion\u003e1.7.30\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ech.qos.logback\u003c/groupId\u003e \u003cartifactId\u003elogback-classic\u003c/artifactId\u003e \u003cversion\u003e1.2.6\u003c/version\u003e \u003c/dependency\u003e application.yml 修改mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.slf4j.Slf4jImpl可输出到日志文件中 # MyBatis-Plus 配置 mybatis-plus: configuration: # 启用或禁用缓存 cache-enabled: true # 启用或禁用生成的键 use-generated-keys: true # 设置默认的执行器类型。选项有 SIMPLE, REUSE, 和 BATCH default-executor-type: REUSE # 启用或禁用实际参数名的使用 use-actual-param-name: true # 指定 MyBatis-Plus 的日志实现。默认是 org.apache.ibatis.logging.stdout.StdOutImpl # 它只能打印日志到控制台，不能输出到日志文件 #log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 当前的日志实现是 org.apache.ibatis.logging.slf4j.Slf4jImpl，它支持输出到日志文件 log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl logback-spring.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cconfiguration scan=\"true\" scanPeriod=\"10 seconds\"\u003e \u003c!-- 日志级别从低到高分为TRACE \u003c DEBUG \u003c INFO \u003c WARN \u003c ERROR \u003c FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --\u003e \u003c!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --\u003e \u003c!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --\u003e \u003c!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --\u003e \u003ccontextName\u003elogback\u003c/contextName\u003e \u003c!-- 全局属性：name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。 --\u003e \u003c!-- 日志文件路径属性,不同环境日志输出位置不一样 --\u003e \u003cspringProfile name=\"dev\"\u003e \u003cproperty name=\"log.path\" value=\"dev-logs\"/\u003e \u003c/springProfile\u003e \u003cspringProfile name=\"prod\"\u003e \u003cproperty name=\"log.path\" value=\"prod_logs\"/\u003e \u003c/springProfile\u003e \u003c!-- 控制台日志输出格式属性，magenta:洋红,boldMagenta:粗红,cyan:青色,white:白色,magenta:洋红--\u003e \u003cproperty name=\"CONSOLE_LOG_PATTERN\" value=\"%yellow(%date{yyyy-MM-dd HH:mm:ss}) |%highlight(%-5level) |%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)\"/\u003e \u003cconversionRule conversionWord=\"wEx\" converterClass=\"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter\"/\u003e \u003cproperty name=\"FILE_LOG_PATTERN\" value=\"%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS}} ${LOG_LEVEL_PATTERN:-%5p} ${PID:- } --- [%t] %-40.40logger{39} %file:%line: %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}\"/\u003e \u003c!--输出到控制台的Appender配置--\u003e \u003cappender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"\u003e \u003c!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--\u003e \u003c!-- 例如：如果此处配置了INFO级别，则后面其他位置即使配置了DEBUG级别的日志，也不会被输出 --\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"\u003e \u003clevel\u003eDEBUG\u003c/level\u003e \u003c/filter\u003e \u003cencoder\u003e \u003c!-- 输出日志格式 --\u003e \u003cPattern\u003e${CONSOLE_LOG_PATTERN}\u003c/Pattern\u003e \u003c!-- 设置字符集 --\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c/appender\u003e \u003c!--输出到文件的Appender配置 info日志--\u003e \u003cappender name=\"INFO_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 日志具体路径及文件名 --\u003e \u003cfile\u003e${log.path}/log_info.log\u003c/file\u003e \u003c!--日志文件输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e${FILE_LOG_PATTERN}\u003c/pattern\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c!-- 日志记录器的滚动策略，按日期，按大小记录 --\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"\u003e \u003c!-- 每天日志归档路径以及格式 --\u003e \u003cfileNamePattern\u003e${log.path}/info/log-info-%d{yyyy-MM-dd}.%i.log\u003c/fileNamePattern\u003e \u003ctimeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"\u003e \u003cmaxFileSize\u003e100MB\u003c/maxFileSize\u003e \u003c/timeBasedFileNamingAndTriggeringPolicy\u003e \u003c!--日志文件保留天数--\u003e \u003cmaxHistory\u003e60\u003c/maxHistory\u003e \u003c/rollingPolicy\u003e \u003c!-- 此日志文件只记录info级别的 --\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.LevelFilter\"\u003e \u003clevel\u003eINFO\u003c/level\u003e \u003conMatch\u003eACCEPT\u003c/onMatch\u003e \u003conMismatch\u003eDENY\u003c/onMismatch\u003e \u003c/filter\u003e \u003c/appender\u003e \u003c!--输出到文件的Appender配置 warn日志--\u003e \u003cappender name=\"WARN_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003cfile\u003e${log.path}/log_warn.log\u003c/file\u003e \u003cencoder\u003e \u003cpattern\u003e${FILE_LOG_PATTERN}\u003c/pattern\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c!-- 日志记录器的滚动策略，按日期，按大小记录 --\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedR","date":"2023-12-09","objectID":"/posts/springboot%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E6%97%A5%E5%BF%97/:0:0","tags":["Java","XML","Spring"],"title":"Spring日志设置","uri":"/posts/springboot%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E6%97%A5%E5%BF%97/"},{"categories":null,"content":" start javaw -jar xxxxx netstat -ano | findstr 8848 查看端口占用 pid taskkill /pid xxxx/f 杀死进程 ","date":"2023-11-29","objectID":"/posts/windows%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/:0:0","tags":null,"title":"Windows 项目部署","uri":"/posts/windows%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"categories":["学习"],"content":"项目绑定 ","date":"2023-11-09","objectID":"/posts/git%E5%8D%8F%E4%BD%9C/:0:0","tags":["Git"],"title":"Git 协作","uri":"/posts/git%E5%8D%8F%E4%BD%9C/"},{"categories":["学习"],"content":"生成密钥对 如果代码托管平台没有添加本地公钥先添加，下面是创建公钥，如已有公钥请跳过 ssh-keygen -t rsa -b 4096 -C \u003cemail\u003e ssh-keygen **命令**用于为 ssh 生成、管理和转换认证密钥，它支持 RSA 和 DSA 两种认 证密钥 -b：指定密钥长度； -C：添加注释；用于为指定注释，可以是任何内容，通常使用自己的邮件名作为注释。 -f：指定用来保存密钥的文件名； -t：指定要创建的密钥类型（加密方式）。 -e：读取openssh的私钥或者公钥文件； -i：读取未加密的ssh-v2兼容的私钥/公钥文件，然后在标准输出设备上显示openssh兼容的私钥/公钥； -l：显示公钥文件的指纹数据； -N：提供一个新密语； -P：提供（旧）密语； -q：静默模式； ","date":"2023-11-09","objectID":"/posts/git%E5%8D%8F%E4%BD%9C/:1:0","tags":["Git"],"title":"Git 协作","uri":"/posts/git%E5%8D%8F%E4%BD%9C/"},{"categories":["学习"],"content":"添加 SSH 密钥至 ssh-agent eval \"$(ssh-agent -s)\" ssh-add ~/.ssh/id_rsa ","date":"2023-11-09","objectID":"/posts/git%E5%8D%8F%E4%BD%9C/:2:0","tags":["Git"],"title":"Git 协作","uri":"/posts/git%E5%8D%8F%E4%BD%9C/"},{"categories":["学习"],"content":"复制公钥 查看本地公钥，复制然后添加到需要设置公钥的代码托管平台 cat ~/.ssh/id_rsa.pub ","date":"2023-11-09","objectID":"/posts/git%E5%8D%8F%E4%BD%9C/:3:0","tags":["Git"],"title":"Git 协作","uri":"/posts/git%E5%8D%8F%E4%BD%9C/"},{"categories":["学习"],"content":"项目绑定 假设我在 Github 上面有一个仓库，本地有项目需要推送到这个仓库去 在本地项目中执行下面命令指定远程仓库地址 git remote add \u003cname\u003e \u003curl\u003e # 一般为 git remote add origin \u003cgit开头/Https开头的地址\u003e 查看绑定的远程地址 git remote -v 如果想要移除这个绑定 git remote remove \u003cname\u003e 然后推送的时候指定远程的 master 分支 git push --set-upstream origin master # 或者下面一样 git push -u origin master 下面这是遇到了错误 $ git push --set-upstream origin master ssh: connect to host 10.88.4.34 port 22: Connection timed out fatal: Could not read from remote repository. Please make sure you have the correct access rights and the repository exists. $ git pull origin master From http://10.88.4.34:9091/10064602/dockmaintenancemanagement * branch master -\u003e FETCH_HEAD fatal: refusing to merge unrelated histories 解决 git pull origin master --allow-unrelated-histories git branch -m 旧分支名 新分支名 git reset HEAD^ git commit -am \"\u003c提交内容\u003e\" git log --oneline git config --global user.name \"\u003c用户名\u003e\" git config --global user.email \"\u003c邮箱\u003e\" git commit --amend --reset-author git pull # 同步本地远端信息 git checkout -b \u003c新分支名\u003e \u003c远程主机名\u003e/\u003c远程分支名\u003e # 基于远程分支代码代码开一个本地分支 git push origin \u003c新分支名\u003e # 将代码推送到远程分支，即在远程开一个同名分支 git branch --set-upstream-to=\u003c远程主机名\u003e/\u003c远程分支名\u003e \u003c本地分支名\u003e # 设置本地分支追踪远程分支 git push 提交代码 Git 提交前缀规范 commit 的类型： feat: 新功能、新特性 fix: 修改 bug perf: 更改代码，以提高性能（在不影响代码内部行为的前提下，对程序性能进行优化） refactor: 代码重构（重构，在不影响代码内部行为、功能下的代码修改） docs: 文档修改 style: 代码格式修改, 注意不是 css 修改（例如分号修改） test: 测试用例新增、修改 build: 影响项目构建或依赖项修改 revert: 恢复上一次提交 ci: 持续集成相关文件修改 chore: 其他修改（不在上述类型中的修改） release: 发布新版本 workflow: 工作流相关文件修改 参考： https://www.thisfaner.com/p/ssh-key-git-usage/ https://www.thisfaner.com/p/ssh-agent/ ","date":"2023-11-09","objectID":"/posts/git%E5%8D%8F%E4%BD%9C/:4:0","tags":["Git"],"title":"Git 协作","uri":"/posts/git%E5%8D%8F%E4%BD%9C/"},{"categories":["学习"],"content":" 获取当前路径的 url 可以使用Window：location 属性，然后通过这个 url 创建一个 JavaScript 内置 URL 类的实例对象 const url = new URL(window.location) const param = url.searchParams.get(\"{{param}}\") 这样看似乎没有问题，先获取 URL 对象，然后用searchParams属性得到请求参数，最后用get方法获取请求参数 searchParams属性：返回一个URLSearchParams对象，可以调用URLSearchParams对象各种方法，对查询字符串进行非常方便的处理 下面看个例子，这里例子没有任何问题，可以获取 url 中的 params const url = new URL(\"https://example.com/a/b?foo=1\u0026bar=2\") const foo = url.searchParams.get(\"foo\") const bar = url.searchParams.get(\"bar\") console.log(\"foo\", foo) console.log(\"bar\", bar) // 输出结果 foo 1 bar 2 再看下面 url 中带有#号的例子 const url = new URL(\"https://example.com/a/#/b?foo=1\u0026bar=2\") const foo = url.searchParams.get(\"foo\") const bar = url.searchParams.get(\"bar\") console.log(\"foo\", foo) console.log(\"bar\", bar) // 输出结果 foo null bar null const params = new URLSearchParams(\"https://example.com/a/#/b?foo=1\u0026bar=2\") const foo = params.get(\"foo\") const bar = params.get(\"bar\") console.log(\"foo\", foo) console.log(\"bar\", bar) 解决方法 const url = window.location.href const search = Object.fromEntries( new URL(url.replace(\"#\", \"\")).searchParams ) const { token, userNumber } = search new URLSearchParams(\"http://h5.shasteel.cn/h5/0f46cef3-f7eb-483a-88ff-6f7e3c1394d8/#/home?\u0026token=865c70f3-742e-4178-bObb-7d1b64b8e893\u0026userNumber=10064602\").get(\"token\") new URLSearchParams(\"http://h5.shasteel.cn/h5/0f46cef3-f7eb-483a-88ff-6f7e3c1394d8/home?\u0026token=865c70f3-742e-4178-bObb-7d1b64b8e893\u0026userNumber=10064602\").get(\"userNumber\") 参考 https://developer.mozilla.org/zh-CN/docs/Web/API/URLSearchParams https://www.zhangxinxu.com/wordpress/2019/08/js-url-urlsearchparams/ ","date":"2023-10-18","objectID":"/posts/url%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0params%E8%8E%B7%E5%8F%96/:0:0","tags":["JavaScript"],"title":"URL请求参数Params获取","uri":"/posts/url%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0params%E8%8E%B7%E5%8F%96/"},{"categories":null,"content":" 同步模式与异步模式 ","date":"2023-10-09","objectID":"/posts/javascript%E5%BC%82%E6%AD%A5/:0:0","tags":null,"title":"JavaScript 异步","uri":"/posts/javascript%E5%BC%82%E6%AD%A5/"},{"categories":null,"content":"同步模式 JavaScript 语言的执行是单线程的，从执行代码来看，是单独一条一条语句从上至下执行，但是这样就会存在阻塞，比如某个操作比较费时（文件读写、网络IO等）下面的代码就不得不等待这个耗时操作执行完成后在执行，显然这种方式非常影响整个程序的使用。 为什么 JavaScript 不设计成多线程执行语言，举个例子，在 Web 应用中，A 函数删除了一个 DOM 节点，B 函数修改了同一个 DOM 节点，那么之后我是使用 A 函数的执行结果还是 B 函数的执行结果？这样会出现很多的问题 ","date":"2023-10-09","objectID":"/posts/javascript%E5%BC%82%E6%AD%A5/:1:0","tags":null,"title":"JavaScript 异步","uri":"/posts/javascript%E5%BC%82%E6%AD%A5/"},{"categories":null,"content":"异步模式 异步模式大概是指运行环境提供的 API 是以同步或者异步模式进行工作的，同步模式指 JavaScript 代码会以同步模式执行，但是其某些 API 会调用其他线程完成某些工作。换句话说，JavaScript 是单线程工作的，但其浏览器并不是单线程工作的，执行 JavaScript 的线程是单线程的。 回调函数 所有异步编程方案的根基，由调用者定义，交给执行者执行的函数 Promise 一种更优雅的异步编程统一方案 ","date":"2023-10-09","objectID":"/posts/javascript%E5%BC%82%E6%AD%A5/:2:0","tags":null,"title":"JavaScript 异步","uri":"/posts/javascript%E5%BC%82%E6%AD%A5/"},{"categories":null,"content":"基本用法 // Promise 基本用法 const promise = new Promise((resolve, reject) =\u003e { // 承诺达成后需要执行的函数 resolve(100); // 承诺失败后需要执行的函数 reject(new Error(\"Promise rejected\")); }); promise.then( (value) =\u003e { console.log(\"resolve\", value); }, (error) =\u003e { console.log(\"rejected\", error); }, ); ","date":"2023-10-09","objectID":"/posts/javascript%E5%BC%82%E6%AD%A5/:2:1","tags":null,"title":"JavaScript 异步","uri":"/posts/javascript%E5%BC%82%E6%AD%A5/"},{"categories":null,"content":"Ajax 例子 // Promise 方式的 AJAX const ajax = (url) =\u003e { return new Promise((resolve, reject) =\u003e { var xhr = new XMLHttpRequest(); xhr.open(\"GET\", url); xhr.responseType = \"json\"; xhr.onload = () =\u003e { if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; xhr.send(); }); }; const url = \"http://localhost:8081/tcarSpotCheckItem/listInspectionItems/装载机\"; ajax(url).then( (res) =\u003e { console.log(\"resolve\", res.data.data); }, (error) =\u003e { console.log(\"reject\", error); }, ); ","date":"2023-10-09","objectID":"/posts/javascript%E5%BC%82%E6%AD%A5/:2:2","tags":null,"title":"JavaScript 异步","uri":"/posts/javascript%E5%BC%82%E6%AD%A5/"},{"categories":null,"content":"链式调用 Promise 对象的 then 方法会返回一个全新的 Promise 对象 后面的 then 方法就是在为上一个 then 返回的 Promise 注册回调 前面 then 方法中回调函数的返回值会作为后面 then 方法回调的参数 如果回调中返回的是 Prmose，那么后面 then 方法的回调会等待它的结束 ajax(url).then( (res) =\u003e { // 成功 }, (error) =\u003e { // 失败 }, ); ajax(url) .then((res) =\u003e { // 成功 }) .catch((error) =\u003e { // 失败 }); // catch 方法其实就是 then 方法的别名，换言之，调用 catch 等价于下面的 then 写法 ajax(url) .then((res) =\u003e { // 成功 }) .then(undefined, (error) =\u003e { // 失败 }); ","date":"2023-10-09","objectID":"/posts/javascript%E5%BC%82%E6%AD%A5/:2:3","tags":null,"title":"JavaScript 异步","uri":"/posts/javascript%E5%BC%82%E6%AD%A5/"},{"categories":null,"content":"静态方法 resolve foo 将会作为 Promise 成功结果返回，然后注册返回 Promise 的成功回调 Promise.resolve(\"foo\").then((value) =\u003e { console.log(value); }); 等价于下面写法，新的 Promise 对象掉调用了成功回调，并传入了 foo 字符串，后面在将返回的 Promise 对象注册成功回调 new Promise((resolve) =\u003e { resolve(\"foo\"); }).then((value) =\u003e { console.log(value); }); 输出结果都是foo 如果 resolve 接收的是一个 Promise 对象 通过 resolve 返回的 Promise 与原来 Promise 相同 const p1 = new Promise((resolve, reject) =\u003e {}); const p2 = Promise.resolve(p1); console.log(p1 === p2); // 输出 true; reject Promise.reject(\"anything\").catch((error) =\u003e { console.log(error); }); // 输出 anything; ","date":"2023-10-09","objectID":"/posts/javascript%E5%BC%82%E6%AD%A5/:2:4","tags":null,"title":"JavaScript 异步","uri":"/posts/javascript%E5%BC%82%E6%AD%A5/"},{"categories":["学习"],"content":" 模板 泛型，是一种将类型参数化达到代码复用的技术，C++中使用模板来实现泛型 模板的使用格式：template \u003ctypename\\class T\u003e 模板没有被使用时，是不会被实例化出来的 模板的声明和实现如果分离到 .h 和 .cpp 中，会导致链接错误 编译，链接过程 头文件不参与编译 每个 cpp 文件都是单独编译 头文件不参与编译，在包含有头文件的 cpp 文件中，会直接将头文件的内容进行拷贝到 cpp 文件中，真正参与编译的是 cpp 文件，编译器会对每个 cpp 文件单独编译成 .obj 文件（也就是生成汇编代码/机器码），之后对编译生成的 .obj 进行链接，多个 .obj 文件会被整合成一个可执行文件 新特性：比如说 C++17 for 循环可以定义变量，但是转化为汇编代码和写在外面没有什么不同，这种限制作用域的都是编译器特性 sub 汇编代码，分配栈空间 ","date":"2023-04-18","objectID":"/posts/c++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/:0:0","tags":["C++","C"],"title":"C++ 其他语法","uri":"/posts/c++%E5%85%B6%E4%BB%96%E8%AF%AD%E6%B3%95/"},{"categories":["学习"],"content":" C++基础语法 ","date":"2023-04-18","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:0","tags":["C++","C"],"title":"C++ 基础语法","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["学习"],"content":"函数重载 Debug 模式：生成很多调试信息，生产的可执行文件比较臃肿 Release 模式：去除调试信息，生产的可执行文件比较简洁高效 规则： 函数名相同 函数参数个数不同、顺序不同、类型不同 注意事项： 函数返回值与函数重载无关（返回值类型不同不能构成函数重载） int func(int num) { } long func(int num) { } 这两个函数不能构成函数重载，vs提示无法重载仅按返回类型区分的函数 调用函数时，实参的隐式类型转换可能会产生二义性 void func(long num) { cout \u003c\u003c \"func(long num)--\" \u003c\u003c num \u003c\u003c endl; } void func(double num) { cout \u003c\u003c \"func(double num)--\" \u003c\u003c num \u003c\u003c endl; } int main(int argc, char const *argv[]) { func(10); return 0; } 语句 func(10) 编译器不知道调用哪个函数，因为 10 既可以是 long 类型，又可以是 double 类型 本质：C++ 采用了 name mangling或者叫name decoration 技术，编译器默认会对符号名（比如函数名）进行改编、修饰，重载时会生成多个不同的函数名，但是不同的编译器有不同的规则 #include \u003ciostream\u003e using namespace std; void func(int num) { cout \u003c\u003c \"func(int num)--\" \u003c\u003c num \u003c\u003c endl; } void func(long num) { cout \u003c\u003c \"func(long num)--\" \u003c\u003c num \u003c\u003c endl; } void func(double num) { cout \u003c\u003c \"func(double num)--\" \u003c\u003c num \u003c\u003c endl; } int main(int argc, char const *argv[]) { func(10); func(10L); func(10.0); return 0; } 上述代码的部分汇编如下，可以看到 call 后面的函数名称分别为 _Z4funci、_Z4funcl、_Z4funcd，应该是 g++ 编译器进行符号改编的结果，所以函数不会重名，但是前提是满足函数重载 函数名其实并不重要，在编译器编译后的汇编代码中，调用函数其实就是转到该函数的内存地址，函数名只是一个表象 18 func(10); =\u003e 0x000055555555528c \u003c+15\u003e: mov edi,0xa 0x0000555555555291 \u003c+20\u003e: call 0x555555555199 \u003c_Z4funci\u003e 19 func(10L); 0x0000555555555296 \u003c+25\u003e: mov edi,0xa 0x000055555555529b \u003c+30\u003e: call 0x5555555551e2 \u003c_Z4funcl\u003e 20 func(10.0); 0x00005555555552a0 \u003c+35\u003e: mov rax,QWORD PTR [rip+0xd99] # 0x555555556040 0x00005555555552a7 \u003c+42\u003e: movq xmm0,rax 0x00005555555552ac \u003c+47\u003e: call 0x55555555522e \u003c_Z4funcd\u003e 21 return 0; 0x00005555555552b1 \u003c+52\u003e: mov eax,0x0 ","date":"2023-04-18","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:1:0","tags":["C++","C"],"title":"C++ 基础语法","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["学习"],"content":"默认参数 C++允许函数设置默认函数，在调用的时候可以根据情况省略实参 默认参数只能按照从右往左的顺序 int sum(int v1 = 5, int v2) { return v1 + v2; } int main(int argc, char const *argv[]) { sum(1, 3); return 0; } 上面代码报错：default argument missing for parameter 2 of ‘int sum(int, int)’ 这个编译错误的含义是第二个参数没有默认值，但是在函数声明中却没有提供默认值。这个错误通常发生在使用函数默认参数的情况下。默认参数是在函数声明中指定的，但是如果在函数定义中省略了它们，则编译器将发出此错误。要解决这个错误，您需要在函数定义中为缺失的参数提供一个默认值，或者在函数声明中省略该参数的默认值。 int sum(int v1 = 1, int v2, int v3 = 6) { return v1 + v2 + v3; } int main(int argc, char const *argv[]) { cout \u003c\u003c sum(1, 2, 3); return 0; } 同样的报错：default argument missing for parameter 2 of ‘int sum(int, int, int)’ 默认参数必须是从右往左设定并且需是连续的 int sum(int v1, int v2 = 5, int v3 = 6) { return v1 + v2 + v3; } int main(int argc, char const *argv[]) { cout \u003c\u003c sum(1) \u003c\u003c endl; cout \u003c\u003c sum(1, 2) \u003c\u003c endl; cout \u003c\u003c sum(1, 2, 3) \u003c\u003c endl; return 0; } 运行结果： 12 9 6 如果函数同时有声明和实现，默认参数只能放在函数声明中 其实默认参数的本质就是调用函数传参，比如下面 func() 函数有默认参数，调用 func()，本质上就是调用了 func(1,2) func() 与 func(1,2) 的汇编代码是一样的 void func(int num1 = 1, int num2 = 2) {} 默认参数的值可以是常量、全局符号（全局变量、函数名） 函数重载、默认参数可能会产生二义性（建议优先使用默认参数） int sum(int v1, int v2 = 5) { return v1 + v2; } int sum(int v1 = 1, int v2 = 5, int v3 = 6) { return v1 + v2 + v3; } int main(int argc, char const *argv[]) { cout \u003c\u003c sum(2, 2) \u003c\u003c endl; cout \u003c\u003c sum(8, 4, 3) \u003c\u003c endl; return 0; } 错误：调用重载的‘sum(int, int)’有歧义 cout « sum(2, 2) « endl; 因为 sum(2,2) 调用时候会有二义性 注意：函数调用可以理解为参数从左往右赋值，函数实现的形参可以理解为从右往左赋值 因此，如果没有 sum(int, int) 函数，那么调用 sum(2,2) 相当于调用了 sum(2,2,6) ","date":"2023-04-18","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:2:0","tags":["C++","C"],"title":"C++ 基础语法","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["学习"],"content":"extern “c” 被 extern “c” 修饰的代码会按照 C语言的方式编译 如果函数同时存在声明和实现，那么 extern “c” 应该放在声明，函数实现可以作修饰也可以不修饰 关于C/C++混合开发 ","date":"2023-04-18","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:3:0","tags":["C++","C"],"title":"C++ 基础语法","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["学习"],"content":"内联函数 使用inline修饰函数的声明或者实现，可以使其变为内联函数 建议声明和实现都用inline修饰 特点： 编译器会将函数调用直接展开为函数体代码 可以减少栈空间的开辟也即函数调用的开销 会增大代码的体积即可执行文件 使用内联函数的场景（空间换时间） 函数代码体积不大（尽量不要超过10行代码的函数） 频繁调用的函数 有些函数即使用inline修饰，也不一定会被编译器内联，比如递归函数 ","date":"2023-04-18","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:4:0","tags":["C++","C"],"title":"C++ 基础语法","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["学习"],"content":"内联函数与宏 内联函数和宏，都可以减少函数调用的开销 对比宏，内联函数多了语法检测和函数特性 考虑使用内联函数和宏的时候，优先使用内联函数，因为内联函数具有函数特性 举例一个两者区别 #include \u003ciostream\u003e using namespace std; #define double2(v) v + v int double1(int v) { return v + v; } int main(int argc, char const *argv[]) { int a = 10; int b = 10; cout \u003c\u003c double1(++a) \u003c\u003c \"-\" \u003c\u003c double2(++b); return 0; } 运行结果： 22-24 宏定义本质上是文本替换，调用 double2(++a) 即 double2(++a) ++a + ++a，而该运算根据不同编译器得出的结果可能会不同 而内联函数则是将 ++b 传入，也就是将 11 作为实参传入 double1 函数返回 return 11 + 11 ","date":"2023-04-18","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:5:0","tags":["C++","C"],"title":"C++ 基础语法","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["学习"],"content":"表达式 C++有些表达式可以被赋值，例子如下 例1： int main(int argc, char const *argv[]) { int a = 1; int b = 2; (a = b) = 5; cout \u003c\u003c a \u003c\u003c \"-\" \u003c\u003c b; return 0; } 运行结果： 5-2 分析(a=b)=5，根据优先级，括号内的会先执行，即将 b 的值赋值为 a，而赋值操作=会返回被赋值变量，即返回变量 a，因此下一步将 5 赋值给了 a 变量 验证(a=b)会返回什么 int main(int argc, char const *argv[]) { int a = 1; int b = 2; cout \u003c\u003c \u0026a \u003c\u003c endl; cout \u003c\u003c \u0026(a = b) \u003c\u003c endl; return 0; } 运行结果 0x7ffc4cccfb30 0x7ffc4cccfb30 可以从这里发现(a=b)会返回变量 a 例2： int main(int argc, char const *argv[]) { int a = 3; int b = 2; (a \u003c b ? a : b) = 5; cout \u003c\u003c a \u003c\u003c \"-\" \u003c\u003c b; return 0; } 运行结果 3-5 三目运算符返回变量 b，之后 5 赋值给变量 b ","date":"2023-04-18","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:6:0","tags":["C++","C"],"title":"C++ 基础语法","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["学习"],"content":"const const 是常量的意思，被其修饰的变量不可修改 如果修饰的是类、结构体(的指针)，其成员也不可以更改 思考下面 5 个表达式 int main(int argc, char const *argv[]) { int num = 10; int id = 5; const int *p0 = \u0026num; int const *p1 = \u0026num; int * const p2 = \u0026num; const int * const p3 = \u0026num; int const * const p4 = \u0026num; return 0; } 总结来说可以用一个结论解决：const修饰的是其右边的内容 p0：const 修饰其右边的 *p0，所以 *p0 无法更改（无法通过 p0 变量解引用改变 num 的值），p0 可以更改（可以将 p0 指针指向其他变量的地址），具体可以看图 p1：与 p0 一样，const 修饰 *p1 p2：const 修饰 p2 变量，那么 *p2 可以更改（可通过 p2 变量解引用改变 num 的值），p2 不可以更改（无法改变指向的地址） p3：第一个 const 修饰 *p3，第二个 const 修饰 p3，那么 *p3 与 p3 都不可以更改 p4：跟 p3 一样 思考下图代码 pStu1：*pStu1 是常量（被 const 修饰），pStu1 不是常量 *pStu1 不可修改，其本质上是 pStu1 指向的内存地址的值不可修改，即 stu1 结构体的成员不可修改 pStu1 可以修改 pStu2：*pStu2 不是常量，pStu2 是常量（被 const 修饰） *pStu2 可修改，所以可以修改其指向地址的内存空间 pStu2 不可修改，所以一旦被初始化就更改不了 ","date":"2023-04-18","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:7:0","tags":["C++","C"],"title":"C++ 基础语法","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["学习"],"content":"引用 在 C语言中，使用指针（Pointer）可以间接获取、修改某个变量的值 在 C++中，使用引用（Reference）可以起到跟指针类似的功能 注意点 引用相当于变量的别名，基本数据类型、结构体、枚举、类、指针、数组等都可以有引用 引用一旦定义就必须赋初始值，而且后面不可以做更改 对引用做修改相当于对引用所指向的变量做修改 可以用一个引用初始化另一个引用，相当于一个变量有多个别名 不存在引用的引用、指向引用的指针、引用数组 引用的价值之一：比指针更安全、函数返回值可以被赋值 引用的本质就是指针，只是编译器削弱了它的功能，所以引用就相当于弱化了的指针 证明引用的本质就是指针 看下面一段指针间接修改变量值的代码的汇编 int main(int argc, char const *argv[]) { int age = 3; int *p = \u0026age; *p = 5; return 0; } # AT\u0026T风格 =\u003e 0x0000555555555177 \u003c+30\u003e: movl $0x3,-0x14(%rbp) 0x000055555555517e \u003c+37\u003e: lea -0x14(%rbp),%rax 0x0000555555555182 \u003c+41\u003e: mov %rax,-0x10(%rbp) 0x0000555555555186 \u003c+45\u003e: mov -0x10(%rbp),%rax 0x000055555555518a \u003c+49\u003e: movl $0x5,(%rax) 0x0000555555555190 \u003c+55\u003e: mov $0x0,%eax 0x0000555555555195 \u003c+60\u003e: mov -0x8(%rbp),%rdx 0x0000555555555199 \u003c+64\u003e: sub %fs:0x28,%rdx 0x00005555555551a2 \u003c+73\u003e: je 0x5555555551a9 \u003cmain(int, char const**)+80\u003e 0x00005555555551a4 \u003c+75\u003e: call 0x555555555040 \u003c__stack_chk_fail@plt\u003e 0x00005555555551a9 \u003c+80\u003e: leave 0x00005555555551aa \u003c+81\u003e: ret # Intel风格 # int age = 3; # rbp-0x14就是age的地址值，DWORD是4字节，将0x3赋值到地址值为rbp-0x14初始的连续4个字节，采用小端模式 =\u003e 0x0000555555555177 \u003c+30\u003e: mov DWORD PTR [rbp-0x14],0x3 # int *p = \u0026age; # rax保存rbp-0x14的地址值 0x000055555555517e \u003c+37\u003e: lea rax,[rbp-0x14] # rax赋值给rbp-0x10地址的指针变量p，QWORD是8字节(64bit指针大小占8B)，即指针p现存储age的地址(rbp-0x14) 0x0000555555555182 \u003c+41\u003e: mov QWORD PTR [rbp-0x10],rax # *p = 5; # 将指针p存储的内容赋值给rax 0x0000555555555186 \u003c+45\u003e: mov rax,QWORD PTR [rbp-0x10] # 将5赋值给地址为rax的内存空间，即age变量的内存空间，大小是DWORD，4字节，达到间接修改age值 0x000055555555518a \u003c+49\u003e: mov DWORD PTR [rax],0x5 0x0000555555555190 \u003c+55\u003e: mov eax,0x0 0x0000555555555195 \u003c+60\u003e: mov rdx,QWORD PTR [rbp-0x8] 0x0000555555555199 \u003c+64\u003e: sub rdx,QWORD PTR fs:0x28 0x00005555555551a2 \u003c+73\u003e: je 0x5555555551a9 \u003cmain(int, char const**)+80\u003e 0x00005555555551a4 \u003c+75\u003e: call 0x555555555040 \u003c__stack_chk_fail@plt\u003e 0x00005555555551a9 \u003c+80\u003e: leave 0x00005555555551aa \u003c+81\u003e: ret 0x0000555555555177 \u003c+30\u003e: mov DWORD PTR [rbp-0x14],0x3 0x0000555555555182 \u003c+41\u003e: mov QWORD PTR [rbp-0x10],rax 看下面引用的代码的汇编，可以发现跟上面指针汇编基本一模一样 int main(int argc, char const *argv[]) { int age = 3; int \u0026p = age; p = 5; return 0; } =\u003e 0x0000555555555177 \u003c+30\u003e: mov DWORD PTR [rbp-0x14],0x3 0x000055555555517e \u003c+37\u003e: lea rax,[rbp-0x14] 0x0000555555555182 \u003c+41\u003e: mov QWORD PTR [rbp-0x10],rax 0x0000555555555186 \u003c+45\u003e: mov rax,QWORD PTR [rbp-0x10] 0x000055555555518a \u003c+49\u003e: mov DWORD PTR [rax],0x5 0x0000555555555190 \u003c+55\u003e: mov eax,0x0 0x0000555555555195 \u003c+60\u003e: mov rdx,QWORD PTR [rbp-0x8] 0x0000555555555199 \u003c+64\u003e: sub rdx,QWORD PTR fs:0x28 0x00005555555551a2 \u003c+73\u003e: je 0x5555555551a9 \u003cmain(int, char const**)+80\u003e 0x00005555555551a4 \u003c+75\u003e: call 0x555555555040 \u003c__stack_chk_fail@plt\u003e 0x00005555555551a9 \u003c+80\u003e: leave 0x00005555555551aa \u003c+81\u003e: ret 引用的大小跟指针一样，因为引用本质就是指针 引用可以被 const 修饰，这样就无法通过引用修改数据了，称为常引用 const 必须写到 \u0026 的左边，才能算是常引用，写到 \u0026 右边没有意义 const 引用特点 可以指向临时数据（常量、表达式、函数返回等） int func() { return -1; } int main(int argc, char const *argv[]) { int num1 = 3; int num2 = 2; const int \u0026ref = 5; const int \u0026ref1 = num1 + num2; const int \u0026ref2 = func(); return 0; } 可以指向不同类型的数据 int main(int argc, char const *argv[]) { int num1 = 3; // double \u0026ref = num1; // 不行 const double \u0026ref = num1; return 0; } 作为函数参数时（此规则也适用于 const 指针） 可以接受 const 和非 const 实参（非 const 引用，只能接受非 const 实参） 可以跟非 const 引用构成重载 int mul(int \u0026v1, int \u0026v2) { return v1 * v2; } int mul(const int \u0026v1, const int \u0026v2) { return v1 * v2; } int main(int argc, char const *argv[]) { // 非 const 参数 int num1 = 2; int num2 = 3; mul(num1, num2); // 调用 int mul(int \u0026v1, int \u0026v2) // const 参数 const int num3 = 3; const int num4 = 4; mul(num3, num4); // 调用 int mul(const int \u0026v1, const int \u0026v2) // const 参数 mul(5, 6); // 调用 int mul(const int \u0026v1, const int \u0026v2) mul(num1, num3); // 调用 int mul(const int \u0026v1, const int \u0026v2) return 0; } 当常引用指向了不同数据类型的变量时，会产生临时变量，即引用指向的并不是初始化的变量 首先看下引用指向相同数据类型时 int main(int argc, char const *argv[]) { int age = 3; const int \u0026rAge = age; age = 5; cout \u003c\u003c age \u003c\u003c endl; cout \u003c\u003c rAge \u003c\u003c endl; return 0; 运行结果 5 5 这个没有什么疑问，下面是上面代码的部分汇编 int age = 3; 0x00005555555552","date":"2023-04-18","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:8:0","tags":["C++","C"],"title":"C++ 基础语法","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["学习"],"content":"汇编 汇编语言种类 8086 汇编 x86 汇编（32bit） x64 汇编（64bit） ARM 汇编（嵌入式，移动设备）等 x64 汇编根据编译器的不同，有两种书写格式 AT\u0026T：比如GCC编译器 Intel：微软的MSVC编译器 汇编语言不区分大小写 AT\u0026T与Intel汇编略有不同 x64 汇编寄存器 x64 在 MSVC 编译器中的部分汇编 jmp：无条件跳转即一定会跳到所给内存地址去执行机器码，下面是一些有条件跳转的指令 变量地址总结：一个变量的地址值，是它所有字节地址中最小的 几个例子 下图是一个简单赋值的汇编代码 ","date":"2023-04-18","objectID":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:9:0","tags":["C++","C"],"title":"C++ 基础语法","uri":"/posts/c++%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["学习"],"content":" 面向对象 ","date":"2023-04-18","objectID":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:0:0","tags":["C++","C"],"title":"C++ 面向对象","uri":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["学习"],"content":"类 C++ 中可以使用class或者struct创建一个类 struct 的默认成员权限是 public class 的默认成员权限是 private 在C中没有类的概念，但是可以通过结构体模拟类，struct中不可以定义函数，可以通过下面例子理解struct如何用函数指针模拟函数 #include \u003cstdio.h\u003e void run() { printf(\"void run()\\n\"); } int cnt; int* sum(int num) { cnt = 2 * num; return \u0026cnt; } struct Person { int age; void (*run)(); int* (*sum)(int); }; int main(int argc, char const *argv[]) { struct Person p; p.age = 10; p.run = run; p.sum = sum; p.run(); int *tmp = p.sum(p.age); printf(\"%d\", *tmp); return 0; } /* run void run() 20 */ 对象中的函数不占用对象的空间，其实在任何时候函数都只会在内存中保存一份 函数的内存不在对象中 #include \u003ciostream\u003e using namespace std; class Person { public: int m_age; void run() { cout \u003c\u003c \"Person::run()-\" \u003c\u003c m_age \u003c\u003c endl; } }; int main(int argc, char const *argv[]) { Person p1; p1.m_age = 1; p1.run(); Person p2; p2.m_age = 2; p2.run(); Person p3; p3.m_age = 3; p3.run(); cout \u003c\u003c \"sizeof(Person):\" \u003c\u003c sizeof(Person); return 0; } /* Person::run()-1 Person::run()-2 Person::run()-3 sizeof(Person):4 */ 下面看汇编代码，可以看到p1/2/3调用的run()函数地址都是一样的（0x555555555298） 11 Person p1; 12 p1.m_age = 1; 0x00005555555551b7 \u003c+30\u003e: mov DWORD PTR [rbp-0x14],0x1 13 p1.run(); =\u003e 0x00005555555551be \u003c+37\u003e: lea rax,[rbp-0x14] 0x00005555555551c2 \u003c+41\u003e: mov rdi,rax 0x00005555555551c5 \u003c+44\u003e: call 0x555555555298 \u003c_ZN6Person3runEv\u003e 14 15 Person p2; 16 p2.m_age = 2; 0x00005555555551ca \u003c+49\u003e: mov DWORD PTR [rbp-0x10],0x2 17 p2.run(); 0x00005555555551d1 \u003c+56\u003e: lea rax,[rbp-0x10] 0x00005555555551d5 \u003c+60\u003e: mov rdi,rax 0x00005555555551d8 \u003c+63\u003e: call 0x555555555298 \u003c_ZN6Person3runEv\u003e 18 19 Person p3; 20 p3.m_age = 3; 0x00005555555551dd \u003c+68\u003e: mov DWORD PTR [rbp-0xc],0x3 21 p3.run(); 0x00005555555551e4 \u003c+75\u003e: lea rax,[rbp-0xc] 0x00005555555551e8 \u003c+79\u003e: mov rdi,rax 0x00005555555551eb \u003c+82\u003e: call 0x555555555298 \u003c_ZN6Person3runEv\u003e ","date":"2023-04-18","objectID":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:1:0","tags":["C++","C"],"title":"C++ 面向对象","uri":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["学习"],"content":"对象的内存布局 对象的地址就是类中第一个成员变量的地址吗？ 当编译器要用一个成员变量的时候，它会根据对象的首地址加上成员的偏移量得到成员变量的地址。 当对象的首地址为0时，得到的成员变量地址就是它的偏移量。 不一定。对象的地址通常是由操作系统分配的内存地址，而类中第一个成员变量的地址只是在对象内存布局中的相对位置之一。具体取决于编译器和操作系统的实现方式，可能还受到对齐和填充等因素的影响。 一般来说对象的地址就是第一个成员变量的地址 #include \u003ciostream\u003e using namespace std; class Person { public: int m_age; int m_id; int m_height; void run() { cout \u003c\u003c \"Person::run()-\" \u003c\u003c m_age \u003c\u003c endl; cout \u003c\u003c \"Person::run()-\" \u003c\u003c m_id \u003c\u003c endl; cout \u003c\u003c \"Person::run()-\" \u003c\u003c m_height \u003c\u003c endl; } }; int main(int argc, char const *argv[]) { Person p; cout \u003c\u003c \u0026p \u003c\u003c endl; cout \u003c\u003c \u0026p.m_age \u003c\u003c endl; cout \u003c\u003c \u0026p.m_id \u003c\u003c endl; cout \u003c\u003c \u0026p.m_height \u003c\u003c endl; cout \u003c\u003c \"sizeof(Person):\" \u003c\u003c sizeof(Person); return 0; } /* run 0x7fffffffdb1c 0x7fffffffdb1c 0x7fffffffdb20 0x7fffffffdb24 sizeof(Person):12 */ ","date":"2023-04-18","objectID":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:2:0","tags":["C++","C"],"title":"C++ 面向对象","uri":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["学习"],"content":"this 函数代码都是放到代码区，不管是什么函数 好了，看下面的代码，思考问题？ main函数中的 p1 和 p2 对象是在栈空间，而对象中的 run() 函数单独在代码区，对象中并不存在 run() 函数，为什么当对象调用run() 函数的时，run() 函数却能访问调用者的成员变量 #include \u003ciostream\u003e using namespace std; class Person { public: int m_age; void run() { cout \u003c\u003c \"Person::run()-\" \u003c\u003c m_age \u003c\u003c endl; } }; int main(int argc, char const *argv[]) { Person p1; p1.m_age = 1; p1.run(); Person p2; p2.m_age = 2; p2.run(); return 0; } /* run Person::run()-1 Person::run()-2 */ 猜想：是不是编译器做了一些隐含操作，比如在调用 run() 函数的时候，“偷偷”将调用者的地址传过去了，其实事实也如此。 this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。 this 作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给 this 赋值。 在《C++函数编译原理和成员函数的实现》一节中讲到，成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁。 将第一点的代码稍作修改便于看汇编代码，看汇编是验证是否将调用者的地址传入成员函数中 #include \u003ciostream\u003e using namespace std; class Person { public: int m_age; void setAge() { m_age = 10; } }; int main(int argc, char const *argv[]) { Person p1; p1.m_age = 1; p1.setAge(); return 0; } 下面看汇编代码（只截取部分） # 很显然是p1.m_age = 1 0x0000555555555177 \u003c+30\u003e: mov DWORD PTR [rbp-0xc],0x1 # 将rbp-0xc地址存入rax寄存器，其实rbp-0xc就是对象p1的地址 =\u003e 0x000055555555517e \u003c+37\u003e: lea rax,[rbp-0xc] 0x0000555555555182 \u003c+41\u003e: mov rdi,rax # 调用函数，也就是p1.setAge() 0x0000555555555185 \u003c+44\u003e: call 0x55555555520c \u003c_ZN6Person6setAgeEv\u003e 下面执行到调用 setAge() 函数的汇编 Dump of assembler code for function _ZN6Person6setAgeEv: =\u003e 0x000055555555520c \u003c+0\u003e: push rbp 0x000055555555520d \u003c+1\u003e: mov rbp,rsp # 这一句将rid值赋值到rbp-0x8地址的8B内存中，也就是起始内存地址为rbp-0x8的8B空间存有p1对象的地址 0x0000555555555210 \u003c+4\u003e: mov QWORD PTR [rbp-0x8],rdi # 将p1对象的地址赋值给rax 0x0000555555555214 \u003c+8\u003e: mov rax,QWORD PTR [rbp-0x8] # 将10赋值给地址为rax的4B内存空间中，也就是p1的地址，也就是p1.m_age的地址 0x0000555555555218 \u003c+12\u003e: mov DWORD PTR [rax],0xa 0x000055555555521e \u003c+18\u003e: nop 0x000055555555521f \u003c+19\u003e: pop rbp 0x0000555555555220 \u003c+20\u003e: ret 不难从汇编中看出，在用p1对象调用成员函数setAge()时，会将p1对象的地址通过 rdi 寄存器保存起来，然后在 setAge() 函数中使用该寄存器，也就是起到了传入成员函数调用者的地址 ","date":"2023-04-18","objectID":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:3:0","tags":["C++","C"],"title":"C++ 面向对象","uri":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["学习"],"content":"指针访问 看直接用对象访问成员变量与用指针访问成员变量的区别，先看示例代码 #include \u003ciostream\u003e using namespace std; class Person { public: int m_age; int m_id; int m_height; }; int main(int argc, char const *argv[]) { Person person; person.m_age = 1; person.m_id = 2; person.m_height = 3; Person* p = \u0026person; p-\u003em_age = 10; p-\u003em_id = 20; p-\u003em_height = 30; return 0; } 看部分汇编，探寻两者访问的区别 对象直接访问：直接在编译的时候就将每个成员变量的地址编译好 指针间接访问所指对象的成员变量： 从指针中取出对象地址 利用对象的地址值 + 成员变量的偏移量计算出成员变量的地址 根据成员变量的地址访问成员变量的存储空间 # 明显下面3句是直接使用对象访问成员变量的汇编代码 =\u003e 0x0000555555555177 \u003c+30\u003e: mov DWORD PTR [rbp-0x14],0x1 0x000055555555517e \u003c+37\u003e: mov DWORD PTR [rbp-0x10],0x2 0x0000555555555185 \u003c+44\u003e: mov DWORD PTR [rbp-0xc],0x3 # 下面是通过指针变量p访问对象的成员变量 # rbp-0x14是person对象的地址 0x000055555555518c \u003c+51\u003e: lea rax,[rbp-0x14] # 将person对象的地址付给以rbp-0x20为地址的8B内存空间，其实rbp-0x20就是指针p的地址 0x0000555555555190 \u003c+55\u003e: mov QWORD PTR [rbp-0x20],rax # p-\u003em_age = 10 0x0000555555555194 \u003c+59\u003e: mov rax,QWORD PTR [rbp-0x20] 0x0000555555555198 \u003c+63\u003e: mov DWORD PTR [rax],0xa # p-\u003em_id = 20 0x000055555555519e \u003c+69\u003e: mov rax,QWORD PTR [rbp-0x20] 0x00005555555551a2 \u003c+73\u003e: mov DWORD PTR [rax+0x4],0x14 # p-\u003em_height = 30 0x00005555555551a9 \u003c+80\u003e: mov rax,QWORD PTR [rbp-0x20] 0x00005555555551ad \u003c+84\u003e: mov DWORD PTR [rax+0x8],0x1e 有了上面的基础，接下来可以思考下面的指针题了 #include \u003ciostream\u003e using namespace std; class Person { public: int m_age; int m_id; int m_height; void display() { cout \u003c\u003c \"m_age:\" \u003c\u003c m_age \u003c\u003c \",m_id:\" \u003c\u003c m_id \u003c\u003c \",m_height:\" \u003c\u003c m_height \u003c\u003c endl; } }; int main(int argc, char const *argv[]) { Person person; person.m_age = 1; person.m_id = 2; person.m_height = 3; Person* p = (Person*)\u0026person.m_id; p-\u003em_age = 10; p-\u003em_id = 20; person.display(); return 0; } 问：该程序的输出结果是？ 问题就出在22行，p指针指向的并不是 person 对象的地址，而是 person 对象的第二个成员变量的地址，且听下面分析 p 指向的地址是 person.m_id 的地址，也就是 [person+4]，那么执行 指针-\u003e成员变量 时，this 指针接收的地址是 [person+4]，而 this 存储的是 person 地址，即使 p 并不真正是 person 的地址，通过强制类型转化骗过了编译器，p-\u003em_age 执行时 编译器会将 10 赋值给 [this] 的内存空间，也就是 [person+4]，而该地址实际上是 person.m_id 地址，因此 10 赋值给了 person 对象的第一个成员变量。那么 p-\u003em_id=20 通过查看汇编 20 赋值到地址为 [this+4] 的内存空间，也就是 [person+4+4]，即 person.m_height 成员变量的地址 所以最终的输出结果是 m_age:1,m_id:10,m_height:20 问：将26行的 person.display() 改为 p-\u003edisplay() 的结果又是如何 乍一看，好像没有什么区别，其实两者存在区别 先回顾一下 对象.成员函数 的执行过程，成员函数并不存储在对象中，单独存储在代码区，那么在本代码中成员函数需要访问在栈空间 person 对象的成员变量，那么就会隐式传入形参 this，而 this 正是调用者的地址，成员函数会根据 this 指针的内容（存储的也就是调用者的地址）找到 person 对象各个成员变量，这样就达到了单独存储在代码区的函数访问存在栈空间对象的效果。 对象.成员函数 这种写法，this 指针存储的内容是调用者的地址，也就是对象的地址，那么指针-\u003e成员函数又有什么不同吗？这种指针调用 this 指针存储的就不是调用者的地址了，而是指针调用者存储的内容，这样也很好理解，因为指针存储的是对象的地址，那么 this 就是会从指针的存储空间取值 好了，知道上面两种调用的区别之后，调用 p-\u003edisplay() 后，代码区的 display() 函数会接收 this 形参（这一点是都存在的），而此时 this 指针的存储内容是 p 指针存储的内容，也就是 person 对象第二个成员变量的地址，得到 this 指针的 display() 函数会通过 this 存储的内容 + 地址偏移来寻找成员变量，即函数内部会将 this存储的内容认为是 m_age 的地址，this存储的内容+4 认为是 m_id 第地址，this存储的内容+8 认为是 m_height 的地址，因此函数访问 m_age 其实是在访问 person.m_id，访问 m_id 其实在访问 person.m_height，访问 m_height 其实在访问不属于 person 对象的地址 因此输出结果可能是：m_age:10,m_id:20,m_height:-183960320 当我再次运行结果变化了：m_age:10,m_id:20,m_height:35649536 ","date":"2023-04-18","objectID":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:4:0","tags":["C++","C"],"title":"C++ 面向对象","uri":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["学习"],"content":"内存布局 ","date":"2023-04-18","objectID":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:5:0","tags":["C++","C"],"title":"C++ 面向对象","uri":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["学习"],"content":"析构函数（Destructor） 析构函数也叫析构器，在对象销毁的时候自动调用，一般用于完成对象的清理工作 特点：函数名以~开头，与类名同名，无返回值（不用写 void ），无参，不可以重载有且只有一个析构函数 注意：通过 malloc 分配的对象 free 的时候不会调用析构函数 之前在构造函数的时候也提到过，通过 malloc 分配的对象也不会调用构造函数，只有通过 new 分配的对象才会调用构造函数，当然，new 申请的对象通过 delete 销毁对象时也会自动调用析构函数 构造函数和析构函数需要声明为 public 才能被外界使用 ","date":"2023-04-18","objectID":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:6:0","tags":["C++","C"],"title":"C++ 面向对象","uri":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["学习"],"content":"初始化列表 默认参数只能写在声明，初始化列表只能写在实现中 初始化列表只能写在实现中比较好理解，因为初始化列表的本质无非就是转化为赋值语句放在了构造器中执行，所以应该放在实现中 那么为什么默认参数只能放声明，在开发过程中，函数的声明和实现是放在不同文件中，需要调用该函数就需要加上头文件，那么如果函数声明没有写默认参数（写在了函数实现里），调用者调用这个函数就会有问题，比如 func 函数的函数声明是 void func(int num1, int num2) ，那么调用的时候就无法通过 func() 调用这个函数，因为编译器直接会报错，即使你明明知道 num1 和 num2 是打算写默认参数的，既然无法通过 func() 调用该函数，那么默认参数写在实现又有什么意义了呢 ","date":"2023-04-18","objectID":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:7:0","tags":["C++","C"],"title":"C++ 面向对象","uri":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["学习"],"content":"构造函数的相互调用 #include \u003ciostream\u003e using namespace std; class Person { public: int m_age; int m_height; Person() { cout \u003c\u003c \"Person::Person()-begin\" \u003c\u003c endl; Person(0, 0); cout \u003c\u003c \"Person::Person()-end\" \u003c\u003c endl; } Person(int age, int height) { cout \u003c\u003c \"Person::Person(int, int)-begin\" \u003c\u003c endl; m_age = age; m_height = height; cout \u003c\u003c \"Person::Person(int, int)-end\" \u003c\u003c endl; } }; int main(int argc, const char *argv[]) { Person p; cout \u003c\u003c p.m_age \u003c\u003c endl; cout \u003c\u003c p.m_height \u003c\u003c endl; return 0; } 运行结果： Person::Person()-begin Person::Person(int, int)-begin Person::Person(int, int)-end Person::Person()-end -1312601984 32574 奇怪，为什么成员变量没有被赋值呢？ 构造函数调用构造函数必须写在初始化列表中 上述无参构造需要该为 Person() :Person(0, 0) { cout \u003c\u003c \"Person::Person()-begin\" \u003c\u003c endl; cout \u003c\u003c \"Person::Person()-end\" \u003c\u003c endl; } 运行结果： Person::Person(int, int)-begin Person::Person(int, int)-end Person::Person()-begin Person::Person()-end 0 0 回到上面的问题，为什么第一段代码没有将值赋值给成员变量 Person() { Person(0, 0); } 其实 Person(0, 0) 是创建了一个匿名的 Person 对象，等同于下面代码 Person() { Person p; p.m_age = 0; p.m_height = 0; } // 或者等价下面 Person() { Person p(0, 0); } ","date":"2023-04-18","objectID":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:7:1","tags":["C++","C"],"title":"C++ 面向对象","uri":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["学习"],"content":"父类构造函数 子类的构造函数默认会调用父类的无参构造函数 如果子类的构造函数显式的调用了父类的有参构造函数，就不会再去默认调用父类的无参构造函数 如果父类缺少无参构造函数，子类的构造函数必须显示的调用父类的有参构造函数 如果父类没有任何构造函数，那么子类构造函数不会生成父类无参构造函数并且调用它 ","date":"2023-04-18","objectID":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:7:2","tags":["C++","C"],"title":"C++ 面向对象","uri":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["学习"],"content":"const 能够创建 const 对象的类中成员变量都是 const 或者 static 的，成员函数没有要求 也即存在非 const 和非 static 的成员变量创建不了 const 对象 const 成员函数不能调用非 const 以及非 static 成员函数 const 对象只能调用 const 成员函数，static 成员函数 ","date":"2023-04-18","objectID":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/:8:0","tags":["C++","C"],"title":"C++ 面向对象","uri":"/posts/c++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"categories":["学习"],"content":"1 左值/右值 能去地址的都是左值，反之 左值/右值引用 引入右值引用的目的是实现移动语义 下面看一个例子 #include \u003ciostream\u003e using namespace std; class Car { public: int m_price; Car(int price = 9) : m_price(price) {} }; Car getTemp() { return Car(); } int main(int argv, char* argc[]) { int\u0026\u0026 a = 3; // 3 是右值，a 是右值引用，但它是一个左值（能取地址） int b = 4; // b 和 4 都是左值 int\u0026\u0026 c = b + 1; // b+5 是右值，c 是右值引用（同时也是左值） Car\u0026\u0026 car = getTemp(); // getTemp() 返回的是右值（临时变量）,car 是右值引用（同时也是左值） cout \u003c\u003c \"a=\" \u003c\u003c a \u003c\u003c endl; cout \u003c\u003c \"c=\" \u003c\u003c c \u003c\u003c endl; cout \u003c\u003c \"car.m_price=\" \u003c\u003c car.m_price \u003c\u003c endl; // 下面3个变量都可以取地址，是左值 cout \u003c\u003c \"\u0026a=\" \u003c\u003c \u0026a \u003c\u003c endl; cout \u003c\u003c \"\u0026c=\" \u003c\u003c \u0026c \u003c\u003c endl; cout \u003c\u003c \"\u0026car.m_price=\" \u003c\u003c \u0026car.m_price \u003c\u003c endl; return 0; } /* a=3 c=5 car.m_price=9 \u0026a=0x7ffd8d0922d0 \u0026c=0x7ffd8d0922d4 \u0026car.m_price=0x7ffd8d0922d8 */ 左值引用只能绑定（关联、指向）左值 右值引用只能绑定右值，如果绑定不对，编译器报错 比如我把上面代码改动一下，编译器就会报错 将右值赋给左值引用，报错 将左值赋给右值引用，报错 常量左值引用是一个万能的引用类型，它可以绑定非常量左值、常量左值、右值，而且绑定右值的时候，常量左值引用还可以像右值一样将右值的生命周期延长，缺点是只能读不能修改 移动语义 如果一个对象中有堆区资源，需要编写拷贝构造函数和赋值函数，实现深拷贝 深拷贝把对象中的堆区资源赋值一份，如果源对象是临时对象，拷贝完就释放了，这样会造成没有意义的资源申请与资源释放，如果能够直接使用源对象拥有的资源，可以节省资源的申请和释放的时间，C++11新增加的移动语义就能够做到 实现移动语义需要增加两个函数：移动构造函数和移动赋值函数 移动构造函数： 移动赋值函数： 拷贝构造函数和赋值函数 拷贝构造函数和赋值函数都是用于对象拷贝的，但它们有不同的调用时机和语义： 拷贝构造函数是在创建新对象并用另一个同类型对象初始化它时调用的。例如： MyClass a; MyClass b(a); // 调用拷贝构造函数，将 b 初始化为 a 的副本 拷贝构造函数的声明通常为： MyClass(const MyClass\u0026 other); 其中 other 是要拷贝的对象的引用。 赋值函数是在已有对象被赋值为另一个同类型对象时调用的。例如： MyClass a, b; b = a; // 调用赋值函数，将 b 赋值为 a 的副本 赋值函数的声明通常为： MyClass\u0026 operator=(const MyClass\u0026 other); 其中 other 是要拷贝的对象的引用，返回值是当前对象的引用。 需要注意的是，C++11 引入了移动构造函数和移动赋值函数，用于处理右值引用（rvalue reference）的情况。这两个函数在效率上有很大提升，但语义和使用方式与拷贝构造函数和赋值函数有所不同。 假设有一个名为MyClass的类，其中包含一个指向动态分配内存的指针ptr，可以通过以下代码实现赋值函数： class MyClass { public: // 构造函数 MyClass() : ptr(nullptr) {} // 拷贝构造函数 MyClass(const MyClass\u0026 other) { if (other.ptr != nullptr) { ptr = new int(*other.ptr); } } // 赋值函数 MyClass\u0026 operator=(const MyClass\u0026 other) { if (this != \u0026other) { // 释放当前对象的资源 delete ptr; // 分配新的资源 if (other.ptr != nullptr) { ptr = new int(*other.ptr); } else { ptr = nullptr; } } return *this; } // 析构函数 ~MyClass() { delete ptr; } private: int* ptr; }; 在赋值函数中，需要首先判断是否为自我赋值，若是则直接返回当前对象的引用；否则需要先释放当前对象所持有的资源，再根据other对象是否持有资源进行不同的处理，最后返回当前对象的引用。这里返回左值引用是为了支持链式赋值操作，例如a = b = c ","date":"2023-04-18","objectID":"/posts/%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/:0:0","tags":["C++","C"],"title":"左值右值引用","uri":"/posts/%E5%B7%A6%E5%80%BC%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"},{"categories":["学习"],"content":" #include \u003ciostream\u003e using namespace std; int\u0026 increment(int\u0026 num) { num++; return num; } int main() { int x = 5; int\u0026 y = increment(x); std::cout \u003c\u003c x \u003c\u003c std::endl; // 输出 6 y = 10; std::cout \u003c\u003c x \u003c\u003c std::endl; // 输出 10 return 0; } int x = 5; 0x00005555555551ad \u003c+23\u003e: mov DWORD PTR [rbp-0x14],0x5 11 int\u0026 y = increment(x); 0x00005555555551b4 \u003c+30\u003e: lea rax,[rbp-0x14] 0x00005555555551b8 \u003c+34\u003e: mov rdi,rax =\u003e 0x00005555555551bb \u003c+37\u003e: call 0x555555555179 \u003c_Z9incrementRi\u003e 0x00005555555551c0 \u003c+42\u003e: mov QWORD PTR [rbp-0x10],rax 12 std::cout \u003c\u003c x \u003c\u003c std::endl; // 输出 6 0x00005555555551c4 \u003c+46\u003e: mov eax,DWORD PTR [rbp-0x14] 0x00005555555551c7 \u003c+49\u003e: mov esi,eax 0x00005555555551c9 \u003c+51\u003e: lea rax,[rip+0x2e70] # 0x555555558040 \u003c_ZSt4cout@GLIBCXX_3.4\u003e 0x00005555555551d0 \u003c+58\u003e: mov rdi,rax 0x00005555555551d3 \u003c+61\u003e: call 0x555555555070 \u003c_ZNSolsEi@plt\u003e 0x00005555555551d8 \u003c+66\u003e: mov rdx,QWORD PTR [rip+0x2dd9] # 0x555555557fb8 0x00005555555551df \u003c+73\u003e: mov rsi,rdx 0x00005555555551e2 \u003c+76\u003e: mov rdi,rax 0x00005555555551e5 \u003c+79\u003e: call 0x555555555040 \u003c_ZNSolsEPFRSoS_E@plt\u003e 13 y = 10; 0x00005555555551ea \u003c+84\u003e: mov rax,QWORD PTR [rbp-0x10] 0x00005555555551ee \u003c+88\u003e: mov DWORD PTR [rax],0xa 14 std::cout \u003c\u003c x \u003c\u003c std::endl; // 输出 10 0x00005555555551f4 \u003c+94\u003e: mov eax,DWORD PTR [rbp-0x14] 0x00005555555551f7 \u003c+97\u003e: mov esi,eax 0x00005555555551f9 \u003c+99\u003e: lea rax,[rip+0x2e40] # 0x555555558040 \u003c_ZSt4cout@GLIBCXX_3.4\u003e 0x0000555555555200 \u003c+106\u003e: mov rdi,rax 0x0000555555555203 \u003c+109\u003e: call 0x555555555070 \u003c_ZNSolsEi@plt\u003e 0x0000555555555208 \u003c+114\u003e: mov rdx,QWORD PTR [rip+0x2da9] # 0x555555557fb8 0x000055555555520f \u003c+121\u003e: mov rsi,rdx 0x0000555555555212 \u003c+124\u003e: mov rdi,rax 0x0000555555555215 \u003c+127\u003e: call 0x555555555040 \u003c_ZNSolsEPFRSoS_E@plt\u003e 15 return 0; 0x000055555555521a \u003c+132\u003e: mov eax,0x0 Dump of assembler code for function _Z9incrementRi: 4 int\u0026 increment(int\u0026 num) { =\u003e 0x0000555555555179 \u003c+0\u003e: push rbp 0x000055555555517a \u003c+1\u003e: mov rbp,rsp 0x000055555555517d \u003c+4\u003e: mov QWORD PTR [rbp-0x8],rdi 5 num++; 0x0000555555555181 \u003c+8\u003e: mov rax,QWORD PTR [rbp-0x8] 0x0000555555555185 \u003c+12\u003e: mov eax,DWORD PTR [rax] 0x0000555555555187 \u003c+14\u003e: lea edx,[rax+0x1] 0x000055555555518a \u003c+17\u003e: mov rax,QWORD PTR [rbp-0x8] 0x000055555555518e \u003c+21\u003e: mov DWORD PTR [rax],edx 6 return num; 0x0000555555555190 \u003c+23\u003e: mov rax,QWORD PTR [rbp-0x8] 7 } 0x0000555555555194 \u003c+27\u003e: pop rbp 0x0000555555555195 \u003c+28\u003e: ret ","date":"2023-04-18","objectID":"/posts/%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/:0:0","tags":["C++","C"],"title":"引用传递","uri":"/posts/%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"},{"categories":["学习"],"content":" 局域网 电话线入户（ADSL） 网线入户 光纤入户 家用无线路由器的逻辑结构 相当于里面有一个小型交换机，这就解释了为什么家用路由器连接后都属于同一个私网网段（LAN） 公网Vs私网 先看一下ABCD类地址 # A类地址：0开头 00000000:00000000:00000000:00000000 -\u003e 0.0.0.0 # 不使用 00000001:00000000:00000000:00000000 -\u003e 1.0.0.0 ........ 01111111:11111111:11111111:11111111 -\u003e 127.255.255.255 (127=255-2^7=255-128) # B类地址：10开头 10000000:00000000:00000000:00000000 -\u003e 128.0.0.0 10000000:00000000:00000000:00000001 -\u003e 128.0.0.1 ...... 10111111:11111111:11111111:11111111 -\u003e 191.255.255.255 (191=255-2^6) # C类地址：110开头 11000000:00000000:00000000:00000000 -\u003e 192.0.0.0 11000000:00000000:00000000:00000001 -\u003e 192.0.0.1 ...... 11011111:11111111:11111111:11111111 -\u003e 223.255.255.255 (223=255-2^5) # D类地址：1110开头 11100000:00000000:00000000:00000000 -\u003e 224.0.0.0 ...... 11101111:11111111:11111111:11111111 -\u003e 239.255.255.255 (239=255-2^4) # E类地址：11110开头 11110000:00000000:00000000:00000000 -\u003e 240.0.0.0 ...... 11111111.11111111.11111111.11111111 -\u003e 255.255.255.255 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:0:0","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"公网 Internet 上的路由器只有到达公网的路由表，没有到达私网的路由表 公网IP由因特网信息中心（Inter NIC）统一分配和管理 ISP需要向Inter NIC申请公网IP ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:1:0","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"私网 主要用于局域网，下面是几个保留的私网网段 A类：10.0.0.0/8 B类：172.16.0.0/16 - 172.32.0.0/16 C类：192.168.0.0/24 - 192.168.255.0/24 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:2:0","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"NAT 私网IP访问 Internet 需要进行 NAT 转化为公网IP NAT（Network Address Translation）转化 这一步由路由器完成 NAT 特点 可以节约公网IP 会隐藏内部真实IP NAT 分类 静态转换（一对一转换） 手动配置 NAT 映射表 比如私网A映射成公网A，私网B映射成公网B 动态转化（一对一转换） 定义外部地址池，动态随机转换 PAT（Port Address Translation）（多对一） 采用端口多路复用方式，通过端口号标识不同的数据流 目前应用最广泛的NAT实现方式 一对一的方式并不能节约公网IP，还是一个私网对应一个公网，而多对一的方式能够实现一个公网对应多个私网，那么它的实现方式简单说就是每个私网IP对应公网IP的一个端口，进而实现端口多路复用 网络分层 网络请求过程，每层加上自己的一些信息，比如首部和尾部 5 层参考模型 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:3:0","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"物理层 物理层定义了接口标准，线缆标准，传输方式，传输速率等 数字信号（Digital Signal） Vs 模拟信号（Analog Signal） 模拟信号适合长距离传输，但是抗干扰能力差，受到干扰变形很难矫正 数字信号频率高，衰减快，不适合长距离传输，但是抗干扰能力强，受到干扰后波形失真可以修复 数据通信模型 信道（Channel） ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:4:0","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"数据链路层 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:5:0","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"链路 链路：从一个节点到相邻节点的一段物理线路（有线/无线），中间没有其他交换节点 这里集线器只是起到数据转发，没有对数据进行任何处理，因此它并不是一个交换节点 而交换机会对数据做处理，交换机内部存有 MAC 地址表，能够知道数据传给谁 集线器是一种将多个计算机或网络设备连接在一起的网络设备，它可以加强信号并将数据从一个端口转发到另一个端口。在集线器中，所有设备都连接在同一个物理链路上，这意味着所有设备共享相同的网络带宽和碰撞域。 由于集线器只是简单地将来自一个端口的数据复制到所有其他端口，因此集线器两端被视为同一链路。当一个设备发送数据到集线器时，集线器会将该数据广播到所有其他端口，因此该数据可以被连接到该集线器的任何其他设备接收。因此，在集线器中，所有设备都处于同一逻辑链路上，即它们共享相同的广播域和碰撞域。 下面两个链路的网络都是以太网（Ethernet），它传输的是以太网帧 计算机0-路由器0：使用了CSMA/CD协议，传输的帧称为以太网帧 计算机1-路由器2：用交换机组建的网络，支持全双工通信，不需要使用CSMA/CD协议，但传输的帧依然是以太网帧 注意：路由器0与路由器1（直连）之间走的是PPP协议帧，PPP协议不需要源MAC和目标MAC，如果路由器0与路由器1之间有一个交换机（比如下图），那么他们之间的两条链路走的就不是PPP协议了，是以太网帧，也就是说，还存在源MAC和目标MAC 数据链路：在一条链路上传输数据时，需要有对应的传输协议来控制数据的传输 比如：广播信道的CSMA/CD协议（同轴电缆、集线器组成的网络）、点对点信道的PPP协议（比如两个路由器之间的链路） 虽然数据链路都会把IP数据包加上首部和尾部，但是根据数据链路层协议的不同（比如PPP协议与CSMA/CD协议）加入的首部和尾部也不相同。 这里举个例子，比如上图中计算机0要给计算机1发送数据，首先在计算机0与路由器0之间使用的是以太网技术，假设用的是CSMA/CD协议，那么计算机0与路由器0之间的链路就会在IP数据包的基础上加上首部和尾部，加上属于CSMA/CD协议的首部和尾部，链路层封装好的数据在交给物理层处理，传输到路由器0后，路由器0会将数据解封装即将之前对IP数据包封装的首部和尾部去掉，直到得到IP数据包为止，由于路由器之间传输数据是用的另外一个协议，假设使用的是PPP协议，那么此时路由器0会将解封装得到的IP数据包加上PPP协议的首部和尾部，之后物理层处理后发送给路由器1，然后重复上述过程，直到将数据传送到计算机1为止 数据链路层的 3 个基本问题 封装成帧 数据链路层会将 IP 数据包的两端加上帧首部和帧尾部 帧的数据部分是网络层传下来的 IP 数据包（Packet） 最大传输单元（Maximum Transfer Unit）：每一种数据链路协议都规定了能够传送帧的数据长度上限，以太网的 MTU 是 1500 Byte 透明传输 如果数据部分出现了帧结束符/帧开始符，那么接收端就会认为该处是帧结束符/帧开始符，这样就会出现问题。解决方法可以让数据部分不可能出现帧结束符/帧开始符，即数据部分一旦出现了 SOH/EOT，就对他们进行转义，在 IP 数据包中的 SOH/EOT/ESC 字符前面插入转义字符 ESC 差错检验 FCS 是根据帧数据部分和数据链路层首部计算得出的，如果接收端用同样的方法得出的 FCS 与数据帧中的 FCS 不匹配，那么网卡就会丢弃该帧数据，这也就是为什么抓包工具看不到 FCS 数据，因为出错的都被网卡丢弃了 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:5:1","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"网卡 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:5:2","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"CSMA/CD协议 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:5:3","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"Ethernet V2帧 格式 首部：源MAC地址+目标MAC地址+类型 尾部：FCS 以太网帧：首部+尾部+数据 数据的长度至少是 64-6-6-2-4=46B 为什么Ethernet V2没有帧开始符和帧结束符：以太网V2使用曼彻斯特编码，接收端接收帧的过程中只要发现没有信号跳变，就认为帧结束 当数据部分少于46B时 数据链路层会在IP数据包后面添加一些字节用来填充 接收端会将填充的字节去掉 长度总结 以太网帧的数据长度（IP数据包长度）：46B~1500B 以太网帧长度：64B~1518B（源MAC地址+目标MAC地址+网络类型+IP数据包+FCS） ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:5:4","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"PPP协议 帧格式 字节填充 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:5:5","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"网络层 网络层首部 网络层数据包（IP数据包，Packet）由首部、数据两部分组成 数据部分：很多时候是由传输层传递下来的数据段（Segment） 因为有些协议只是工作在最下面三层，比如 ARP 协议，IP 协议，ICMP 协议，这些都不属于运输层 版本：占4位 IPV4：0b0100 IPV6：0b0110 首部长度（Header Length）：占4位 如果首部没有可变部分，那么就首部就是占用了 20B（最小长度），对应该字段的值就是 0b0101，疑惑：0b0101不是等于十进制的 5 吗，没错，但是这个真实长度是需要乘以数字 4 的，也就是 4*5=20B 那么 4bit 的最大二进制是 0b1111=15，也就是 60B（最大长度） 区分服务（Differentiated Services Field）：占8位，可以用于提高网络的服务质量（Qos） 总长度（Total Length）：占 16位 网络层首部+数据的长度之和，最大是 2^16-1=65535B 之前学习数据链路层的帧，帧的数据部分，也就是IP数据包最大的长度MTU不可超过 1500B，那么如果上层传输层传过来的数据加上网络层的首部超过 1500B 怎么办？ 如果IP数据包超过 1500B 就会进行分片（fragments）处理，将每个分片单独加上网络层的首部传输给数据链路层，一些分片到了数据链路层怎么将他们组合起来传递给网络层呢？这就设计到首部的一些数据字段了 标识（Identification）：占16位 数据包的ID，当数据包过大进行分片，同一个数据包的所有片的标识都是一样的 有一个计数器专门管理数据包的ID，每发出一个数据包，ID就加1 标志（Flags）：占3位 第一位（Reserved Bit）：保留 第二位（Don’t Fragment）：1代表不允许分片，0代表允许分片 第三位（More Fragments）：1代表不是最后一片，0代表是最后一片 片偏移（Fragment Offset）：占13位，最大二进制是 0b1111111111111=4095，故最大字节偏移 4095*8=32760B（31.992KB） 片偏移的值乘以 8 才是字节偏移 每一片的长度都是 8 的整数倍 生存时间（Time To Live）：占8位 每个路由器在转发之前都会将 TTL 减 1，一旦发现 TTL 减为 0 了，路由器会返回错误报告 为什么要设置这个字段：最通俗的解释就是路由器形成回路，不设置该字段数据就会一直占用带宽 协议（Protocol）：占8位 表明封装的数据是用的什么协议，数据由上层即运输层传下来 首部校验和（Header Checksum）：由发送端填充，接收端对其使用 CRC 算法以检验 IP 数据报的头部（仅检验头部）在传输过程中是否损坏 32 位源地址和目标地址在整个数据报的传递过程中保持不变 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:6:0","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"书中摘要 当 IP 数据报（首部+数据）长度超过帧的 MTU 时，需要进行分片传输。分片可能发生在发送方也可能发生在中转路由器上，而且可能在传输过程中多次分片，但只有到目标机器上，这些分片才会被内核中的 IP 模块重新组装 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:6:1","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"传输层 传输层有两个协议 TCP（Transmission Control Protocol）：传输控制协议 UDP（User Datagram Protocol）：用户数据报协议 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:7:0","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"UDP UDP是无连接的，减少了建立和释放连接的开销 UDP是尽最大能力交付，不保证可靠交付 UDP协议的格式，首部只有8个字节（TCP的首部至少20个字节） UDP长度：UDP首部+数据长度 UDP检验和（Checksum）：需要利用伪首部+首部+数据三部分计算出 伪首部（12字节）：仅仅在计算检验和时起作用，并不传给网络层，增加伪首部能提高安全性，检错能力更强 端口（Port）：占2字节，端口的取值范围是 0~65535 客户端的源端口是临时开启的随机端口，用完之后就释放 下面是一些程序的默认端口 网络安全 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:7:1","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"HTTP协议安全问题 HTTP 协议的安全问题 先认识几个英文 encrypt：加密 decrypt：解密 plaintext：明文 ciphertext：密文 虚拟人物 防止被窃听 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:8:0","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"不可逆加密 单向散列函数 单向散列函数，可以根据消息内容计算出散列值 散列值的长度和消息的长度无关，无论消息是 1bit、10M、100G 甚至更大，单向散列函数都会计算出固定长度的散列值 无法通过散列值推算内容 特点 根据任意长度的消息，计算出固定长度的散列值 计算速度快，能够快速计算出散列值 消息不同，散列值也不同 具备单向性 单向散列函数也称为 消息摘要函数（message digest function） 哈希函数（hash function） 输出的散列值也称为 消息摘要（message digest） 指纹（fingerprint） 常见的几种单向散列函数 MD4、MD5：能够产生 128 bit 的散列值，MD 即 Message Digest 的缩写，目前已经不安全 MD5 是一种哈希算法，它将任意长度的数据映射成一个固定长度的输出。MD5 哈希值通常表示为 32 位十六进制数字。因为哈希函数是单向的，并且有可能存在相同的哈希值（所谓的哈希冲突），因此暴力破解 MD5 哈希值是非常困难的。 通常，暴力破解 MD5 哈希值需要枚举所有可能的输入字符串并计算其哈希值，直到找到与目标哈希值匹配的输入字符串。由于 MD5 哈希值长度为 32 位，因此可以理论上有 16321632 种可能的输入字符串，所以暴力破解 MD5 哈希值需要极长的时间和计算资源。 实际上，通过使用一些对称密钥算法的技术（如彩虹表，字典攻击等），可以加速 MD5 哈希值的暴力破解。但是，这仍然需要大量的时间和计算资源，具体取决于要破解的哈希值和攻击者的计算能力。 总的来说，暴力破解 MD5 哈希值需要的时间和计算资源取决于许多因素，包括哈希值长度、密码复杂度、攻击者计算能力等等，因此很难给出一个确切的答案。 SHA-1：产生 160 bit 的散列值，目前已经不安全 SHA-2：SHA-256、SHA-384、SHA-512，散列长度分别是 256 bit、384 bit、512 bit SHA-3：全新标准 单向散列函数的应用 检测 应用被篡改，比如一些网站下载软件会提供一串散列值，下载到本地后通过对应的散列函数计算出散列值与官网给出的散列值对比 密码加密：比如前端输入密码先将密码加密在传给后端，后端加盐在存储到数据库中 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:8:1","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"可逆加密 如何加密解密 不管是对称加密和非对称加密，都需要加密算法和密钥 对称加密(Symmetric Cryptography) 对称加密也称对称密码 加密和解密的密钥是相同的 DES、3DES、AES等 DES 英文：Data Encryption Algorithm 3DES 英文：Triple Data Encryption Algorithm EDE3：E是加密（Encryption）的首字母，D 是解密（Decryption）的首字母，3 代表 3 个不同的密钥 如果所有密钥都是相同的，那么结果与普通的 DES 是等价的 如果密钥1、密钥3相同，密钥2不同，称为 DES-EDE2 AES 英文：Advanced Encryption Standard 取代 DES 成为新标准的一种对称加密算法，又称为 Rijndael 算法（作者名字） AES 的密钥长度有 128、192、256 bit 三种 目前 AES 已经逐步取代 DES、3DES，成为首选的加密算法 密钥配送问题 在使用对称加密时，一定会遇到密钥配送问题 下图表示窃听者窃听到了密钥和密文，能够解密出来 有下面几种方法解决密钥配送问题 事先共享密钥（私下共享…） 密钥配送中心（简称 KDC） Diffie-Hellman 密钥交换 非对称加密，密钥配送步骤如下 由消息的接收者生成一对公钥、私钥 将公钥发给消息的发送者 消息发送者使用公钥将对称加密的密钥进行加密 将密文发送给接收者，接受者通过私钥解密得到对称加密的密钥 非对称加密(Asymmetric Cryptography) 非对称加密也称公钥密码 加密用的密钥和解密用的密钥不是相同的 在非对称加密中，密钥分为加密密钥、解密密钥 2 种，他们并不是同一个密钥 加密密钥：一般是公开的，称为公钥（public key） 因此，非对称加密也被称为公钥密码（Public-key Cryptography） 解密密钥：由接受者自己保管，不能公开，称为私钥（Private key） 公钥、私钥 公钥和私钥是一一对应的，不能单独生成 一对公钥和私钥统称为密钥对（key pair） 由公钥加密的密文，必须使用该公钥对应的私钥才能解密 由私钥加密的密文，必须使用该私钥对应的公钥才能解密，应用：数字签名 下面这幅图解释了 2 和 3 两点，注意：右边是数字签名 公钥的合法性 上面提到，通过接收者的公钥进行加密消息，然后发送者发送给接收者，接受者用对应的私钥进行解密，假如中间有个窃听者呢，那么他就可以在中间做文章了，比如伪造公钥，具体看图 那么就引出了公钥的合法性问题，解决方法是证书，下面提及 通信举例 通过公钥加密，私钥解密 比如 A、B、C、D 给 E 发送数据，发送者会用后者接收方 E 的公钥对数据加密，之后发送给 E，E 接受到后用对应的私钥进行解密，即使网络窃听者窃取到密文也无法解密，因为公钥对应的私钥只有 E 有，这种加密方式就避免了密钥在网络上的配送问题，但是通过公钥加密，私钥解密是比较复杂的，效率当然没有对称加密那么高，但是安全性好 通过私钥加密，公钥解密 上面提到了发送数据给 E，那么反过来，E 想发数据给 A 怎么发，用同样的方法，E 用 A 的公钥进行加密然后把密文发送给 A，A 用对应的私钥进行解密即可。但是还有一种方法，即 E 用自己的私钥进行加密，将密文发送给 A，A 用对应的公钥进行解密，一样可以达到 E 发送数据给 A。可能会有疑问，E 的公钥谁都可以获取到，那么这样岂不是跟没加密一样吗？后面的数字签名将会应用到 RSA 目前使用最广泛的非对称加密算法是 RSA RSA 的名字，是 3 位开发者的姓氏首字母组成 对称加密与非对称加密 非对称加密：复杂 -\u003e 安全 -\u003e 加密解密慢 对称解密：简单 -\u003e 不安全 -\u003e 加密解密快 混合密码 为了解决对称加密和非对称加密的各自缺点，达到效率更高的加密方法，使用了对称加密和非对称加密 会话密钥（session key） 为本次通信随机生成的临时密钥 作为对称加密的密钥，用于加密消息，提高速度 加密步骤（发送消息） 首先，消息发送者要拥有消息接受者的公钥 生成会话密钥，作为对称加密的密钥，用于加密消息内容主体 用消息接受者的公钥，加密会话密钥 将前两部生成的密钥结果，一并发送给消息接受者 接受者接受到消息，用自己的私钥解密公钥加密的会话密钥内容，得到会话密钥，再用会话密钥解密消息密文（此时是对称加密） 因此发送出去的内容包括 用会话密钥加密的消息（加密方法：对称加密） 用公钥加密的会话密钥（加密方法：非对称加密） 举例，Alice 发送消息给 Bob 的过程 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:8:2","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"数字签名 数字签名并不是加密，而是解决数据的可靠性问题，即这个消息的确是发送者发的，而不是别人伪装发送者发的，或者篡改发送者的消息 数字签名的过程，这个过程是对整个消息用私钥进行加密，但是私钥进行加密解密速度会比价慢，改进方法看下面 对数字签名过程进行改进，这一种方法是将消息通过单向散列函数得到一串散列值，再对散列值用私钥进行加密（也即签名），这样就解决了对过多消息内容进行签名的性能缺陷 数字签名的完整过程 数字签名疑惑 数字签名是不是很像将非对称加密反过来用 在非对称加密中，发送者需要拥有接受者的公钥 在数字签名中，发送者需要拥有自己的私钥 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:8:3","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"证书 能够解决公钥合法性问题 证书的使用过程 只要签名是假的 那么公钥就不能解密 因为只有私钥加密的 公钥才能解密 私钥只有认证机构知道 而且验证证书的时候只会用认证机构的公钥 所以认证机构的签名不可能做假 证书的注册和下载 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:8:4","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"HTTPS HTTPS(HyperText Transfer Protocol Secure)：超文本传输安全协议，由网景公司于1994年首次提出 常成为：HTTP over TLS、HTTP over SSL、HTTP Secure 使用了HTTPS服务，服务端与客户端传输的所有内容都是加密的（比如请求体、响应头、响应体等） ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:9:0","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"SSL/TLS TLS(Transport Layer Security)：传输层安全性协议 SSL(Secure Sockets Layer)：安全套接层 SSL/TLS 工作在哪一层 HTTP 工作在应用层，HTTPS 对数据加密，但是加密后还是需要递交给下一层的传输层，所以加密的行为是在应用层基础并在传输层之前，所以 SSL/TLS 工作在应用层和传输层之间 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:9:1","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"OpenSSL OpenSSL 是 SSL/TLS 协议的开源实现，支持 Windows、Linux、Mac 等平台 Linux、Mac 一般自带 OpenSSL 如在 Linux 下使用 OpenSSL 生成一个私钥 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:9:2","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":"成本 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:9:3","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":["学习"],"content":" 引用 https://www.bilibili.com/video/BV1Fy4y1Y7n6?t=7814.0\u0026p=17 https://www.bilibili.com/video/BV1Fy4y1Y7n6?t=7412.2\u0026p=18 curl https://api.openai.com/v1/models \\ -H \"Authorization: Bearer $OPENAI_API_KEY\" \\ -H \"OpenAI-Organization: org-yfxKET4BhWsFbmaEsfqNnVtB\" curl https://api.openai.com/v1/chat/completions \\ -H \"Content-Type: application/json\" \\ -H \"Authorization: Bearer $OPENAI_API_KEY\" \\ -d '{ \"model\": \"gpt-3.5-turbo\", \"messages\": [{\"role\": \"user\", \"content\": \"Say this is a test!\"}], \"temperature\": 0.7 }' ppp0 Link encap:Point-to-Point Protocol inet addr:223.145.169.186 P-t-P:223.145.168.1 Mask:255.255.255.255 UP POINTOPOINT RUNNING NOARP MULTICAST MTU:1492 RX packets:1927363 errors:0 dropped:0 overruns:0 frame:0 TX packets:1327515 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:3 RX bytes:1980896866 (1.8 GiB) TX bytes:446459702 (425.7 MiB) 这是 ppp0 网络接口的配置信息。其中，各字段的含义如下： - Link encap：连接类型，这里是 PPP（Point-to-Point Protocol）协议。 - inet addr：网络地址，这里是 223.145.169.186。 - P-t-P：点对点地址，这里是 223.145.168.1。 - Mask：子网掩码，这里是 255.255.255.255，表示没有子网划分。 - UP：接口状态，表示该接口当前处于启动状态。 - POINTOPOINT：连接类型，与 Link encap 字段相同，都是 PPP 协议。 - RUNNING：接口运行状态。 - NOARP：地址解析协议（ARP）状态，表示不进行 ARP 处理。 - MULTICAST：多播状态。 - MTU：最大传输单元，指该接口支持的数据包最大大小。 - RX packets：接收数据包数量。 - errors：接收错误数。 - dropped：丢弃的数据包数量。 - overruns：接收缓冲区溢出次数。 - frame：损坏的数据帧数量。 - TX packets：发送数据包数量。 - carrier：发送过程中发生的错误数。 - collisions：冲突数。 - txqueuelen：传输队列长度。 - RX bytes：接收字节数。 - TX bytes：发送字节数。 ","date":"2023-02-18","objectID":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/:9:4","tags":["HTTP","TCP","IP"],"title":"网络协议","uri":"/posts/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":" 为什么会有这一篇博客？ 我用的是 ArchLinux+DWM，我尝试连接HDMI无法输出到外接显示器上，下面记录了解决问题的过程，由于这个问题牵涉到了显卡，所以以前遇到的显卡切换问题在这里一并解决了，于此同时画面撕裂的问题也得以解决！ 前言 我尝试通过HDMI连接外接显示器，然后我通过xrandr命令查看输出如下，似乎没有检测到HDMI接口的输出设备 ➜ ~ xrandr Screen 0: minimum 8 x 8, current 1920 x 1080, maximum 32767 x 32767 eDP1 connected primary 1920x1080+0+0 (normal left inverted right x axis y axis) 340mm x 190mm 1920x1080 60.00*+ 59.93 1680x1050 59.88 1400x1050 59.98 1600x900 60.00 59.95 59.82 1280x1024 60.02 1400x900 59.96 59.88 1280x960 60.00 1368x768 60.00 59.88 59.85 1280x800 59.81 59.91 1280x720 59.86 60.00 59.74 1024x768 60.00 1024x576 60.00 59.90 59.82 960x540 60.00 59.63 59.82 800x600 60.32 56.25 864x486 60.00 59.92 59.57 640x480 59.94 720x405 59.51 60.00 58.99 640x360 59.84 59.32 60.00 DP1 disconnected (normal left inverted right x axis y axis) VIRTUAL1 disconnected (normal left inverted right x axis y axis) 于是通过上网冲浪，在一个社区看到了一个帖子，这里我截取部分内容(文章链接见最下) 英伟达显卡闭源驱动我已经安装了，也知道独显似乎没起作用，以前也尝试切换独显，但是切换失败了，这个问题就一直没有得到解决，这次要把这个问题给解决掉！ 通过nvidia-settings查看显卡信息 根据ArchWiki的描述，切换显卡的方案如下： ","date":"2022-06-10","objectID":"/posts/archlinux%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8/:0:0","tags":null,"title":"ArchLinux外接显示器","uri":"/posts/archlinux%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8/"},{"categories":null,"content":"使用可切换显卡 使用 PRIME 渲染卸换（render offload） 这是英伟达为支持可切换显卡提供的官方方法。 详情请参见 PRIME#PRIME render offload。 使用 nouveau 要了解显卡切换相关内容，请参见 PRIME；要了解开源英伟达驱动相关内容，请参见 nouveau。 使用大黄蜂（Bumblebee） 请参见 Bumblebee。 使用 nvidia-xrun 请参见 nvidia-xrun。 使用 optimus-manager 请参见 Optimus-manager 上游文档。其中包含了在 Arch Linux 系统上的安装和配置方法。 我选择用optimus-manager工具（原因还是以前用这个显卡切换没成功，打算继续尝试） ptimus-manager 切换独显 ➜ ~ optimus-manager --switch nvidia ERROR: a GPU setup was initiated but Xorg post-start hook did not run. Log at /var/log/optimus-manager/switch/switch-20220610T152810.log If your login manager is GDM, make sure to follow those instructions: https://github.com/Askannz/optimus-manager#important--gnome-and-gdm-users If your display manager is neither GDM, SDDM nor LightDM, or if you don't use one, read the wiki: https://github.com/Askannz/optimus-manager/wiki/FAQ,-common-issues,-troubleshooting Cannot execute command because of previous errors. 解决方案，根据解决方案的描述，运行prime-offload命令 ➜ ~ prime-offload [8] INFO: # Xorg post-start hook [1946] INFO: Running /etc/optimus-manager/xsetup-integrated.sh [1987] INFO: Writing state {'type': 'done', 'switch_id': '20220610T152810', 'current_mode': 'integrated'} [1988] INFO: Xorg post-start hook completed successfully. ➜ ~ optimus-manager --status Optimus Manager (Client) version 1.4 Current GPU mode : integrated GPU mode requested for next login : no change GPU at startup : integrated Temporary config path: no 再次切换独显 ➜ ~ optimus-manager --switch nvidia WARNING : no power management option is currently enabled (this is the default since v1.2). Switching between GPUs will work but you will likely experience poor battery life. Follow instructions at https://github.com/Askannz/optimus-manager/wiki/A-guide--to-power-management-options to enable power management. You are about to switch GPUs. This will forcibly close all graphical sessions and all your applications WILL CLOSE. (you can pass the --no-confirm option to disable this warning) Continue ? (y/N) \u003e xrandr 设置主屏：xrandr --output eDP-1 --auto --primary 调整副屏在主屏左边：xrandr --output HDMI-1-0 --left-of eDP-1 副屏同步主屏：xrandr --output HDMI-1-0 --same-as eDP-1 自动调整分辨率和位置：xrandr --output HDMI-1-0 --auto 关闭显示器：xrandr --output HDMI-1-0 --off 打开关闭的显示器：xrandr --output HDMI-1-0 --auto 设置分辨率：xrandr --output HDMI-1-0 --mode 1920x1080 配置文件 ➜ optimus-manager cat optimus-manager.conf [amd] DRI=3 driver=modesetting tearfree= [intel] DRI=3 accel= driver=modesetting modeset=yes tearfree= [nvidia] DPI=96 PAT=yes allow_external_gpus=no dynamic_power_management=no ignore_abi=no modeset=yes options=overclocking [optimus] auto_logout=yes pci_power_control=no pci_remove=no pci_reset=no startup_auto_battery_mode=integrated startup_auto_extpower_mode=nvidia startup_mode=nvidia switching=bbswitch 禁用独显 ArchWiki已经说的很清楚了，直接看官方解决方案 根据上面ArchWiki的描述，写了一个简单的脚本 #删除配置文件 sudo rm -rf /etc/X11/xorg.conf.d/20-nvidia.conf #将内核模块添加到模块列表以在引导时加载 echo 'acpi_call' | sudo tee /etc/modules-load.d/acpi_call.conf # 将/etc/tmpfiles.d/acpi_call.conf文件由systemd启动时加载 echo 'w /proc/acpi/call - - - - \\\\_SB.PCI0.PEG0.PEGP._OFF' | sudo tee /etc/tmpfiles.d/acpi_call.conf reboot 仅使用英伟达显卡 根据上面禁用独显的脚本内容知晓，需要删除/etc/modules-load.d/acpi_call.conf和/etc/tmpfiles.d/acpi_call.conf文件， 脚本如下 #!/bin/bash echo '您将切换至独显' echo '输入密码回车将重启，请将工作区文件保存好！！！' # 删除自动加载的acpi_call模块 sudo rm -rf /etc/modules-load.d/acpi_call.conf # 将systemd启动时加载的文件删除(该文件是将独显断电) sudo rm -rf /etc/tmpfiles.d/acpi_call.conf #获取NVIDIA显卡的BusID NVIDIA_BusID=`lspci | egrep 'VGA|3D' | grep 'NVIDIA' | cut -d ' ' -f 1 | sed -r 's/0?(.)/\\1/' | sed -e 's/:0/:/g' -e 's/\\./:/g'` #写入Xorg配置文件 echo 'Section \"Module\" Load \"modesetting\" EndSection Section \"Device\" Identifier \"nvidia\" Driver \"nvidia\" BusID \"PCI:'$NVIDIA_BusID'\" Option \"AllowEmptyInitialConfiguration\" EndSection' | sudo tee /etc/X11/xorg.conf.d/20-nvidia.conf \u003e /dev/null reboot 仅使用Intel显卡 脚本如下 #!/bin/bash echo '您将切换至核显(独显将会断电)' echo '输入密码回车将重启，请将工作区文件保存好！！！' #删除配置文件 sudo rm -rf /etc/X11/xorg.conf.d/20-nvidia.conf #将内核模块添加到模块列表以在引导时加载 echo 'acpi_call' | sudo t","date":"2022-06-10","objectID":"/posts/archlinux%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8/:0:1","tags":null,"title":"ArchLinux外接显示器","uri":"/posts/archlinux%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8/"},{"categories":null,"content":" 安装 安装 samba sudo pacman -S samba 创建配置文件sudo nvim /etc/samba/smb.conf 实例内容 这里 获取 用户配置 ","date":"2022-05-21","objectID":"/posts/smb/:0:0","tags":null,"title":"SMB文件共享","uri":"/posts/smb/"},{"categories":null,"content":"添加用户 Samba 需要 Linux 账户才能使用 - 可以使用已有账户或 创建新用户. 虽然用户名可以和 Linux 系统共享，Samba 使用单独的密码管理，将下面的 samba_user 替换为选择的 Samba 用户 注意：添加的用户必须是系统用户 $ sudo smbpasswd -a minghui New SMB password: Retype new SMB password: Added user minghui. $ sudo pdbedit -L minghui:1000: ","date":"2022-05-21","objectID":"/posts/smb/:0:1","tags":null,"title":"SMB文件共享","uri":"/posts/smb/"},{"categories":null,"content":"创建sambashare用户组 sambashare 名字不要改 $ sudo groupadd sambashare 然后将samba用户添加到sambashare组 $ sudo usermod -aG sambashare minghui ","date":"2022-05-21","objectID":"/posts/smb/:0:2","tags":null,"title":"SMB文件共享","uri":"/posts/smb/"},{"categories":null,"content":"共享文件夹 将要分享的文件夹用户组改为sambashare $ sudo chown root:sambashare /mnt/move_disk/ 以下的操作将会让 sambashare 群组中的用户拥有读取，写入和执行此文件夹中内容的权限： 1770的1是设置粘滞位，创建的文件只有root和文件所属者才可删除 $ sudo chmod 1770 /mnt/move_disk ","date":"2022-05-21","objectID":"/posts/smb/:0:3","tags":null,"title":"SMB文件共享","uri":"/posts/smb/"},{"categories":null,"content":"修改配置文件实现共享 中括号里面的是名称，即共享文件夹的名称 [move_disk] comment = Mary's and Fred's stuff path = /mnt/move_disk valid users = minghui browsable = yes public = yes writable = yes printable = no create mask = 0765 ","date":"2022-05-21","objectID":"/posts/smb/:0:4","tags":null,"title":"SMB文件共享","uri":"/posts/smb/"},{"categories":null,"content":"启动服务 $ systemctl enable smb.service $ systemctl start smb.service ","date":"2022-05-21","objectID":"/posts/smb/:0:5","tags":null,"title":"SMB文件共享","uri":"/posts/smb/"},{"categories":null,"content":"参数说明 path = ：共享目录路径 public = yes/no：设置共享是否允许guest账户访问 browseable = yes/no：设置共享是否可浏览，如果no就表示隐藏，需要通过IP+共享名称进行访问（即其他设备看不到这个共享） read only = yes/no：设置共享是否具有只读权限 writable = yes/no：设置共享是否具有可写权限 printable = yes/no：打印机 write list = username：设置在共享具有写入权限的用户，例如例如write list = user1,user2,@group1,@group2（多用户或组使用逗号隔开，@group表示group用户组） valid users = username：设置允许访问共享的用户，例如valid users = user1,user2,@group1,@group2（多用户或组使用逗号隔开，@group表示group用户组） invalid users = username：设置不允许访问共享的用户 create mask = 0764：创建的文件权限为 764 directory mode = 0755：创建的文件目录为 755 [public] comment = Public Stuff path = /home/minghui/samba public = no browseable = yes read only = yes printable = no valid users = @sambashare write list = @sambashare create mask = 0764 directory mask = 0755 注意：writable与write list有个奇怪的问题，见下 writable = no write list = @sambashare 这样写同样能够写入，说明后者生效了 writable = yes write list = 这样写同样能够写入，说明前者生效了 避免出现这样的情况，统一使用write list来控制读权限 ","date":"2022-05-21","objectID":"/posts/smb/:0:6","tags":null,"title":"SMB文件共享","uri":"/posts/smb/"},{"categories":["教程"],"content":" 基本操作 如果不做任何处理，触摸板是能够用的，但是点击的话需要按触摸板的按键，双指滑动也不行 看到网上一篇文章解决了我的疑惑，现在将他文章连接放在此处：https://twor.me/posts/archlinux_gesture/ 下面就简单记录一下步骤 安装xf86-input-libinput包sudo pacman -S xf86-input-libinput 自定义配置文件放在 /etc/X11/xorg.conf.d/ 中，并且通常选择被广泛使用的命名模式 30-touchpad.conf 作为文件名，sudo vim /etc/X11/xorg.conf.d/30-touchpad.conf，该文件可以更该很多触摸板参数 Section \"InputClass\" Identifier \"touchpad\" Driver \"libinput\" MatchIsTouchpad \"on\" # 当检测到 USB 鼠标时，它将禁用触摸板 #Option \"SendEventsMode\" \"disabled-on-external-mouse\" Option \"TapButton1\" \"1\" #单指敲击产生左键事件 Option \"TapButton2\" \"2\" #双指敲击产生中键事件 Option \"TapButton3\" \"3\" #三指敲击产生右键事件 Option \"EmulateTwoFingerMinZ\" \"40\" #精确度 Option \"EmulateTwoFingerMinW\" \"8\" Option \"CoastingSpeed\" \"20\" #触发快速滚动的滚动速度 Option \"PalmDetect\" \"1\" #避免手掌触发触摸板1表示打开 Option \"PalmMinWidth\" \"0.05\" #认定为手掌的最小宽度 Option \"PalmMinZ\" \"10\" #认定为手掌的最小压力值 Option \"Tapping\" \"on\" Option \"DisableWhileTyping\" \"True\" # 防止打字误触 Option \"NaturalScrolling\" \"True\" # 反方向滚动 Option \"AccelProfile\" \"adaptive\" Option \"AccelSpeed\" \"0.5\" Option \"TappingDrag\" \"on\" Option \"TappingButtonMap\" \"lmr\" EndSection 当我做完上面的步骤之后，重新打开了一个tty并进去了dwm窗口管理器，发现触摸板能够点击以及双指滑动了，但是网页的缩小放大等手势还不行 进阶操作 触摸板手势的进阶操作 需要安装软件包libinput-gestures $ sudo pacman -S libinput-gestures 自动创建了/etc/libinput-gestures.conf文件，但是没有创建$HOME/.config/libinput-gestures.conf，需要手动创建，编写自己的配置文件 需要将当前用户添加到input组才能具有读取触摸板设备的权限 查看/etc/group文件如下 将当前用户添加到input组 $ sudo gpasswd -a minghui input 然后安装需要的包 $ sudo pacman -S xdotool wmctrl 然后编写配置文件vim ~/.config/libinput-gestures.conf，里面内容需要自己修改 $ vim .config/libinput-gestures.conf # 内容如下 gesture swipe left 4 xdotool key super+Ctrl+Left # 4指左划: 切换到左侧工作区 gesture swipe right 4 xdotool key super+Ctrl+Right # 4指右划: 切换到右侧工作区 gesture swipe up 4 xdotool key super+s # 4指上划: 堆叠窗口 gesture swipe down 4 xdotool key super+d # 4指下划: 还原窗口 gesture pinch in 4 xdotool key super+r # 4指捏: 调整窗口大小 gesture swipe left 3 xdotool key super+Shift+Left # 3指左划: 窗口移动到左边 gesture swipe right 3 xdotool key super+Shift+Right # 3指右划: 窗口移动到右边 gesture swipe up 3 xdotool key super+Shift+space # 3指下划: 浮动切换 gesture swipe down 3 xdotool key super+Shift+space # 3指上划: 浮动切换 gesture pinch in 3 xdotool key super+Shift+q # 3指捏: 关闭窗口 gesture pinch in 2 xdotool key ctrl+minus # 2指捏: 缩小 gesture pinch out 2 xdotool key ctrl+plus # 2指张: 放大% ","date":"2022-04-18","objectID":"/posts/archlinux%E8%A7%A6%E6%91%B8%E6%9D%BF/:0:0","tags":["Linux"],"title":"ArchLinux触摸板","uri":"/posts/archlinux%E8%A7%A6%E6%91%B8%E6%9D%BF/"},{"categories":null,"content":" PPPoE拨号 先安装ppp、re-pppoe $ sudo pacman -S ppp re-pppoe 配置pppoe $ pppoe-setup 欢迎使用 RP-PPPoE 客户端设置。首先，我会对您的系统进行一些检查以确保已安装 PPPoE 客户端 适当地… /usr/bin/pppoe-setup: 抱歉，您必须是 root 才能运行此脚本 使用 root 运行 $ sudo pppoe-setup \u003e\u003e\u003e Enter your PPPoE user name (default bxxxnxnx@sympatico.ca): \u003e\u003e\u003e Enter the Ethernet interface connected to the DSL modem For Solaris, this is likely to be something like /dev/hme0. For Linux, it will be ethn, where 'n' is a number. (default eth0): \u003e\u003e\u003e Enter the demand value (default no): \u003e\u003e\u003e Enter the DNS information here: \u003e\u003e\u003e Please enter your PPPoE password: \u003e\u003e\u003e Please re-enter your PPPoE password: \u003e\u003e\u003e Choose a type of firewall (0-2): \u003e\u003e\u003e Accept these settings and adjust configuration files (y/n)? y Adjusting /etc/ppp/pppoe.conf Adjusting /etc/ppp/pap-secrets and /etc/ppp/chap-secrets (But first backing it up to /etc/ppp/pap-secrets-bak) (But first backing it up to /etc/ppp/chap-secrets-bak) Congratulations, it should be all set up! Type 'pppoe-start' to bring up your PPPoE link and 'pppoe-stop' to bring it down. Type 'pppoe-status' to see the link status. \u003e\u003e\u003e Enter your PPPoE user name (default bxxxnxnx@sympatico.ca):宽带帐号 (default eth0):有线网卡名称 \u003e\u003e\u003e Enter the demand value (default no):默认 no 即可 \u003e\u003e\u003e Enter the DNS information here:可以填百度DNS：180.76.76.76 \u003e\u003e\u003e Please enter your PPPoE password:宽带密码 \u003e\u003e\u003e Choose a type of firewall (0-2):填 0 即可 最后输入y 把配置写入了/etc/ppp/pppoe.conf and /etc/ppp/pap-secrets and /etc/ppp/chap-secret 使用命令 pppoe-start：拨号，显示Connected!表示拨号成功 ➜ ppp sudo pppoe-start . Connected! pppoe-stop：停止拨号 pppoe-status：查看状态 ➜ ppp pppoe-status pppoe-status: Link is up and running on interface ppp0 11: ppp0: \u003cPOINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP\u003e mtu 1492 qdisc fq_codel state UNKNOWN mode DEFAULT group default qlen 3 link/ppp 下面测试 先把 wifi 关闭：nmcli radio wifi off 尝试 ping 百度的 DNS，没有问题，说明已经连接到外网了 ➜ ppp ping 180.76.76.76 PING 180.76.76.76 (180.76.76.76) 56(84) 字节的数据。 64 字节，来自 180.76.76.76: icmp_seq=1 ttl=52 时间=24.2 毫秒 64 字节，来自 180.76.76.76: icmp_seq=2 ttl=52 时间=24.1 毫秒 64 字节，来自 180.76.76.76: icmp_seq=3 ttl=52 时间=25.0 毫秒 ^C --- 180.76.76.76 ping 统计 --- 已发送 3 个包， 已接收 3 个包, 0% packet loss, time 2002ms rtt min/avg/max/mdev = 24.135/24.417/24.955/0.380 ms ➜ ppp 然后尝试 ping 百度，半天没接收到响应 ➜ ppp ping www.baidu.com ^C 说明DNS解析没问题，如果DNS有问题则会显示如下，解决方法是编辑sudo vim /etc/ppp/pppoe.conf文件，把DNS替换成可用的 ➜ ppp ping www.baidu.com ping: www.baidu.com: 域名解析暂时失败 根据网上教程链接解决了该问题 ip a(address)查看网卡信息（省略了部分信息） ➜ ppp ip a 12: ppp0: \u003cPOINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP\u003e mtu 1492 qdisc fq_codel state UNKNOWN group default qlen 3 link/ppp inet 223.145.168.154 peer 223.145.168.1/32 scope global ppp0 valid_lft forever preferred_lft forever ip r(route)查看路由信息 ➜ ppp ip r default via 192.168.1.1 dev enp7s0 proto dhcp src 192.168.1.2 metric 20100 192.168.1.0/24 dev enp7s0 proto kernel scope link src 192.168.1.2 metric 100 192.168.140.0/24 dev vmnet1 proto kernel scope link src 192.168.140.1 192.168.164.0/24 dev vmnet8 proto kernel scope link src 192.168.164.1 223.145.168.1 dev ppp0 proto kernel scope link src 223.145.168.154 默认路由没走 pppoe，需要sudo ip r replace default via 223.145.168.154 dev ppp0 然后再次ip r查看 ➜ ppp ip r default via 223.145.168.154 dev ppp0 default via 192.168.1.1 dev enp7s0 proto dhcp src 192.168.1.2 metric 20100 192.168.1.0/24 dev enp7s0 proto kernel scope link src 192.168.1.2 metric 100 192.168.140.0/24 dev vmnet1 proto kernel scope link src 192.168.140.1 192.168.164.0/24 dev vmnet8 proto kernel scope link src 192.168.164.1 223.145.168.1 dev ppp0 proto kernel scope link src 223.145.168.154 ➜ ppp route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 223.145.168.154 0.0.0.0 UG 0 0 0 ppp0 0.0.0.0 192.168.1.1 0.0.0.0 UG 20100 0 0 enp7s0 192.168.1.0 0.0.0.0 255.255.255.0 U 100 0 0 enp7s0 192.168.140.0 0.0.0.0 255.255.255.0 U 0 0 0 vmnet1 192.168.164.0 0.0.0.0 255.255.255.0 U 0 0 0 vmnet8 223.145.168.1 0.0.0.0 255.255.255.255 UH 0 0 0 ppp0 然后就解决了！ 有个疑问 我尝试输入sudo ip r replace default via 223.145.168.1 dev ppp0，然后ip r查看","date":"2022-03-02","objectID":"/posts/archlinux-pppoe%E6%8B%A8%E5%8F%B7/:0:0","tags":null,"title":"ArchLinux PPPoE拨号","uri":"/posts/archlinux-pppoe%E6%8B%A8%E5%8F%B7/"},{"categories":["教程"],"content":" Ranger 安装 $ sudo pacman -S ranger ","date":"2022-03-01","objectID":"/posts/ranger/:0:0","tags":["Tools"],"title":"Ranger","uri":"/posts/ranger/"},{"categories":["教程"],"content":"安装图标 没装之前 下面装图标 $ git clone https://github.com/alexanderjeurissen/ranger_devicons ~/.config/ranger/plugins/ranger_devicons $ echo \"default_linemode devicons\" \u003e\u003e $HOME/.config/ranger/rc.conf 效果如下 ","date":"2022-03-01","objectID":"/posts/ranger/:1:0","tags":["Tools"],"title":"Ranger","uri":"/posts/ranger/"},{"categories":["教程"],"content":"插件安装 安装完成之后用ranger打开 但是预览文件没有高亮显示，以及图片没有预览 下面进行插件安装 $ sudo pacman -S libcaca highlight lynx w3m elinks mediainfo ","date":"2022-03-01","objectID":"/posts/ranger/:2:0","tags":["Tools"],"title":"Ranger","uri":"/posts/ranger/"},{"categories":["教程"],"content":"图片预览 安装ueberzug yay -S ueberzug 编辑文件vim ~/.config/ranger/rc.conf 修改为set preview_images true ","date":"2022-03-01","objectID":"/posts/ranger/:3:0","tags":["Tools"],"title":"Ranger","uri":"/posts/ranger/"},{"categories":["教程"],"content":"边框 编辑文件vim ~/.config/ranger/rc.conf 设置如下： set draw_borders true set preview_images_method ueberzug ","date":"2022-03-01","objectID":"/posts/ranger/:4:0","tags":["Tools"],"title":"Ranger","uri":"/posts/ranger/"},{"categories":["教程"],"content":"压缩包预览 安装插件即可，不用修改配置文件，默认设置好了 $ yay -S atool ","date":"2022-03-01","objectID":"/posts/ranger/:5:0","tags":["Tools"],"title":"Ranger","uri":"/posts/ranger/"},{"categories":["教程"],"content":" Typora 安装 使用 cur 安装 1.0 版本以下的 Typora（pacman 只搜索到了 1.0 版本以上的） $ yay typora 但是我此时是下载失败的，所以采用了下面的方法安装 下载 tar 包，蓝奏云下载链接，密码9999 下载好后，我是复制到/opt目录下解压 $ cd /opt $ sudo tar -zxvf typora-0-11-18.tar.gz 然后进入目录并且编辑typora.desktop文件 $ cd typora $ sudo vim typora.desktop # 我的编辑内容如下，如果路径不同则替换即可 [Desktop Entry] Name=Typora Exec=/opt/typora/Typora Type=Application Icon=/opt/typora/resources/assets/icon/icon_512x512.png 说明：/opt/typora/Typora这个文件是启动文件 然后把这个启动快捷方式复制到/usr/share/applications $ sudo cp typora.desktop /usr/share/applications 安装完成 然后就可以在菜单中搜索到，但是没有图标还不知道怎么回事（图标路径没有错误） 我的安装过程没有遇到什么错误，如果有错误网上查找即可 Picgo(core) 安装 在下载picgo之前，确保本机已经安装了nodejs和npm $ sudo pacman -S nodejs npm 满足1条件后，接下来用npm安装picgo（全局安装） $ sudo npm install picgo -g picgo安装的位置是/usr/lib/node_modules/（即 npm 模块的保存位置，我没有修改 npm 下载模块的保存位置） Picgo 配置 先提前说明一下，上面安装好picgo之后，它还有一些文件是在~/.picgo/目录下，之后下载的插件以及配置文件都在这里！ 大致流程很简单：先下载两个插件，然后编辑配置文件指定上传到哪里 注意：下面的安装命令前面不要带sudo 由于我是使用gitee作为图床，所以还要安装picgo插件 gitee-uploader：用于使用 gitee 作为图床 super-prefix：上传图片时能在文件后缀加上时间戳 $ picgo install gitee-uploader super-prefix 启用插件，空格键确定，上下键移动 $ picgo use plugins 接下来编辑上传的图床参数 $ picgo set uploader 用键盘上下键选择gitee按回车 repo：填写 gitee 仓库名称（用户名/仓库名） branch：上传分支，默认是 master token：gitee 生成的私人令牌 path：上传到仓库的什么位置，默认是仓库根目录 customPath：默认即可 customUrl：默认即可 当然也可以直接编辑配置文件，路径~/.picgo/config.json 可以看到上面配置已经写入了文件 编辑好图床参数后，选择使用gitee图床 上下键选择gitee并回车即可 $ picgo use uploader 终于要打开Typora了，按图编辑 这里为什么是填写picgo upload 我们之前通过 npm 全局安装了 picgo，这里就是调用了这个上传命令（而上传到图床的参数我们又设置好了） Typora 需要上传图片的时候，就会自动将图片的绝对路径拼接载在该命令的后面，然后调用该命令上传图片到图床，当看到步骤 5 的测试就会明白 最后测试是否可以上传成功 两种方式 命令 $ picgo upload \"图片路径\" Typora 软件内有测试按钮 如果上传失败的话，注意看报错 最后献上 配置阿里OSS 下面简单配置aliyun图床 命令，选择aliyun $ picgo set uploader 设置参数 参数 备注 accessKeyId 需要从阿里云控制台查看 accessKeySecret 需要从阿里云控制台查看 bucket OSS Bucket 名称，到控制台查看 area 这是路径，有个小坑，下面说明 path 上传到的路径 customUrl 自定义域名，暂时没配 options area 查看，红框的地方，不需要全部填写，填写前面oss-cn-shenzhen path 有个坑的地方 比如你查看 Bucket 的文件管理是下面这样的 我想把图片上传到image/blog_img/下，那么path参数就要写成image/blog_img/而不是/image/blog_img或者image/blog_img 比如把参数写成这样image/blog_img：前面不加/是阿里云默认会给它前面加上/，后面不加/就不会自动加，比如下面这个图片链接，image前面自动加了/，而后面的blog_img确与图片的名称拼接成了一个整体，当作图片的新名称，所以它并没有上传到blog_img目录下，所以要写成image/blog_img/才正确 https://ming-blog.oss-cn-shenzhen.aliyuncs.com/image/blog_img2022-05-07_23-32.png ","date":"2022-01-15","objectID":"/posts/archlinux-typora-picgo/:0:0","tags":["Linux"],"title":"ArchLinux-Typora-Picgo","uri":"/posts/archlinux-typora-picgo/"},{"categories":null,"content":" ArchLinux安装步骤 ","date":"2022-01-08","objectID":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/:0:0","tags":null,"title":"ArchLinux系统安装","uri":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"连接网络 由于我使用的是WIFI，所以需要手动连接，如果你连接的是路由器LAN口的网线，那么插上就行了！ 输入iwctl，会进入这个工具的使用模式 输入device list查看网卡设备，我是有一个 wlan0 的网卡设备 输入station wlan0 scan，扫描 WIFI 输入station wlan0 get-networks，查看可用 WIFI 列表 下面连接WIFI，输入station wlan0 connect 要连接的WIFI名称，回车后输入密码 然后更新一下系统时间 $ timedatectl set-ntp true 注意看我下面WIFI名称显示方块， 其实就是中文字符显示不出来，建议将WIFI名称改为非中文！ ","date":"2022-01-08","objectID":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/:1:0","tags":null,"title":"ArchLinux系统安装","uri":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"分区并挂载 查看当前磁盘分区fdisk -l详情 分区可以使用两个工具，cfdisk和gdisk，前者是有DOS界面的，后者命令行，下面我用的是 gdisk 然后就是分区了，最少建立两个分区（有boot分区的情况下），即根分区和swap分区 swap分区大小可以分内存一半，或者与内存等大 根分区为其他未分配空间 如果是硬盘里面只装这一个系统就还需要建立boot分区，用来引导系统。因为我原本是还有一个Windows系统，Windows已经创建了boot分区，我就可以不用创建了。 这里分区分好之后，假设分区情况如下 boot分区：/dev/nvme0n1p1 根分区：/dev/nvme0n1p5 swap分区：/dev/nvme0n1p6 下面将分区格式化，执行如下命令 $ mkfs.ext4 -L ArchFSBoot /dev/nvme0n1p5 # -L 指定卷标名 $ mkswap /dev/nvme0n1p6 $ swapon /dev/nvme0n1p6 # 打开交换分区 分区完成后，进行挂载 挂载的目的就是写文件到刚刚所建分区上（刚刚已经格式化了，什么东西都没有），因为我们现在所处的是光盘镜像（可以看到是红色的root），还未安装系统到新建分区上，因此需要通过挂载刚刚新建分区到光盘镜像的某个目录下，与此同时，Linux挂载目录通常是/mnt下 下面把根分区（/dev/nvme0n1p5）挂载到/nmt下 swap分区（/dev/nvme0n1p6）挂载到/mnt/boot下，在挂载前，需要创建/mnt/boot目录 下面开始挂载，注意挂载顺序，先挂载外面的/mnt，然后挂载/mnt下的boot，当然，挂载前需要创建该/mnt/boot目录 下面假设先创建/mnt/boot目录并将此目录作为硬盘/dev/nvme0n1p6的挂载点，直到这里没有任何问题，然后挂载硬盘/dev/nvme0n1p5到/mnt，然后你查看/mnt下的文件ls /mnt，会发现刚刚挂载的/mnt/boot没有了。这里我是认为是先挂载的/mnt/boot这个目录被后面挂载的/mnt所掩盖了，即挂载一个目录后，该目录原始的文件会看不到了，具体原因还未知！类比刚刚，先挂载的/mnt/boot被后面挂载的/mnt掩盖掉了。 $ mount /dev/nvme0n1p5 /mnt $ mkdir /mnt/boot $ mount /dev/nvme0n1p1 /mnt/boot ","date":"2022-01-08","objectID":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/:2:0","tags":null,"title":"ArchLinux系统安装","uri":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"设置镜像源 编辑/etc/pacman.d/mirrorlist文件，查找 China ，把国内源复制到最前面，最上面的源优先级最高 补充一个生成镜像源的网站：https://archlinux.org/mirrorlist/ ","date":"2022-01-08","objectID":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/:3:0","tags":null,"title":"ArchLinux系统安装","uri":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"开始装系统 书接上文，我们把上面的所做的工作用一个图表示 这里很好理解，/mnt等价于需装系统(ArchLinux)的/ 而/mnt/boot等价于/boot 知道了/mnt就是待装系统的/那么现在在/mnt下装系统，官方提供了一条命令pacstrap，下面是我安装的一些东西，按个人需求安装 $ pacstrap /mnt base base-devel linux linux-firmware networkmanager vim intel-ucode git 等待即可！！！ 安装好了之后生成文件表 $ genfstab -U /mnt \u003e\u003e /mnt/etc/fstab /etc/fstab是Linux系统下的n硬盘挂载点文件 ","date":"2022-01-08","objectID":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/:4:0","tags":null,"title":"ArchLinux系统安装","uri":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"新系统配置 刚刚已经将系统安装好了，并且生成了文件表，下面切换到新安装的ArchLinux系统 $ arch-chroot /mnt 语言 $ vim /ect/local.gen 找到zh_CN.UTF-8 UTF-8和en_US.UTF-8 UTF-8前面#删除 生成语言文件 $ locale-gen 设置系统缺省语言文件 $ echo LANG=en_US.UTF-8 \u003e /etc/locale.conf 设置时区 $ ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime $ timedatectl set-ntp true 硬件时钟 $ hwclock --systohc 主机名，我这里设置为 Mingarch $ echo Mingarch \u003e /etc/hostname 域名解析文件（hosts） $ vim /etc/hosts 我的内容如下 # Static table lookup for hostnames. # See hosts(5) for details. 127.0.0.1 localhost ::1 localhost 127.0.1.1 Mingarch.localdomain Mingarch 这里面的 Mingarch 是主机名，不要搞错了 给普通用户执行sudo命令权限 $ visudo 找到%wheel ALL=(ALL) ALL，前面#删除 给 root 用户重新设密码 $ passwd 新建用户并加入组 $ useradd -m minghui $ usermod -aG wheel,audio,video,optical,storage minghui $ passwd minghui 重要一部，安装引导，使用 systemd-boot 安装 systemd-boot系统自带：这是一个教程 $ bootctl install 安装好了之后，进行简单配置 需要配置/boot/loader/loader.conf和/boot/loader/entries/ 首先到/boot/loader/entries/新建一个.conf文件，我这里建为Arch.conf，然后编辑它，我的内容如下 title Arch Linux linux /vmlinuz-linux initrd /intel-ucode.img initrd /initramfs-linux.img options root=\"PARTUUID=87898fba-ac8a-4703-b317-a858ca9a7ffd\" rw vmlinuz-linux：内核文件 上面的options root=指点根文件系统在哪里，我这里使用了PARTUUID，具体查看方法，如果是在 vim 编辑器下，直接输入:r!blkid会写在当前打开文件，然后找到根分区的PARTUUID复制过去，最后别忘记删除无关内容 编辑/boot/loader/loader.conf文件 我的内容如下 default Arch timeout 5 default Arch：表示的是默认读取名为Arch的配置文件，该文件即为刚刚创建的，/boot/loader/entries/Arch.conf ","date":"2022-01-08","objectID":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/:5:0","tags":null,"title":"ArchLinux系统安装","uri":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"新系统重启 先回到光盘镜像文件exit或者Ctrl+D 卸载开始挂载的分区 $ umount -R /mntr 终于可以reboot了，完成 ","date":"2022-01-08","objectID":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/:6:0","tags":null,"title":"ArchLinux系统安装","uri":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"categories":["教程"],"content":" 安装下载 查看是否安装 安装 主配置文件/etc/vsftpd/vsftpd.conf 查看配置，并去掉注释 $ cat vsftpd.conf | grep -v \"#\" 为了更好的配置，做一下处理 本地登录 本地用户模式是通过 Linux 系统本地的账户密码信息进行认证的模式，相较于匿名开放模式更安全，而且配置起来相对简单。但是如果被黑客破解了账户的信息，就可以畅通无阻地登录FTP服务器，从而完全控制整台服务器。 先关闭匿名登录，开启本地登录（默认是开启的） 下面用ftp用户登录 先修改ftp用户的密码 $ passwd ftp /var/ftp/默认是登录后可以看到的文件夹 创建文件发现被拒绝了 给权限 下面就可以创建并修改了 如果无法登录 无法登录考虑到防火墙 查看是否打开 核实防火墙是否加载了FTP 模块，发现结果为空 开放和关闭 FTP 端口 暂时开放 FTP 服务 $ firewall-cmd --add-service=ftp 永久开放 FTP 服务 $ firewall-cmd --add-service=ftp --permanent 永久关闭 FTP 服务 $ firewall-cmd --remove-service=ftp --permanent 开发和检查是否生效 参考： https://www.modb.pro/db/111811 https://zhuanlan.zhihu.com/p/354583347 ","date":"2021-12-15","objectID":"/posts/centos7%E6%90%AD%E5%BB%BAftp%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:0","tags":["Linux"],"title":"CentOS7搭建FTP服务器","uri":"/posts/centos7%E6%90%AD%E5%BB%BAftp%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["学习"],"content":" 如果文中有什么纰漏或错误的话，请留言指正！！！ 建库建表 仅仅为了做测试，可以不做这一步 DBMS用的是 MySQL 新建一个数据库sql_twenty，然后建表以及添加数据做测试（检验所写 SQL 语句是否正确） 下面SQL语句包括了建库、建表和数据添加，只需要手动复制并执行即可 DROP DATABASE IF EXISTS `sql_twenty`; CREATE DATABASE sql_twenty DEFAULT CHARACTER SET = 'utf8mb4'; USE sql_twenty; DROP TABLE IF EXISTS `SC`; DROP TABLE IF EXISTS `Course`; DROP TABLE IF EXISTS `Student`; DROP TABLE IF EXISTS `Teacher`; CREATE TABLE Student( `S#` CHAR(2) PRIMARY KEY COMMENT '学生编号', `Sname` VARCHAR(20) COMMENT '学生姓名', `Sage` DATE COMMENT '出生年月', `Ssex` CHAR(1) COMMENT '学生性别' ) DEFAULT CHARACTER SET UTF8 COMMENT '学生表'; CREATE TABLE Teacher( `T#` CHAR(4) PRIMARY KEY COMMENT '教师编号', `Tname` VARCHAR(20) COMMENT '教师姓名' ) DEFAULT CHARACTER SET UTF8 COMMENT '教师表'; CREATE TABLE Course( `C#` CHAR(2) NOT NULL PRIMARY KEY COMMENT '课程编号', `Cname` VARCHAR(255) NOT NULL COMMENT '课程名称', `T#` CHAR(4) COMMENT '教师编号', FOREIGN KEY(`T#`) REFERENCES Teacher(`T#`) ) DEFAULT CHARACTER SET UTF8 COMMENT '课程表'; CREATE TABLE SC( `S#` CHAR(2) NOT NULL COMMENT '学生编号', `C#` CHAR(2) NOT NULL COMMENT '课程编号', `score` TINYINT COMMENT '分数', PRIMARY KEY(`S#`,`C#`), FOREIGN KEY(`S#`) REFERENCES Student(`S#`), FOREIGN KEY(`C#`) REFERENCES Course(`C#`) ) DEFAULT CHARACTER SET UTF8 COMMENT '成绩表'; INSERT INTO Student(`S#`,`Sname`,`Sage`,`Ssex`) VALUES('01','赵同学','2000-1-1','男'); INSERT INTO Student(`S#`,`Sname`,`Sage`,`Ssex`) VALUES('02','钱同学','2001-2-1','女'); INSERT INTO Student(`S#`,`Sname`,`Sage`,`Ssex`) VALUES('03','孙同学','2002-3-1','男'); INSERT INTO Student(`S#`,`Sname`,`Sage`,`Ssex`) VALUES('04','李同学','2003-4-1','女'); INSERT INTO Student(`S#`,`Sname`,`Sage`,`Ssex`) VALUES('05','周同学','2004-5-1','女'); INSERT INTO Student(`S#`,`Sname`,`Sage`,`Ssex`) VALUES('06','李同学','2004-5-1','女'); INSERT INTO Student(`S#`,`Sname`,`Sage`,`Ssex`) VALUES('07','周同学','2000-5-1','男'); INSERT INTO Student(`S#`,`Sname`,`Sage`,`Ssex`) VALUES('08','李同学','2002-9-1','男'); INSERT INTO Teacher(`T#`,Tname) VALUES('1001','张三'); INSERT INTO Teacher(`T#`,Tname) VALUES('1002','李四'); INSERT INTO Teacher(`T#`,Tname) VALUES('1003','王五'); INSERT INTO Teacher(`T#`,Tname) VALUES('1004','JACK'); INSERT INTO Course(`C#`,`Cname`,`T#`) VALUES('01','数学','1001'); INSERT INTO Course(`C#`,`Cname`,`T#`) VALUES('02','数据库','1002'); INSERT INTO Course(`C#`,`Cname`,`T#`) VALUES('03','计算机网络','1003'); INSERT INTO Course(`C#`,`Cname`,`T#`) VALUES('04','外语','1004'); INSERT INTO SC(`S#`,`C#`,`score`) VALUES('01','01',80); INSERT INTO SC(`S#`,`C#`,`score`) VALUES('01','02',75); INSERT INTO SC(`S#`,`C#`,`score`) VALUES('02','02',85); INSERT INTO SC(`S#`,`C#`,`score`) VALUES('02','03',65); INSERT INTO SC(`S#`,`C#`,`score`) VALUES('03','01',50); INSERT INTO SC(`S#`,`C#`,`score`) VALUES('03','03',62); INSERT INTO SC(`S#`,`C#`,`score`) VALUES('04','01',65); INSERT INTO SC(`S#`,`C#`,`score`) VALUES('04','02',70); INSERT INTO SC(`S#`,`C#`,`score`) VALUES('04','03',30); INSERT INTO SC(`S#`,`C#`,`score`) VALUES('05','01',59); INSERT INTO SC(`S#`,`C#`,`score`) VALUES('05','02',90); INSERT INTO SC(`S#`,`C#`,`score`) VALUES('05','03',75); T20 下面所写的20个题的 SQL 语句不一定完全正确，但是测试都是正确的，也有可能有些特殊情况没有考虑到！！！ ==前提知识（做题需掌握的知识）== WHERE子句用法、IN运算符用法 自然连接写法：表一名称 NATURAL JOIN 表二名称，这应当写在 FROM 语句中 左外连接写法：表一名称 LEFT JOIN 表二名称 ON(连接条件) EXISTS谓词的使用：它执行流程详细看书上P109 GROUP BY子句、HAVING短语的用法 下面每道题后面都有一个SQL语句的结果图 测试的数据在数据库sql_twenty中，DBMS用的是 MySQL 下图是sql_twenty数据库里四个表的数据 根据热心网友的宝贵发现对以下题做了修改（有错误） 2021/12/07更新了下面几个地方 T19：是输出学生编号，原来写的输出分数、已修改 SQL 语句 T16：SELECT 后面漏写了 Sname，不及格学生应该要有学号和姓名（因为有重名的，两个属性一起才是主码） 查询”01”课程比”02”课程成绩高的学生编号及课程分数 只涉及SC(成绩)表 使用EXISTS谓词，外层循环先筛选出是“01”课程的元组（即满足C# = '01'这个条件），然后执行EXISTS括号的 SQL 语句，EXISTS括号是内层循环，内层循环从SC表第一条元组开始遍历判断，只有当外层循环元组的学生编号等于内层循环当前元组的学生编号且内层循环元组的课程编号为“02”且外层循环元组的成绩高于内层循环当前元组的成绩，EXISTS 才返回真，反之为假。所以当外层循环的两个条件满足时，即为所求元组，最后投影到学生编号和课程分数。 SELECT `S#`, score FROM SC AS A WHERE `C#` = '01' AND EXISTS( SELECT * FROM SC WHERE A.`S#` = `S#` AND `C#` = '02' AND A.score \u003e score ); 查询平均成绩大于等于60分的同学的学生编号和平均成绩 涉及Student(学生)表和SC(成绩)表 Student 表和 SC 表自然连接，每个学生可能有多个选课成绩，所以用 GROUP BY 子句按S#(学生学号)进","date":"2021-12-01","objectID":"/posts/sql20%E9%A2%98/:0:0","tags":["MySQL"],"title":"SQL20题","uri":"/posts/sql20%E9%A2%98/"},{"categories":["教程"],"content":" 如何把 Wallpaper Engine 壁纸提出出来？ 看到一个博客说是找到 GitHub 上一个开源项目，然后本地编译，利用编译好的程序代码，然后写好脚本 具体教程 https://www.zhihu.com/question/277034435 下面记录一下操作过程，使用更加简单 将开源项目：https://github.com/notscuffed/repkg 拉取到本地 然后用 Visual Studio 打开这个箭头文件 执行不调试 这个目录就是一些编译后的文件，我们可以把这些文件复制到一个容易找到的地方（就放这里也可以，强迫症想换一个位置） 我是放到了 E:\\Tools\\pkgToPng 写一个脚本文件（.bat 文件）和编译后的文件放在一起：名称任取 如 pkg.bat 内容如下 两个 move 用来移动提取的壁纸到指定位置，比如我这里把壁纸就是移动到 E:\\Tools\\pkgToPng\\photo 下 rd 是删除提取文件（因为提取文件不仅仅是一张壁纸，还有很多个文件），这里不删除也行，但是还是删除一下，占空间 然后 explorer 后面带的是需要打开的文件目录 exit 退出终端 \"RePKG.exe\" extract ./scene.pkg move output\\materials\\*.jpg E:\\Tools\\pkgToPng\\photo move output\\materials\\*.png E:\\Tools\\pkgToPng\\photo rd output /s /q explorer E:\\Tools\\pkgToPng\\photo exit 然后我们把这个路径添加环境变量，便于后面用 CMD 使用该脚本 使用方法 先在 Wallpaper Engine 找到壁纸在文件管理器打开 然后在此路径下打开 CMD 之后输入上面脚本的名称，我这里是 pkg.bat success ","date":"2021-10-10","objectID":"/posts/wallpaper-engine-%E5%A3%81%E7%BA%B8%E6%8F%90%E5%8F%96/:0:0","tags":["Windows"],"title":"Wallpaper Engine 壁纸提取","uri":"/posts/wallpaper-engine-%E5%A3%81%E7%BA%B8%E6%8F%90%E5%8F%96/"},{"categories":["教程"],"content":" Windows Terminal 连接服务器 小知识：本地 Windows 上传文件到 服务器上 Windows系统 连接服务器的软件有很多，比如 CMD、Powershell、git-bash、xshell 等等工具都可以通过 ssh 连接到服务器主机 下面我通过 Windows Terminal 连接服务器并添加一个启动项 直接在打开终端 ssh 连接，直接终端输连接命令即可 添加一个启动项（好处就是不用每次都输入 ssh 的连接命令） 打开 Windows Terminal 的 json 文件进行编辑 找到 list这个地方（方括号是一个是数组） 我们添加一个数组元素，即一个终端，内容如下 { \"commandline\": \"ssh root@121.4.26.166\", \"guid\": \"{4f338cc5-b9f0-4707-96de-16c856dbfd87}\", \"hidden\": false, \"name\": \"CentOs7\" } guid 获取方式，在终端（在使用 ssh 连接的终端比如 cmd、wt）输入New-Guid 远程连接 Windows 打开设置（应用版块）安装 OpenSSH 服务器 打开 Openssh 服务 查看 22 端口是否开启 未开启 已开启 最后通过局域网的设备 ssh 登录到 Windows 但是我登录了很多次都不知道账户和密码 ","date":"2021-08-23","objectID":"/posts/wt-ssh%E5%92%8C%E9%80%9A%E8%BF%87ssh%E8%BF%9E%E6%8E%A5windows/:0:0","tags":["SSH","Windows"],"title":"wt ssh和通过 SSH 连接 Windows","uri":"/posts/wt-ssh%E5%92%8C%E9%80%9A%E8%BF%87ssh%E8%BF%9E%E6%8E%A5windows/"},{"categories":["教程"],"content":" Windows Terminal ","date":"2021-08-19","objectID":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/:0:0","tags":["Windows"],"title":"Windows Terminal + Git-Bash","uri":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/"},{"categories":["教程"],"content":"先安装PowerShell https://github.com/PowerShell/PowerShell/releases 64位 Windows 可下载 msi 文件 ","date":"2021-08-19","objectID":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/:1:0","tags":["Windows"],"title":"Windows Terminal + Git-Bash","uri":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/"},{"categories":["教程"],"content":"安装Windows Terminal 打开微软商店，直接搜索 Windows Terminal 即可下载安装 ","date":"2021-08-19","objectID":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/:2:0","tags":["Windows"],"title":"Windows Terminal + Git-Bash","uri":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/"},{"categories":["教程"],"content":"安装 posh-git、oh-my-posh https://github.com/JanDeDobbeleer/oh-my-posh2 打开 WindowsTerminal的 Powershell窗口 post-git加入的 -Verbose显示详情 $ Install-Module posh-git -Scope CurrentUser $ Install-Module posh-git -Verbose -Scope CurrentUser 成功安装在 E:\\Multimedia Data\\文档\\PowerShell\\Modules\\ 这个目录下 oh-my-posh $ Install-Module oh-my-posh -Scope CurrentUser $ Install-Module oh-my-posh -Verbose -Scope CurrentUser ","date":"2021-08-19","objectID":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/:3:0","tags":["Windows"],"title":"Windows Terminal + Git-Bash","uri":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/"},{"categories":["教程"],"content":"开启插件 打开配置文件 $ notepad $PROFILE 编辑引入模块 # 引入 posh-git Import-Module posh-git # 引入 oh-my-posh Import-Module oh-my-posh # 设置 PowerShell 主题 Set-PoshPrompt -Theme agnoster 这里我使用的是一个博主提供的内容：https://gist.github.com/LittleNewton/04132945d9b9743ba7cab780fc44a67b \u003c# * FileName: Microsoft.PowerShell_profile.ps1 * Author: 刘 鹏 * Email: littleNewton6@outlook.com * Date: 2020, May. 1 * Update: 2021, Mar. 14 * Copyright: No copyright. You can use this code for anything with no warranty. #\u003e #------------------------------- Import Modules BEGIN ------------------------------- # 引入 posh-git Import-Module posh-git # 引入 oh-my-posh Import-Module oh-my-posh # 设置 PowerShell 主题 # Set-PoshPrompt -Theme ys Set-PoshPrompt -Theme nu4a #------------------------------- Import Modules END ------------------------------- #------------------------------- Set Hot-keys BEGIN ------------------------------- # 设置预测文本来源为历史记录 Set-PSReadLineOption -PredictionSource History # 设置 Tab 为菜单补全和 Intellisense Set-PSReadLineKeyHandler -Key \"Tab\" -Function MenuComplete # 设置 Ctrl+d 为退出 PowerShell Set-PSReadlineKeyHandler -Key \"Ctrl+d\" -Function ViExit # 设置 Ctrl+z 为撤销 Set-PSReadLineKeyHandler -Key \"Ctrl+z\" -Function Undo # 设置向上键为后向搜索历史记录 Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward # 设置向下键为前向搜索历史纪录 Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward #------------------------------- Set Hot-keys END ------------------------------- #------------------------------- Functions BEGIN ------------------------------- # Python 直接执行 $env:PATHEXT += \";.py\" # 更新 pip 的方法 function Update-Packages { # update pip Write-Host \"Step 1: 更新 pip\" -ForegroundColor Magenta -BackgroundColor Cyan $a = pip list --outdated $num_package = $a.Length - 2 for ($i = 0; $i -lt $num_package; $i++) { $tmp = ($a[2 + $i].Split(\" \"))[0] pip install -U $tmp } # update TeX Live $CurrentYear = Get-Date -Format yyyy Write-Host \"Step 2: 更新 TeX Live\" $CurrentYear -ForegroundColor Magenta -BackgroundColor Cyan tlmgr update --self tlmgr update --all # update Chocolotey choco outdated } #------------------------------- Functions END ------------------------------- #------------------------------- Set Alias BEGIN ------------------------------- # 1. 编译函数 make function MakeThings { nmake.exe $args -nologo } Set-Alias -Name make -Value MakeThings # 2. 更新系统 os-update Set-Alias -Name os-update -Value Update-Packages # 3. 查看目录 ls \u0026 ll function ListDirectory { (Get-ChildItem).Name Write-Host(\"\") } Set-Alias -Name ls -Value ListDirectory Set-Alias -Name ll -Value Get-ChildItem #------------------------------- Set Alias END ------------------------------- 重新打开 Windows Terminal ：paradox 主题如下 尝试查看配置颜色，给了一个网址，打开之后告诉我们怎么更新到 V3 更新命令，同样我们加入 Verbose 查看信息 $ Update-Module -Name oh-my-posh -Verbose -Scope CurrentUser ","date":"2021-08-19","objectID":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/:4:0","tags":["Windows"],"title":"Windows Terminal + Git-Bash","uri":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/"},{"categories":["教程"],"content":"主题更改 查看主题 查看主题样式、列举所有主题命令 $ Get-PoshThemes 更改主题 $ Set-PoshPrompt -Theme theme_name ","date":"2021-08-19","objectID":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/:5:0","tags":["Windows"],"title":"Windows Terminal + Git-Bash","uri":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/"},{"categories":["教程"],"content":"VsCode终端 经过上面的美化之后，Vscode 的终端也会得以改变，但是由于 Vscode 设置的字体可能会导致乱码 我们按住 Ctrl+Shift+P 输入 settings.json 然后编辑字体样式即可，我这里用到的是一个FiraCode NF 字体（这个好像是系统内部的，下载链接） 提供一个我的字体设置 \"editor.fontFamily\": \"Fira Code Medium, FiraCode NF, Consolas, 'Courier New', monospace\", 当然还有很多字体都可以，比如 Hack 字体（下载链接），但是我安装之后在 Vscode里面没有用，在 Windows Terminal 的配置文件里面就可以用，具体什么原因不清楚 下面是 Windows Terminal 的配置文件 红色框表示设置终端字体类型，Hack NF、FiraCode NF 都可以达到特殊字符的显示 Git bash 美化 ","date":"2021-08-19","objectID":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/:6:0","tags":["Windows"],"title":"Windows Terminal + Git-Bash","uri":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/"},{"categories":["教程"],"content":"前言 经过上面 Vscode 的启发，能否在 IDEA 上面把终端也改成 Windows Terminal 的样式 但是通过查看 Windows Terminal 的安装路径寻找它的可执行文件，然后在 IDEA 里面设置终端的启动文件 我通过 Everything 找到了 Windows Terminal 的文件路径，把 IDEA 的终端启动文件设置为 wt.exe 启动 但是它打开终端是独立打开的，不在 IDEA 窗口里面打开，于是想到能不能设置为 Git Bash启动，然后把 Git Bash 美化一下 下面 IDEA 设置为了 Git Bash 启动了，只需要把 Git Bash 美化即可 ","date":"2021-08-19","objectID":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/:7:0","tags":["Windows"],"title":"Windows Terminal + Git-Bash","uri":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/"},{"categories":["教程"],"content":"安装 zsh https://packages.msys2.org/package/zsh?repo=msys\u0026variant=x86_64 解压，这个 .zst文件可能解压不了，需要安装一个软件peaziphttps://peazip.github.io/ 然后找到第一步下载的，选择解压即可 解压之后会有一个去掉了 .zst后缀的文件，此时我们在次解压即可 我们把上面解压好的文件全部移动到 git的安装目录下，相当于对git bash做一个补充包，比如我这里 打开 Git Bash，输入 zsh然后你会发现进入了 zsh 终端 提示我们没有配置文件，输入 0 创建一个就行了 ","date":"2021-08-19","objectID":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/:8:0","tags":["Windows"],"title":"Windows Terminal + Git-Bash","uri":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/"},{"categories":["教程"],"content":"安装 oh my zsh 上面已经从进入了 zsh 终端了，执行下面命令安装 oh-my-zsh （给出官网） # 下面两个任选其一 $ sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" $ sh -c \"$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)\" 这里我两个链接都没用 用另外方法安装，其实就是人工手动实现上面两种安装代码方式 首先随便在哪个地方新建文件 install.sh 然后打开网址 https://github.com/ohmyzsh/ohmyzsh/blob/master/tools/install.sh 复制里面的内容 写入install.sh文件中 $ vim install.sh 赋予执行权限 $ chmod +x install.sh 执行脚本 $ ./install.sh 报错了，解决方法先还未知 提示：下面不用看了，因为写到一半发现错了 报错分析 根据上面的报错大概是说克隆仓库到本地出错，那我们查看它仓库里面的 install.sh 文件里面的内容 这是 ohmyzsh仓库 install.sh 的一部分代码，我想大概意思就是拉取仓库到本地，并且保存到 ~/.oh-my-zsh下（~/这个目录在Windows下是用户目录，Linux 是 root） 然后我验证了的确是这样的，我查看云服务器（安装了ohmyzsh）下 /root/目录下是否有个 .oh-my-zsh文件夹以及里面文件是否和仓库一致 lib 提供了核心功能的脚本库 tools 提供安装、升级等功能的快捷工具 plugins 自带插件的存放位置 templates 自带模板的存放位置 themes 自带主题文件的存放位置 custom 个性化配置目录，自安装的插件和主题可放这里 知道了 执行install.sh文件的目的是先拉取仓库到本地，我们干脆手动拉取到指定目录下 发现它那里写的是要拉取到.oh-my-zsh目录，我们只需将其改名即可 随后在 install.sh目录下执行该脚本看看 $ ./install.sh 很明显，即使执行了 install.sh 也没有初始化一些文件，即配置文件 .zshrc 配置文件里面有一些东西，但是我们查看之后并没有 手动添加试试，我添加成功了，也同样开启了 zsh ，但是后面下载插件的时候会有路径上的错误，不知道怎么回事，所以这个方法不可行 ","date":"2021-08-19","objectID":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/:9:0","tags":["Windows"],"title":"Windows Terminal + Git-Bash","uri":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/"},{"categories":["教程"],"content":"插件安装 待续 ","date":"2021-08-19","objectID":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/:10:0","tags":["Windows"],"title":"Windows Terminal + Git-Bash","uri":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/"},{"categories":["教程"],"content":"配置 待续 Git SDK Git SDK 全称 Git for Windows SDK，基于 MSYS2（MinGW64 + Cygwin 合体增强）的仿 Linux 环境； 安装后大约会占用 4~5 GB 的磁盘空间，但是包含了完整的仿 Linux 环境：包括常用工具，完整的 GNU Complier 链以及包管理器 pacman Windows 里面 Powershell 有工具 oh-my-posh Linux 里面 有 oh-my-zsh 接下来在 Windows 下安装 Git SDK 模拟一个 Linux环境 ","date":"2021-08-19","objectID":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/:11:0","tags":["Windows"],"title":"Windows Terminal + Git-Bash","uri":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/"},{"categories":["教程"],"content":"下载安装 方式一：直接从官网下载一个安装包，就是一个下载器，会自动从仓库克隆这个程序所需要的全部文件，但是由于下载速度很慢，不太可行 https://gitforwindows.org/ 方式二：直接拉取仓库上的文件到本地（其实就是方式一中需要下载的文件），但是里面文件很大，大概有 5/6 GB 此时到你想保存的路径克隆下来就行 https://github.com/git-for-windows/git-sdk-64 由于我这里每次都拉取失败，这个就先到这里，具体之后需要安装的 zsh 和 oh-my-zsh 还要参考网上的教程 待续 ","date":"2021-08-19","objectID":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/:12:0","tags":["Windows"],"title":"Windows Terminal + Git-Bash","uri":"/posts/windows-terminal-%E7%BE%8E%E5%8C%96/"},{"categories":["教程"],"content":" 尝试用云服务器搭建一个Nginx+rtmp服务器来做推流服务器 下载 我这里下载的文件全部保存在/opt/source下 nginx-rtmp-module 下载源文件 $ git clone https://github.com/arut/nginx-rtmp-module.git nginx：由于我原本有 nginx 原来有，查看nginx版本rpm -qa nginx，然后下载相同版本的源码 比如我这里查看之后是nginx-1.16.1-3.el7.x86_64 那么我下载1.16.1版本的nginx源码，然后解压，如下 $ wget http://nginx.org/download/nginx-1.16.1.tar.gz $ tar -zxvf nginx-1.16.1.tar.gz nginx添加模块 我下载了 nginx-rtmp-module 模块，就要把它添加到 nginx 服务器里面 进入到cd nginx-1.16.1/目录（也就是刚刚解压的 Nginx 目录） 查看原来 Nginx 的配置信息 $ nginx -V 比如我这里的配置参数如下 复制红色框中的内容 红色框的配置是我们原来的，这个时候只需要在后面追加上需要添加的模块 注意更该自己存放模块的路径 # 需要在后面添加的内容 $ --add-module=/opt/source/nginx-rtmp-module 然后配置参数 $ ./configure --prefix=/usr/share/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --http-client-body-temp-path=/var/lib/nginx/tmp/client_body --http-proxy-temp-path=/var/lib/nginx/tmp/proxy --http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi --http-uwsgi-temp-path=/var/lib/nginx/tmp/uwsgi --http-scgi-temp-path=/var/lib/nginx/tmp/scgi --pid-path=/run/nginx.pid --lock-path=/run/lock/subsys/nginx --user=nginx --group=nginx --with-file-aio --with-ipv6 --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-stream_ssl_preread_module --with-http_addition_module --with-http_xslt_module=dynamic --with-http_image_filter_module=dynamic --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_degradation_module --with-http_slice_module --with-http_stub_status_module --with-http_perl_module=dynamic --with-http_auth_request_module --with-mail=dynamic --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream=dynamic --with-stream_ssl_module --with-google_perftools_module --with-debug --with-cc-opt='-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic' --with-ld-opt='-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E' --add-module=/opt/source/nginx-rtmp-module 执行编译命令 $ make 遇到了问题这一步 查看网上说没有安装其它依赖环境 pcre、zlib、openssl， 这些是解压包、ssl相关的依赖 但是我查看了下面 3 个显示有安装 $ yum -y install pcre pcre-devel $ yum -y install zlib zlib-devel $ yum -y install openssl openssl-devel 先不管有没有安装，尝试安装上述 3 个，安装完后在查看，好吧其实上面 3 个和我原来的不同 在尝试make，结果还是一样的报错 然后我尝试把划线部分删除 执行完之后如下报错 上网查找方法安装如下 $ yum -y install libxslt-devel 然后重新./configure又有新报错，如下 查到解决方案，安装如下 $ yum -y install perl-ExtUtils-Embed 然后重新./configure又有新报错，如下 查到解决方案，安装如下 $ yum -y install gperftools 然后重新./configure，终于没有报错了 编译完成后，会生成一个objs的目录 objs目录文件如下 需要把箭头文件替换成原来的，使用which nginx查看原来的路径 把这个东西替换掉/usr/sbin/nginx 如果替换不了就先关闭 Nginx 服务 $ systemctl stop nginx.service 替换好了之后打开 Nginx 服务 $ systemctl start nginx.service 发现报错，启动不了服务 用 systemctl status nginx.service查看信息 这里说ngx_mail_module.so这个模块有问题，谷歌一波（手动滑稽） 最后实在找不到解决方案了，干脆重装 Nginx，先备份好配置文件 不对，想到一个方法，我们查找出错的这个模块，可以发现编译了一个新的，尝试替换原来的，看是否能解决 最后打开 Nginx 服务看是否成功 发现没有任何提示，终于解决了 添加配置 etc/nginx/nginx.conf下面这个添加在 https{ } 只外 rtmp{ server{ listen 1935; # 监听的端口 chunk_size 4000; # 数据传输块的大小 application minghui { # rtmp 推流请求路径 live on; hls on; hls_path /myweb/rtmp/live; hls_fragment 5s; } } } 添加配置之后来到 OBS 推流，服务器对应配置文件应该如下 # 服务器 rtmp://IP:PORT/推流请求路径 # 串流秘钥：自己随便设置 开始推流之后别人想观看就通过下面这个链接，Potplay、VLC都可以观看 rtmp://IP:PORT/推流请求路径/串流秘钥 ","date":"2021-08-18","objectID":"/posts/centos+nginx-rtmp-module/:0:0","tags":["Linux"],"title":"CentOs+Nginx-rtmp-module","uri":"/posts/centos+nginx-rtmp-module/"},{"categories":["教程"],"content":" Linux 安装 SQl-server CentOs安装SQL-server # 下载存储库配置文件 sudo curl -o /etc/yum.repos.d/mssql-server.repo https://packages.microsoft.com/config/rhel/7/mssql-server-2019.repo # 安装 SQL-server sudo yum install -y mssql-server # 设置 SA 密码并选择版本 sudo /opt/mssql/bin/mssql-conf setup # 验证服务是否正在运行 systemctl status mssql-server # 打开 SQL-server 端口 sudo firewall-cmd --zone=public --add-port=1433/tcp --permanent sudo firewall-cmd --reload ———————————————————————————————————————————————————————————————— # 安装 SQL-server 命令行工具 sudo curl -o /etc/yum.repos.d/msprod.repo https://packages.microsoft.com/config/rhel/7/prod.repo # 删除所有 unixODBC 包 sudo yum remove unixODBC-utf16 unixODBC-utf16-devel # 安装 mssql-tools sudo yum install -y mssql-tools unixODBC-devel # 添加环境变量 echo export PATH=$PATH:/opt/mssql-tools/bin ~/.bash_profile echo export PATH=$PATH:/opt/mssql-tools/bin ~/.bashrc source ~/.bashrc ———————————————————————————————————————————————————————————————— # 连接数据库 sqlcmd -S localhost -U SA -P YourPassword ———————————————————————————————————————————————————————————————— # 新建数据库并查询 CREATE DATABASE TestDB SELECT Name from sys.Databases GO ","date":"2021-07-20","objectID":"/posts/centos%E5%AE%89%E8%A3%85sql-server/:0:0","tags":["Linux"],"title":"CentOs安装SQL-server","uri":"/posts/centos%E5%AE%89%E8%A3%85sql-server/"},{"categories":["教程"],"content":" 安装 zsh $ yum install -y zsh zsh 的基础上安装 oh my zsh $ sh -c \"$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)\" $ sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" 上面那个安装不了打开下面网址复制里面内容 $ https://github.com/ohmyzsh/ohmyzsh/blob/master/tools/install.sh 随便在哪个文件夹新建 install.sh，然后把脚本内容粘贴上去 $ vim install.sh 赋予执行权限 $ chmod -x install.sh 执行脚本 $ ./install.sh 如图安装成功 常用插件 git 插件 当有修改并未提交文件会出现一个小 × 符号 sudo 插件 wd 插件（相当于快捷方式，起名之后直接用 【wd + 名字】 跳转） 能够在常用文件夹之中快速切换访问 $ wd add name # 给当前文件夹起名 $ wd name # 切换到name映射的路径下 $ wd rm name # 删除name的映射快捷方式 $ wd list # 查看现有映射 $ wd show # 查看当前文件夹映射名称 zsh-syntax-highlighting 插件（命令高亮） 先在配置文件（.zshrc）添加插件名称，然后安装依赖 先克隆会失败，要先把插件名称加到配置文件去，具体原因未知 $ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting zsh-autosuggestions 插件（命令提示补全，按右键补全） 先添加到配置，在安装依赖 $ git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions 主题 agnoster amuse bira ys jonathan xiong-chiamiov-plus re5et # ZSH_THEME=\"robbyrussell\" # ZSH_THEME=\"agnoster\" # ZSH_THEME=\"amuse\" # ZSH_THEME=\"random\" # ZSH_THEME=\"bira\" # ZSH_THEME=\"jonathan\" # ZSH_THEME=\"ys\" # ZSH_THEME=\"xiong-chiamiov-plus\" ZSH_THEME=\"re5et\" plugins=( git sudo wd zsh-syntax-highlighting zsh-autosuggestions ) ","date":"2021-07-20","objectID":"/posts/oh-my-zsh/:0:0","tags":["Linux"],"title":"oh my zsh","uri":"/posts/oh-my-zsh/"},{"categories":["博客"],"content":" 服务器购买 购买，这里以腾讯云服务器为例子 登录 不记得密码重置密码 重置密码之后用终端登录，用 xshell 为例 git及创建仓库 ","date":"2021-05-09","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:0","tags":["Hexo","Linux","服务器"],"title":"部署博客到服务器","uri":"/posts/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["博客"],"content":"git及用户 安装 yum install git 查看 git 版本 git version 创建一个 git 账户用来管理以后的博客 # 创建 git 账户 adduser git # 为 git 账户设置密码 passwd git 为 git 用户 添加权限 vim /etc/sudoers git ALL=(ALL) ALL 最后你为 git用户 添加秘钥（我理解为和本地进行身份校准，秘钥不一致就表示不匹配，就无法上传） mkdir -p /home/git/.ssh vim /home/git/.ssh/authorized_keys 然后把本地的公钥粘贴进去：在本地的 *C:\\Users\\用户名\\ .ssh* 下，如图 如果没有的话就创建秘钥，方法如下 ssh-keygen -t rsa 上面对 git 用户操作就结束了，下面是创建一个 git仓库（存放博客） ","date":"2021-05-09","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:0","tags":["Hexo","Linux","服务器"],"title":"部署博客到服务器","uri":"/posts/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["博客"],"content":"仓库创建 切换到 git用户（重要） su git 这里忘记切换的话，后面从本地部署到服务器的时候会报 “权限不够” 错误 而且后面更改很麻烦，要更好很多，一定要先切换到 git用户 再创建仓库 创建仓库 选择一个路径存放：我这里选的是 /home/git/repo mkdir /home/git/repo git init --bare name.git # 这里我的是仓库名是 huiHuiLovesToEatLittleClouds.git # git init --bare huiHuiLovesToEatLittleClouds.git 创建博客存放目录 上面创建了一个仓库用来存放博客，其实并不是真正存放了博客的渲染文件，故我们还需在创建一个文件夹保存真正的博客渲染文件 选择一个路径存放真正能渲染的博客文件：我这里是 /www/wwwroot/Blog_hexo mkdir -p /www/wwwroot/Blog_hexo 权限修改（可能不用修改） 现在看下我刚刚创建的 Blog_hexo 这个目录的 所有者和用户组 是 root ，这样的情况就要修改，如果是 git 则不修改，直接跳到 5 然后看下我另外一个博客目录 （hexo）的 所有者和用户组 是 git 这里我们要将 Blog_hexo 的 所有者和用户组 修改为 git 原因：因为我们到时候在本地部署然后上传到服务器的时候是使用 git用户 上传的，不修改的话权限不够，如果想够权限的话直接用 root用户 上传也可以 然后我们修改权限 chown git:git -R /www/wwwroot/Blog_hexo 仓库和博客目录联系 这里我不太理解其中的逻辑 先梳理一下 仓库是：/home/git/repo/huiHuiLovesToEatLittleClouds.git 博客目录是：/www/wwwroot/Blog_hexo 然后我们使两者关联起来：先来到仓库，里面有一个 hooks 文件夹，进去创建一个名为 post-receive 文件 cd /home/git/repo/huiHuiLovesToEatLittleClouds.git/hooks/ vim post-receive # 把下面这个话填进去保存退出 # git --work-tree=你的博客目录 --git-dir=你的仓库目录 checkout -f git --work-tree=/www/wwwroot/Blog_hexo --git-dir=/home/git/repo/huiHuiLovesToEatLittleClouds.git checkout -f 来到这里的话 git 已经配置好了，接下来是 Nginx 的配置 Nginx 安装 yum install nginx 查看版本 nginx -v 找到 nginx 的安装路径 这样是在：/etc/nginx/ 目录下，找到 nginx.conf 配置文件并修改 server_name：你的域名或服务器IP root：博客的目录 vim /etc/nginx/nginx.conf 这里 Nginx 的配置也完成了，下面修改本地的配置文件即可 端口设置 当我们访问一个域名的时候默认是访问它指向的服务器的 80 端口，可以用一个域名对应多个端口 如果需要访问 81 端口：huige.link:81 当然也可以对应2个以上端口 本地 修改配置文件 本地的配置文件（博客的站点配置文件）修改上传仓库为刚刚配置的仓库，具体如图举例 git 表示使用 git 用户上传 本地部署上传到服务器 —— 成功状态 遇到的问题 当我要上传到服务器的时候报错如下 原因及解决如下 原因：由于我当时创建仓库的时候忘记切换到 git用户 创建了所以所有者是 root ，推送的时候没有权限 解决 法一：在创建仓库的时候就使用 git用户 法二：将这个仓库的所有者改为 git，并且仓库里面的子文件夹的所有者也是 git，一直到没有子文件夹为止 如下图这种还是会报错，必须仓库里面的每个文件夹及其子文件夹及其子子文件夹……的所有者均为 git 即可，然后在修改他们的读写执行的权限，看下面（RWX 权限设置） RWX 权限设置 如果部署过程中遇到了 有关权限 的报错，看下仓库和博客目录是不是 root用户， 因为我们本地使用的是 git用户 进行部署，所以会不够权限。再不行查看文件夹以及文件的 RWX 权限 ","date":"2021-05-09","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:0","tags":["Hexo","Linux","服务器"],"title":"部署博客到服务器","uri":"/posts/%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["博客"],"content":" 个人博客搭建 Hexo ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:0:0","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"一、创建博客 先安装 git 和 node.js 然后在你要保持博客的路径下执行下面命令 $ npm install -g hexo-cli # 安装hexo $ hexo init \u003cfolder\u003e # 安装博客 $ cd \u003cfolder\u003e # 进入到安装博客的路径 $ npm install # 安装npm 然后进入到 xiaofanBlog/ 修改文件 然后执行命令 $ npm install hexo-deployer-git --save $ hexo d 如果不行重新输入 hexo d 上面就已经上传到了github仓库了 下面就是怎么修改主题 如果你没有设置 git 的邮箱和用户名则在 hexo d 时会出现下面提示 只需要设置邮箱和用户名即可 ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:0","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"二、修改主题 从 hexo主题 官网下载主题，直接 git clone 即可 然后就是把主题放到博客文件夹 themes里面，重命名 然后在 _config.yml 中修改主题（注意名称要和 themes 里面的主题文件夹一致） 保存之后用重新部署一下如图 如果出现了下面这个问题 解决方案输入下面命令 $ npm install hexo-renderer-pug hexo-renderer-stylus --save 清理缓存代码 $ hexo clean ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:2:0","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"三、主题美化 ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:0","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"标签页 $ hexo n page tags 然后找到 source/tags/index.md文件 修改为 --- title: 標籤 date: 2018-01-05 00:00:00 # 不动 type: \"tags\" top_img: # 图片 --- ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:1","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"分类页 $ hexo n page categories 同样找到 source/categories/index.md文件 修改为 --- title: 分類 date: 2018-01-05 00:00:00 type: \"categories\" --- ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:2","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"代码主题和能否Copy # 主题配置文件 highlight_theme: pale night # darker / pale night / light / ocean / mac / mac light / false highlight_copy: true # 能否复制 highlight_lang: true # show the code language highlight_shrink: false # true 全部代碼框不展開，需点击\u003e打開false 代碼狂展開，有\u003e點擊按鈕 none 不顯示\u003e按鈕 code_word_wrap: false # 代码换行 ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:3","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"主页标签页等图片设置 // 主题配置文件 # Disable all banner image disable_top_img: false # 显示顶部图为 false # 顶部图 index_img: /img/背景.jpg # 默认的top_img，当页面的top_img 没有配置时，会显示default_top_img default_top_img: # 归档页面的top_img archive_img: # tag 子页面的默认top_img tag_img: # tag 子页面的top_img，可配置每个 tag 的 top_img # - tag name: xxxxx tag_per_img: # category 子页面的默认top_img category_img: # category 子页面的top_img，可配置每个category 的top_img # - category name: xxxxx category_per_img: ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:4","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"文章图片设置 # 主题配置文件 cover: # display the cover or not (是否顯示文章封面) index_enable: true # 在主页 aside_enable: true # 在文章页 archives_enable: true # the position of cover in home page (封面顯示的位置) # left/right/both position: left # 图片在左边 # When cover is not set, the default cover is displayed (當沒有設置cover時，默認的封面顯示) default_cover: #- https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:5","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"文章在主页展示的字数 # 主题配置文件 index_post_content: method: 3 length: 200 # 预览多少。0 就没有了 如200 ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:6","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"文章置顶 直接在文章的front-matter区域里添加sticky: 1属性来把这篇文章置顶。数值越大，置顶的优先级越大。 ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:7","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"文章主页和阅读页显示 // 主题配置 post_meta: page: # Home Page date_type: both # created or updated or both 主頁文章日期是創建日或者更新日或都顯示 date_format: date # date/relative 顯示日期還是相對日期 categories: true # true or false 主頁是否顯示分類 tags: true # true or false 主頁是否顯示標籤 label: true # true or false 顯示描述性文字 post: date_type: both # created or updated or both 文章頁日期是創建日或者更新日或都顯示 date_format: date # date/relative 顯示日期還是相對日期 categories: true # true or false 文章頁是否顯示分類 tags: true # true or false 文章頁是否顯示標籤 label: true # true or false 顯示描述性文字 ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:8","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"文章阅读页显示目录 # 主题配置文件 # toc (目錄) toc: enable: true number: true style_simple: false 特定文章也可以设定是否显示目录 在文章头部添加 toc_number和toc，配置为 true 和 false ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:9","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"相关文章 相关文章推荐的原理是根据文章tags的比重来推荐 # 主题配置文件 # Related Articles related_post: enable: true limit: 5 # 篇数 date_type: created # or created or updated 文章日期顯示創建日或者更新日 ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:10","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"文章描点 开启文章锚点后，当你在文章页进行滚动时，文章链接会根据标题ID进行替换 (注意:每替换一次，会留下一个历史记录。所以如果一篇文章有很多锚点的话，网页的历史记录会很多。) # 主题配置文件 # anchor # when you scroll in post, the URL will update according to header id. anchor: true ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:11","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"文章编辑按钮 在文章标题旁边显示一个编辑按钮，点击会跳转到对应的链接去。 # 主题配置文件 # Post edit # Easily browse and edit blog source code online. post_edit: enable: true # url: https://github.com/755400668/755400668.github/edit/main/source/ # For example: https://github.com/jerryc127/butterfly.js.org/edit/main/source/ url: https://github.com/755400668/755400668.github/edit/main/source/ ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:12","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"文章版权 # post_copyright: enable: true decode: true # 显示中文网址 license: CC BY-NC-SA 4.0 license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/ 如果想要某偏文章不显示版权，在文章标题添加copyright: false 即可 ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:13","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"文章打赏 # 主题配置文件 # Sponsor/reward reward: enable: true QR_code: - img: /img/wechat.jpg link: text: wechat - img: /img/alipay.jpg link: text: alipay ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:14","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"头像 # 主题配置文件 # Avatar (頭像) avatar: img: /img/wechat.gif effect: false # 转圈 ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:15","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"网站内容是否可以复制 # 主题配置文件 # copy settings # copyright: Add the copyright information after copied content (複製的內容後面加上版權信息) copy: enable: true copyright: enable: true limit_count: 500 ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:16","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"页脚设置 # 主题配置文件 # Footer Settings # -------------------------------------- footer: owner: enable: true since: 2021 custom_text: 愿世间美好与你环环相扣 copyright: true # Copyright of theme and framework ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:17","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"夜间模式 # 主题配置文件 # dark mode darkmode: enable: true # Toggle Button to switch dark/light mode button: true # Switch dark/light mode automatically (自動切換 dark mode和 light mode) # autoChangeMode: 1 Following System Settings, if the system doesn't support dark mode, it will switch dark mode between 6 pm to 6 am # autoChangeMode: 2 Switch dark mode between 6 pm to 6 am # autoChangeMode: false autoChangeMode: 1 ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:18","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"阅读模式 # 主题配置文件 # Read Mode (閲讀模式) readmode: true ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:19","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"字体大小 # 主题配置文件 # Bottom right button (右下角按鈕) # Change font size change_font_size: true ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:20","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"访问人数 # 主题配置文件 # busuanzi count for PV / UV in site # 訪問人數 busuanzi: site_uv: true site_pv: true page_pv: true ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:21","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"侧边栏 # 主题配置文件 # aside (側邊欄) # -------------------------------------- aside: enable: true hide: false button: true mobile: true # display on mobile position: right # 右边显示 # 头像卡片 card_author: enable: true description: button: enable: true icon: fab fa-github text: Github link: https://github.com/755400668 # 公告卡片 card_announcement: enable: true content: 欢迎来到灰灰爱吃小云朵的博客 card_recent_post: enable: true limit: 5 # if set 0 will show all sort: date # date or updated sort_order: # Don't modify the setting unless you know how it works # 分类卡片 card_categories: enable: true limit: 8 # if set 0 will show all expand: none # none/true/false sort_order: # Don't modify the setting unless you know how it works # 标签卡片 card_tags: enable: true limit: 40 # if set 0 will show all color: true sort_order: # Don't modify the setting unless you know how it works card_archives: enable: true type: monthly # yearly or monthly format: MMMM YYYY # eg: YYYY年MM月 order: -1 # Sort of order. 1, asc for ascending; -1, desc for descending limit: 8 # if set 0 will show all sort_order: # Don't modify the setting unless you know how it works card_webinfo: enable: false post_count: true last_push_date: true sort_order: # Don't modify the setting unless you know how it works ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:22","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"访问人数 # 主题配置文件 # busuanzi count for PV / UV in site # 訪問人數 busuanzi: site_uv: true site_pv: true page_pv: true ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:23","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"网站运行时间 # 主题配置文件 # Time difference between publish date and now (網頁運行時間) # Formal: Month/Day/Year Time or Year/Month/Day Time runtimeshow: enable: true publish_date: 02/18/2021 ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:24","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"Tag-hide ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:25","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"评论 # 主题配置文件 # gitalk # https://github.com/gitalk/gitalk gitalk: client_id: aa776ef94071498f6753 client_secret: 1cbad93b480c8980863bbfcf1fd8926c2fdd9863 repo: 755400668.github.io owner: 755400668 admin: 755400668 language: zh-CN # en, zh-CN, zh-TW, es-ES, fr, ru perPage: 10 # Pagination size, with maximum 100. distractionFreeMode: false # Facebook-like distraction free mode. pagerDirection: last # Comment sorting direction, available values are last and first. createIssueManually: false # Gitalk will create a corresponding github issue for your every single page automatically ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:26","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"搜索 先安装 npm install hexo-generator-search --save 然后主题配置文件 # Local search local_search: enable: true ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:27","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"UI颜色 # 主题配置文件 # theme_color: enable: true main: \"#49B1F5\" paginator: \"#00c4b6\" button_hover: \"#FF7242\" text_selection: \"#00c4b6\" link_color: \"#99a9bf\" meta_color: \"#858585\" hr_color: \"#A4D8FA\" code_foreground: \"#F47466\" code_background: \"rgba(27, 31, 35, .05)\" toc_color: \"#00c4b6\" blockquote_padding_color: \"#49b1f5\" blockquote_background_color: \"#49b1f5\" ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:28","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"图片加载动画 # 主题配置文件 # Lazyload (圖片懶加載) # https://github.com/verlok/lazyload lazyload: enable: true post: /img/loading1.gif ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:29","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"网站背景 # 主题配置文件 # Website Background (設置網站背景) # can set it to color or image (可設置圖片 或者 顔色) # The formal of image: url(http://xxxxxx.com/xxx.jpg) background: # 页脚显示和首页一样 footer_bg: true ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:30","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"鼠标聚集几何图形 # 主题配置文件 # canvas_nest # https://github.com/hustcc/canvas-nest.js canvas_nest: enable: true color: '0,0,255' #color of lines, default: '0,0,0'; RGB values: (R,G,B).(note: use ',' to separate.) opacity: 0.7 # the opacity of line (0~1), default: 0.5. zIndex: -1 # z-index property of the background, default: -1. count: 199 # the number of lines, default: 99. mobile: true ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:31","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"鼠标点击效果 # 主题配置 # Mouse click effects: Heart symbol (鼠標點擊效果: 愛心) click_heart: enable: true mobile: true ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:32","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"页面美化 # 主题配置 # Default display mode (網站默認的顯示模式) # light (default) / dark display_mode: light # Beautify (美化頁面顯示) beautify: enable: true # post 只在文章頁生效 # site 在全站生效 field: sist # site/post title-prefix-icon: '\\f0c1' title-prefix-icon-color: '#F47466' ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:33","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"主页打字 # 主题配置 # the subtitle on homepage (主頁subtitle) subtitle: enable: true # Typewriter Effect (打字效果) effect: true # loop (循環打字) loop: true # source調用第三方服務 #source: true # 關閉調用 source: 1 # 調用搏天api的隨機語錄（簡體） # source: 2 調用一言網的一句話（簡體） # source: 3 調用一句網（簡體） # source: 4 調用今日詩詞（簡體） # subtitle 會先顯示 source , 再顯示 sub 的內容 #source: false # 如果有英文逗號' , ',請使用轉義字元 \u0026#44; # 如果有英文雙引號' \" ',請使用轉義字元 \u0026quot; # 開頭不允許轉義字元，如需要，請把整個句子用雙引號包住 # 如果關閉打字效果，subtitle只會顯示sub的第一行文字 sub: ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:34","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"PWA npm install hexo-offline --save ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:35","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"字数统计 npm install hexo-wordcount --save # 主题配置 # wordcount (字數統計) wordcount: enable: true post_wordcount: true min2read: true total_wordcount: true ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:36","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"图片放大模式 # 主题配置 # Lightbox (圖片大圖查看模式) # -------------------------------------- # You can only choose one, or neither (只能選擇一個 或者 兩個都不選) # medium-zoom # https://github.com/francoischalifour/medium-zoom medium_zoom: false # fancybox # http://fancyapps.com/fancybox/3/ fancybox: true ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:37","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"弹窗 # 主题配置 # Snackbar (Toast Notification 彈窗) # https://github.com/polonel/SnackBar # position 彈窗位置 # 可選 top-left / top-center / top-right / bottom-left / bottom-center / bottom-right snackbar: enable: true position: bottom-left bg_light: '#ffc0cb' # The background color of Toast Notification in light mode bg_dark: '#121212' # The background color of Toast Notification in dark mode ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:38","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"修改背景 引入一个新的 CSS 文件 使用 js 文件 但是会在一定程度上延缓网页的加载时间，且修改复杂 下面使用第一种方案 \\themes\\hexo-theme-butterfly\\source\\css 目录下新建 background.css 或者你可以在 css 目录下创建一个自己写的新文件夹如（mycss），然后在该目录下创建background.css 编辑 butterfly 主题的背景 div 的 id 是 web_bg 修改为图片 #web_bg { /* 背景图像的地址（url括号里） */ background: url(); /* 背景图像不重复 */ background-repeat: no-repeat; /* 背景图像大小 */ background-size: cover; } # 关于 background 更多用法：https://developer.mozilla.org/zh-CN/docs/Web/CSS/background # 关于 background-repeat 更多用法：https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-repeat # 关于 background-size 更多用法：https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size 修改为渐变背景（如下几种） # 蓝红色渐变 #web_bg { /* webkit内核 5.1 - 6.0 */ background: -webkit-linear-gradient(left, red, blue); /* Opera 11.1 - 12.0 */ background: -o-linear-gradient(right, red, blue); /* Firefox 3.6 - 15 */ background: -moz-linear-gradient(right, red, blue); /* 标准的语法 */ background: linear-gradient(to right, red, blue); } #web_bg { background: linear-gradient(102.7deg,#fddaff 8.2%,#dfadfc 19.6%,#adcdfc 36.8%,#adfcf4 73.2%,#caf8d0 90.9%); } # 紫蓝色渐变 #web_bg { background: linear-gradient(to right bottom, rgb(0, 255, 240), rgb(92, 159, 247) 40%, rgb(211, 34, 255) 80%); } # 图片滤镜渐变 #web_bg{ background-image: url(\"https://ae01.alicdn.com/kf/H18a4b998752a4ae68b8e85d432a5aef0l.png\"), linear-gradient(60deg, rgba(255, 165, 150, 0.5) 5%, rgba(0, 228, 255, 0.35)), url(\"https://ae01.alicdn.com/kf/H21b5f6b8496141a1979a33666e1074d9x.jpg\"); } 更多的渐变网址 https://webgradients.com/ https://www.grabient.com/ 最后将文件引入 # 主题配置文件 # Inject # Insert the code to head (before '\u003c/head\u003e' tag) and the bottom (before '\u003c/body\u003e' tag) # 插入代码到头部 \u003c/head\u003e 之前 和 底部 \u003c/body\u003e 之前 inject: head: - \u003clink rel=\"stylesheet\" href=\"/css/mycss/background.css\"\u003e bottom: # - \u003cscript src=\"xxxx\"\u003e\u003c/script\u003e 如果没有生效的话修改如下 # 主题配置文件 # Website Background (設置網站背景) # can set it to color or image (可設置圖片 或者 顔色) # The formal of image: url(http://xxxxxx.com/xxx.jpg) background: \"#efefef\" ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:39","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"修改页脚 同样的和上面修改背景一样，新建一个css文件如我的 下面在某博主上面看到两种样式 渐变 /* 页脚footer */ /* 渐变色滚动动画 */ @-webkit-keyframes Gradient { 0% { background-position: 0 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0 50%; } } @-moz-keyframes Gradient { 0% { background-position: 0 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0 50%; } } @keyframes Gradient { 0% { background-position: 0 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0 50%; } } #footer { background: linear-gradient(-45deg, #ee7752, #ce3e75, #23a6d5, #23d5ab); background-size: 400% 400%; -webkit-animation: Gradient 10s ease infinite; -moz-animation: Gradient 10s ease infinite; animation: Gradient 10s ease infinite; -o-user-select: none; -ms-user-select: none; -webkit-user-select: none; -moz-user-select: none; user-select: none; border-top-left-radius: 10px; border-top-right-radius: 10px; } #footer:before { background-color: rgba(0, 0, 0, 0); } 半透明 #footer { background: rgba(255,255,255,.15); color: #000; border-top-right-radius: 20px; border-top-left-radius: 20px; backdrop-filter: saturate(100%) blur(5px) } #footer::before { background: rgba(255,255,255,.15) } #footer #footer-wrap { color: var(--font-color); } #footer #footer-wrap a { color: var(--font-color); } 然后引入即可 ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:40","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"手机侧边栏默认不展开 新建 js 文件即可，然后引入 var mobile_sidebar_menus = document.getElementById(\"mobile-sidebar-menus\"); var menus_item_child = mobile_sidebar_menus.getElementsByClassName( \"menus_item_child\" ); var menus_expand = mobile_sidebar_menus.getElementsByClassName(\"menus-expand\"); for (var i = 0; i \u003c menus_item_child.length; i++) { menus_item_child[i].style.display = \"none\"; menus_expand[i].className += \" menus-closed\"; } ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:41","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"加入clustrmaps访问者地图 clustrmaps.com 注册账号或直接登录 填写你的网址然后会看到代码，一种是JS一种是HTML的，这里我选用HTML的 先在主题配置文件加入 card_maps: true 然后在 themes\\hexo-theme-butterfly\\layout\\includes\\widget 路径下创建一个文件 如 card_maps.pug .card-widget.card-map .card-content .item-headline i.fa.fa-map-marker(aria-hidden=\"true\") span= _p('足迹') # 这里是你复制过来的代码 \u003ca href='https://clustrmaps.com/site/1bgca' title='Visit tracker'\u003e\u003cimg src='//clustrmaps.com/map_v2.png?cl=ffffff\u0026w=300\u0026t=tt\u0026d=Ti7plTQaKk8zjpyoUXfK29uCDrIzNldAuvoLvSLy1bU\u0026ct=ffffff\u0026co=2d78ad'/\u003e\u003c/a\u003e 如图 然后在 widget/ 目录下找得到 index.png 加上下面代码 if theme.aside.card_maps !=partial('includes/widget/card_maps', {}, {cache:theme.fragment_cache}) 如图 ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:42","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"添加评论 首先去 leadcloud 国际版注册一个账号Leadcloud国际版 。 然后创建应用 创建class 找到用户栏添加用户 然后修改访问权限 把 _User 的权限全部设置为指定用户但不添加，就是为了没有用户可以修改，防止别人通过 id 和 key 篡改我们用户数据 即上一步添加用户就是这么个作用 Leancloud的配置就告一段落了 然后在主题配置文件中填写 Leancloud 信息 # valine # https://valine.js.org valine: appId: # leancloud application app id appKey: # leancloud application app key pageSize: 10 # comment list page size avatar: monsterid # gravatar style https://valine.js.org/#/avatar lang: zh-CN # i18n: zh-CN/zh-TW/en/ja placeholder: Please leave your footprints # valine comment input placeholder (like: Please leave your footprints) guest_info: nick,mail # valine comment header info (nick/mail/link) recordIP: false # Record reviewer IP serverURLs: # This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in) bg: # valine background emojiCDN: # emoji CDN enableQQ: true # enable the Nickname box to automatically get QQ Nickname and QQ Avatar requiredFields: nick,mail # required fields (nick/mail) visitor: false option: 最后不要忘记打开这个 ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:43","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"文章加密 npm install --save hexo-blog-encrypt 然后在文章的头部写上，如下例子 ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:44","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"顶部标签页顶部图片 ","date":"2021-02-18","objectID":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:45","tags":["Hexo"],"title":"Hexo \u0026 butterfly","uri":"/posts/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"这是一个关于我的页面 ","date":"2018-04-24","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"游戏规则 点击小圆点，围住小猫。 你点击一次，小猫走一次。 直到你把小猫围住（赢），或者小猫走到边界并逃跑（输）。 ","date":"0001-01-01","objectID":"/catch-the-cat/:1:0","tags":null,"title":"逮住那只猫!","uri":"/catch-the-cat/"}]