[{"categories":null,"content":"参考大佬主题： https://idoubi.cc/works/ https://liyangzone.com/（挺简约的） https://blog.gimo.me/posts/creating-a-hugo-theme-2/ 主题：https://github.com/masakichi/futu https://prologue.dev/（秒开，基本不用网络加载） https://rene.wang/（很有特色的博客） https://hicole.top/（很简约） https://powerfulyang.com/post（二次元） https://blog.tanglu.me/ https://www.hsuyeung.com/ https://github.com/hsuyeung/simple-blog 我使用 hugo + 自己写的 notion-site 工具 效果： 博客站： https://blog.env.wtf/ 文档站： https://ns-doc.env.wtf/ 1: 先去 hugo 找一款喜欢的主题:https://themes.gohugo.io/ 2：使用 notion-site 工具同步 notion 文章到 vercel ，自动、免费、随处编辑 https://github.com/pkwenda/notion-site notion 原文： https://zhuangwenda.notion.site/2bd00e5dfff3449ba81e0142f8af9bbb https://zhuangwenda.notion.site/zhuangwenda/df7fb0e4e0114268b973f9d3e9a39982 注意 一个 注意 横幅什么信息 Abstract 一个 摘要 横幅 Info 一个 信息 横幅 Tip 一个 技巧 横幅 Success 一个 成功 横幅 Question 一个 问题 横幅 Warning 一个 警告 横幅 Failure 一个 失败 横幅 Danger 一个 危险 横幅 Bug 一个 Bug 横幅 Example 一个 示例 横幅 Quote 一个 引用 横幅 ","date":"2024-01-10","objectID":"/posts/hugo%E4%B8%BB%E9%A2%98/:0:0","tags":null,"title":"Hugo主题","uri":"/posts/hugo%E4%B8%BB%E9%A2%98/"},{"categories":null,"content":"简介 Quick setup — if you’ve done this kind of thing before or https://github.com/200928/hugo-xiaozao.git Get started by creating a new file or uploading an existing file. We recommend every repository include a README, LICENSE, and .gitignore. …or create a new repository on the command line echo \"# hugo-xiaozao\" \u003e\u003e README.md git init git add README.md git commit -m \"first commit\" git branch -M main git remote add origin https://github.com/200928/hugo-xiaozao.git git push -u origin main …or push an existing repository from the command line git remote add origin https://github.com/200928/hugo-xiaozao.git git branch -M main git push -u origin main ","date":"2024-01-09","objectID":"/posts/vim%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/:1:0","tags":["vim"],"title":"Vim基本操作","uri":"/posts/vim%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"},{"categories":null,"content":"引入依赖 \u003c!--日志输出--\u003e \u003cdependency\u003e \u003cgroupId\u003ech.qos.logback\u003c/groupId\u003e \u003cartifactId\u003elogback-core\u003c/artifactId\u003e \u003cversion\u003e1.2.6\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.slf4j\u003c/groupId\u003e \u003cartifactId\u003eslf4j-api\u003c/artifactId\u003e \u003cversion\u003e1.7.30\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ech.qos.logback\u003c/groupId\u003e \u003cartifactId\u003elogback-classic\u003c/artifactId\u003e \u003cversion\u003e1.2.6\u003c/version\u003e \u003c/dependency\u003e application.yml 修改mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.slf4j.Slf4jImpl可输出到日志文件中 # MyBatis-Plus 配置 mybatis-plus: configuration: # 启用或禁用缓存 cache-enabled: true # 启用或禁用生成的键 use-generated-keys: true # 设置默认的执行器类型。选项有 SIMPLE, REUSE, 和 BATCH default-executor-type: REUSE # 启用或禁用实际参数名的使用 use-actual-param-name: true # 指定 MyBatis-Plus 的日志实现。默认是 org.apache.ibatis.logging.stdout.StdOutImpl # 它只能打印日志到控制台，不能输出到日志文件 #log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # 当前的日志实现是 org.apache.ibatis.logging.slf4j.Slf4jImpl，它支持输出到日志文件 log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl logback-spring.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cconfiguration scan=\"true\" scanPeriod=\"10 seconds\"\u003e \u003c!-- 日志级别从低到高分为TRACE \u003c DEBUG \u003c INFO \u003c WARN \u003c ERROR \u003c FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --\u003e \u003c!-- scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true --\u003e \u003c!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。 --\u003e \u003c!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --\u003e \u003ccontextName\u003elogback\u003c/contextName\u003e \u003c!-- 全局属性：name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。 --\u003e \u003c!-- 日志文件路径属性,不同环境日志输出位置不一样 --\u003e \u003cspringProfile name=\"dev\"\u003e \u003cproperty name=\"log.path\" value=\"dev-logs\"/\u003e \u003c/springProfile\u003e \u003cspringProfile name=\"prod\"\u003e \u003cproperty name=\"log.path\" value=\"prod_logs\"/\u003e \u003c/springProfile\u003e \u003c!-- 控制台日志输出格式属性，magenta:洋红,boldMagenta:粗红,cyan:青色,white:白色,magenta:洋红--\u003e \u003cproperty name=\"CONSOLE_LOG_PATTERN\" value=\"%yellow(%date{yyyy-MM-dd HH:mm:ss}) |%highlight(%-5level) |%blue(%thread) |%blue(%file:%line) |%green(%logger) |%cyan(%msg%n)\"/\u003e \u003cconversionRule conversionWord=\"wEx\" converterClass=\"org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter\"/\u003e \u003cproperty name=\"FILE_LOG_PATTERN\" value=\"%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS}} ${LOG_LEVEL_PATTERN:-%5p} ${PID:- } --- [%t] %-40.40logger{39} %file:%line: %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}\"/\u003e \u003c!--输出到控制台的Appender配置--\u003e \u003cappender name=\"CONSOLE\" class=\"ch.qos.logback.core.ConsoleAppender\"\u003e \u003c!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--\u003e \u003c!-- 例如：如果此处配置了INFO级别，则后面其他位置即使配置了DEBUG级别的日志，也不会被输出 --\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"\u003e \u003clevel\u003eDEBUG\u003c/level\u003e \u003c/filter\u003e \u003cencoder\u003e \u003c!-- 输出日志格式 --\u003e \u003cPattern\u003e${CONSOLE_LOG_PATTERN}\u003c/Pattern\u003e \u003c!-- 设置字符集 --\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c/appender\u003e \u003c!--输出到文件的Appender配置 info日志--\u003e \u003cappender name=\"INFO_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003c!-- 日志具体路径及文件名 --\u003e \u003cfile\u003e${log.path}/log_info.log\u003c/file\u003e \u003c!--日志文件输出格式--\u003e \u003cencoder\u003e \u003cpattern\u003e${FILE_LOG_PATTERN}\u003c/pattern\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c!-- 日志记录器的滚动策略，按日期，按大小记录 --\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"\u003e \u003c!-- 每天日志归档路径以及格式 --\u003e \u003cfileNamePattern\u003e${log.path}/info/log-info-%d{yyyy-MM-dd}.%i.log\u003c/fileNamePattern\u003e \u003ctimeBasedFileNamingAndTriggeringPolicy class=\"ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP\"\u003e \u003cmaxFileSize\u003e100MB\u003c/maxFileSize\u003e \u003c/timeBasedFileNamingAndTriggeringPolicy\u003e \u003c!--日志文件保留天数--\u003e \u003cmaxHistory\u003e60\u003c/maxHistory\u003e \u003c/rollingPolicy\u003e \u003c!-- 此日志文件只记录info级别的 --\u003e \u003cfilter class=\"ch.qos.logback.classic.filter.LevelFilter\"\u003e \u003clevel\u003eINFO\u003c/level\u003e \u003conMatch\u003eACCEPT\u003c/onMatch\u003e \u003conMismatch\u003eDENY\u003c/onMismatch\u003e \u003c/filter\u003e \u003c/appender\u003e \u003c!--输出到文件的Appender配置 warn日志--\u003e \u003cappender name=\"WARN_FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"\u003e \u003cfile\u003e${log.path}/log_warn.log\u003c/file\u003e \u003cencoder\u003e \u003cpattern\u003e${FILE_LOG_PATTERN}\u003c/pattern\u003e \u003ccharset\u003eUTF-8\u003c/charset\u003e \u003c/encoder\u003e \u003c!-- 日志记录器的滚动策略，按日期，按大小记录 --\u003e \u003crollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedR","date":"2023-12-09","objectID":"/posts/springboot%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E6%97%A5%E5%BF%97/:0:0","tags":["Java"],"title":"Spring日志设置","uri":"/posts/springboot%E9%A1%B9%E7%9B%AE%E8%AE%BE%E7%BD%AE%E6%97%A5%E5%BF%97/"},{"categories":null,"content":"start javaw -jar xxxxx netstat -ano | findstr 8848 查看端口占用 pid taskkill /pid xxxx/f 杀死进程 ","date":"2023-11-29","objectID":"/posts/windows%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/:0:0","tags":null,"title":"Windows 项目部署","uri":"/posts/windows%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"categories":null,"content":"1 添加并提交 X-plore handshaker git branch -m 旧分支名 新分支名 git reset HEAD^ git commit -am \"\u003c提交内容\u003e\" git log --oneline git config --global user.name \"\u003c用户名\u003e\" git config --global user.email \"\u003c邮箱\u003e\" git commit --amend --reset-author git pull # 同步本地远端信息 git checkout -b \u003c新分支名\u003e \u003c远程主机名\u003e/\u003c远程分支名\u003e # 基于远程分支代码代码开一个本地分支 git push origin \u003c新分支名\u003e # 将代码推送到远程分支，即在远程开一个同名分支 git branch --set-upstream-to=\u003c远程主机名\u003e/\u003c远程分支名\u003e \u003c本地分支名\u003e # 设置本地分支追踪远程分支 git push 提交代码 Git 提交前缀规范 commit 的类型： feat: 新功能、新特性 fix: 修改 bug perf: 更改代码，以提高性能（在不影响代码内部行为的前提下，对程序性能进行优化） refactor: 代码重构（重构，在不影响代码内部行为、功能下的代码修改） docs: 文档修改 style: 代码格式修改, 注意不是 css 修改（例如分号修改） test: 测试用例新增、修改 build: 影响项目构建或依赖项修改 revert: 恢复上一次提交 ci: 持续集成相关文件修改 chore: 其他修改（不在上述类型中的修改） release: 发布新版本 workflow: 工作流相关文件修改 提交 minghui@Arch:~/workspace/sg-code/gitlab/car-management-backend^dev-fmh ♥ % git push 23-11-03 - 9:52:33 致命错误：当前分支 dev-fmh 没有对应的上游分支。 为推送当前分支并建立与远程上游的跟踪，使用 git push --set-upstream origin dev-fmh 为了让没有追踪上游的分支自动配置，参见 'git help config' 中的 push.autoSetupRemote。 minghui@Arch:~/workspace/sg-code/gitlab/car-management-backend^dev-fmh ♥ % git push --set-upstream origin dev-fmh :( 128 23-11-03 - 9:52:56 Username for 'http://10.88.4.34:9091': 10064602 Password for 'http://10064602@10.88.4.34:9091': 枚举对象中: 96, 完成. 对象计数中: 100% (96/96), 完成. 使用 12 个线程进行压缩 压缩对象中: 100% (57/57), 完成. 写入对象中: 100% (62/62), 24.88 KiB | 2.07 MiB/s, 完成. 总共 62（差异 33），复用 0（差异 0），包复用 0 remote: remote: To create a merge request for dev-fmh, visit: remote: http://10.88.4.34:9091/10064602/car-management-backend/-/merge_requests/new?merge_request%5Bsource_branch%5D=dev-fmh remote: To http://10.88.4.34:9091/10064602/car-management-backend.git c3351c1..5866bb1 dev-fmh -\u003e dev-fmh 分支 'dev-fmh' 设置为跟踪 'origin/dev-fmh'。 ","date":"2023-11-09","objectID":"/posts/git%E5%8D%8F%E4%BD%9C/:0:0","tags":null,"title":"Git 协作","uri":"/posts/git%E5%8D%8F%E4%BD%9C/"},{"categories":null,"content":" 同步模式与异步模式 ","date":"2023-10-09","objectID":"/posts/javascript%E5%BC%82%E6%AD%A5/:0:0","tags":null,"title":"JavaScript 异步","uri":"/posts/javascript%E5%BC%82%E6%AD%A5/"},{"categories":null,"content":"同步模式 JavaScript 语言的执行是单线程的，从执行代码来看，是单独一条一条语句从上至下执行，但是这样就会存在阻塞，比如某个操作比较费时（文件读写、网络IO等）下面的代码就不得不等待这个耗时操作执行完成后在执行，显然这种方式非常影响整个程序的使用。 为什么 JavaScript 不设计成多线程执行语言，举个例子，在 Web 应用中，A 函数删除了一个 DOM 节点，B 函数修改了同一个 DOM 节点，那么之后我是使用 A 函数的执行结果还是 B 函数的执行结果？这样会出现很多的问题 ","date":"2023-10-09","objectID":"/posts/javascript%E5%BC%82%E6%AD%A5/:1:0","tags":null,"title":"JavaScript 异步","uri":"/posts/javascript%E5%BC%82%E6%AD%A5/"},{"categories":null,"content":"异步模式 异步模式大概是指运行环境提供的 API 是以同步或者异步模式进行工作的，同步模式指 JavaScript 代码会以同步模式执行，但是其某些 API 会调用其他线程完成某些工作。换句话说，JavaScript 是单线程工作的，但其浏览器并不是单线程工作的，执行 JavaScript 的线程是单线程的。 回调函数 所有异步编程方案的根基，由调用者定义，交给执行者执行的函数 Promise 一种更优雅的异步编程统一方案 ","date":"2023-10-09","objectID":"/posts/javascript%E5%BC%82%E6%AD%A5/:2:0","tags":null,"title":"JavaScript 异步","uri":"/posts/javascript%E5%BC%82%E6%AD%A5/"},{"categories":null,"content":"基本用法 // Promise 基本用法 const promise = new Promise((resolve, reject) =\u003e { // 承诺达成后需要执行的函数 resolve(100); // 承诺失败后需要执行的函数 reject(new Error(\"Promise rejected\")); }); promise.then( (value) =\u003e { console.log(\"resolve\", value); }, (error) =\u003e { console.log(\"rejected\", error); }, ); ","date":"2023-10-09","objectID":"/posts/javascript%E5%BC%82%E6%AD%A5/:2:1","tags":null,"title":"JavaScript 异步","uri":"/posts/javascript%E5%BC%82%E6%AD%A5/"},{"categories":null,"content":"Ajax 例子 // Promise 方式的 AJAX const ajax = (url) =\u003e { return new Promise((resolve, reject) =\u003e { var xhr = new XMLHttpRequest(); xhr.open(\"GET\", url); xhr.responseType = \"json\"; xhr.onload = () =\u003e { if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; xhr.send(); }); }; const url = \"http://localhost:8081/tcarSpotCheckItem/listInspectionItems/装载机\"; ajax(url).then( (res) =\u003e { console.log(\"resolve\", res.data.data); }, (error) =\u003e { console.log(\"reject\", error); }, ); ","date":"2023-10-09","objectID":"/posts/javascript%E5%BC%82%E6%AD%A5/:2:2","tags":null,"title":"JavaScript 异步","uri":"/posts/javascript%E5%BC%82%E6%AD%A5/"},{"categories":null,"content":"链式调用 Promise 对象的 then 方法会返回一个全新的 Promise 对象 后面的 then 方法就是在为上一个 then 返回的 Promise 注册回调 前面 then 方法中回调函数的返回值会作为后面 then 方法回调的参数 如果回调中返回的是 Prmose，那么后面 then 方法的回调会等待它的结束 ajax(url).then( (res) =\u003e { // 成功 }, (error) =\u003e { // 失败 }, ); ajax(url) .then((res) =\u003e { // 成功 }) .catch((error) =\u003e { // 失败 }); // catch 方法其实就是 then 方法的别名，换言之，调用 catch 等价于下面的 then 写法 ajax(url) .then((res) =\u003e { // 成功 }) .then(undefined, (error) =\u003e { // 失败 }); ","date":"2023-10-09","objectID":"/posts/javascript%E5%BC%82%E6%AD%A5/:2:3","tags":null,"title":"JavaScript 异步","uri":"/posts/javascript%E5%BC%82%E6%AD%A5/"},{"categories":null,"content":"静态方法 resolve foo 将会作为 Promise 成功结果返回，然后注册返回 Promise 的成功回调 Promise.resolve(\"foo\").then((value) =\u003e { console.log(value); }); 等价于下面写法，新的 Promise 对象掉调用了成功回调，并传入了 foo 字符串，后面在将返回的 Promise 对象注册成功回调 new Promise((resolve) =\u003e { resolve(\"foo\"); }).then((value) =\u003e { console.log(value); }); 输出结果都是foo 如果 resolve 接收的是一个 Promise 对象 通过 resolve 返回的 Promise 与原来 Promise 相同 const p1 = new Promise((resolve, reject) =\u003e {}); const p2 = Promise.resolve(p1); console.log(p1 === p2); // 输出 true; reject Promise.reject(\"anything\").catch((error) =\u003e { console.log(error); }); // 输出 anything; ","date":"2023-10-09","objectID":"/posts/javascript%E5%BC%82%E6%AD%A5/:2:4","tags":null,"title":"JavaScript 异步","uri":"/posts/javascript%E5%BC%82%E6%AD%A5/"},{"categories":null,"content":" 为什么会有这一篇博客？ 我用的是 ArchLinux+DWM，我尝试连接HDMI无法输出到外接显示器上，下面记录了解决问题的过程，由于这个问题牵涉到了显卡，所以以前遇到的显卡切换问题在这里一并解决了，于此同时画面撕裂的问题也得以解决！ 前言 我尝试通过HDMI连接外接显示器，然后我通过xrandr命令查看输出如下，似乎没有检测到HDMI接口的输出设备 ➜ ~ xrandr Screen 0: minimum 8 x 8, current 1920 x 1080, maximum 32767 x 32767 eDP1 connected primary 1920x1080+0+0 (normal left inverted right x axis y axis) 340mm x 190mm 1920x1080 60.00*+ 59.93 1680x1050 59.88 1400x1050 59.98 1600x900 60.00 59.95 59.82 1280x1024 60.02 1400x900 59.96 59.88 1280x960 60.00 1368x768 60.00 59.88 59.85 1280x800 59.81 59.91 1280x720 59.86 60.00 59.74 1024x768 60.00 1024x576 60.00 59.90 59.82 960x540 60.00 59.63 59.82 800x600 60.32 56.25 864x486 60.00 59.92 59.57 640x480 59.94 720x405 59.51 60.00 58.99 640x360 59.84 59.32 60.00 DP1 disconnected (normal left inverted right x axis y axis) VIRTUAL1 disconnected (normal left inverted right x axis y axis) 于是通过上网冲浪，在一个社区看到了一个帖子，这里我截取部分内容(文章链接见最下) 英伟达显卡闭源驱动我已经安装了，也知道独显似乎没起作用，以前也尝试切换独显，但是切换失败了，这个问题就一直没有得到解决，这次要把这个问题给解决掉！ 通过nvidia-settings查看显卡信息 根据ArchWiki的描述，切换显卡的方案如下： ","date":"2022-06-10","objectID":"/posts/archlinux%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8/:0:0","tags":null,"title":"ArchLinux外接显示器","uri":"/posts/archlinux%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8/"},{"categories":null,"content":"使用可切换显卡 使用 PRIME 渲染卸换（render offload） 这是英伟达为支持可切换显卡提供的官方方法。 详情请参见 PRIME#PRIME render offload。 使用 nouveau 要了解显卡切换相关内容，请参见 PRIME；要了解开源英伟达驱动相关内容，请参见 nouveau。 使用大黄蜂（Bumblebee） 请参见 Bumblebee。 使用 nvidia-xrun 请参见 nvidia-xrun。 使用 optimus-manager 请参见 Optimus-manager 上游文档。其中包含了在 Arch Linux 系统上的安装和配置方法。 我选择用optimus-manager工具（原因还是以前用这个显卡切换没成功，打算继续尝试） ptimus-manager 切换独显 ➜ ~ optimus-manager --switch nvidia ERROR: a GPU setup was initiated but Xorg post-start hook did not run. Log at /var/log/optimus-manager/switch/switch-20220610T152810.log If your login manager is GDM, make sure to follow those instructions: https://github.com/Askannz/optimus-manager#important--gnome-and-gdm-users If your display manager is neither GDM, SDDM nor LightDM, or if you don't use one, read the wiki: https://github.com/Askannz/optimus-manager/wiki/FAQ,-common-issues,-troubleshooting Cannot execute command because of previous errors. 解决方案，根据解决方案的描述，运行prime-offload命令 ➜ ~ prime-offload [8] INFO: # Xorg post-start hook [1946] INFO: Running /etc/optimus-manager/xsetup-integrated.sh [1987] INFO: Writing state {'type': 'done', 'switch_id': '20220610T152810', 'current_mode': 'integrated'} [1988] INFO: Xorg post-start hook completed successfully. ➜ ~ optimus-manager --status Optimus Manager (Client) version 1.4 Current GPU mode : integrated GPU mode requested for next login : no change GPU at startup : integrated Temporary config path: no 再次切换独显 ➜ ~ optimus-manager --switch nvidia WARNING : no power management option is currently enabled (this is the default since v1.2). Switching between GPUs will work but you will likely experience poor battery life. Follow instructions at https://github.com/Askannz/optimus-manager/wiki/A-guide--to-power-management-options to enable power management. You are about to switch GPUs. This will forcibly close all graphical sessions and all your applications WILL CLOSE. (you can pass the --no-confirm option to disable this warning) Continue ? (y/N) \u003e xrandr 设置主屏：xrandr --output eDP-1 --auto --primary 调整副屏在主屏左边：xrandr --output HDMI-1-0 --left-of eDP-1 副屏同步主屏：xrandr --output HDMI-1-0 --same-as eDP-1 自动调整分辨率和位置：xrandr --output HDMI-1-0 --auto 关闭显示器：xrandr --output HDMI-1-0 --off 打开关闭的显示器：xrandr --output HDMI-1-0 --auto 设置分辨率：xrandr --output HDMI-1-0 --mode 1920x1080 配置文件 ➜ optimus-manager cat optimus-manager.conf [amd] DRI=3 driver=modesetting tearfree= [intel] DRI=3 accel= driver=modesetting modeset=yes tearfree= [nvidia] DPI=96 PAT=yes allow_external_gpus=no dynamic_power_management=no ignore_abi=no modeset=yes options=overclocking [optimus] auto_logout=yes pci_power_control=no pci_remove=no pci_reset=no startup_auto_battery_mode=integrated startup_auto_extpower_mode=nvidia startup_mode=nvidia switching=bbswitch 禁用独显 ArchWiki已经说的很清楚了，直接看官方解决方案 根据上面ArchWiki的描述，写了一个简单的脚本 #删除配置文件 sudo rm -rf /etc/X11/xorg.conf.d/20-nvidia.conf #将内核模块添加到模块列表以在引导时加载 echo 'acpi_call' | sudo tee /etc/modules-load.d/acpi_call.conf # 将/etc/tmpfiles.d/acpi_call.conf文件由systemd启动时加载 echo 'w /proc/acpi/call - - - - \\\\_SB.PCI0.PEG0.PEGP._OFF' | sudo tee /etc/tmpfiles.d/acpi_call.conf reboot 仅使用英伟达显卡 根据上面禁用独显的脚本内容知晓，需要删除/etc/modules-load.d/acpi_call.conf和/etc/tmpfiles.d/acpi_call.conf文件， 脚本如下 #!/bin/bash echo '您将切换至独显' echo '输入密码回车将重启，请将工作区文件保存好！！！' # 删除自动加载的acpi_call模块 sudo rm -rf /etc/modules-load.d/acpi_call.conf # 将systemd启动时加载的文件删除(该文件是将独显断电) sudo rm -rf /etc/tmpfiles.d/acpi_call.conf #获取NVIDIA显卡的BusID NVIDIA_BusID=`lspci | egrep 'VGA|3D' | grep 'NVIDIA' | cut -d ' ' -f 1 | sed -r 's/0?(.)/\\1/' | sed -e 's/:0/:/g' -e 's/\\./:/g'` #写入Xorg配置文件 echo 'Section \"Module\" Load \"modesetting\" EndSection Section \"Device\" Identifier \"nvidia\" Driver \"nvidia\" BusID \"PCI:'$NVIDIA_BusID'\" Option \"AllowEmptyInitialConfiguration\" EndSection' | sudo tee /etc/X11/xorg.conf.d/20-nvidia.conf \u003e /dev/null reboot 仅使用Intel显卡 脚本如下 #!/bin/bash echo '您将切换至核显(独显将会断电)' echo '输入密码回车将重启，请将工作区文件保存好！！！' #删除配置文件 sudo rm -rf /etc/X11/xorg.conf.d/20-nvidia.conf #将内核模块添加到模块列表以在引导时加载 echo 'acpi_call' | sudo t","date":"2022-06-10","objectID":"/posts/archlinux%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8/:0:1","tags":null,"title":"ArchLinux外接显示器","uri":"/posts/archlinux%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8/"},{"categories":null,"content":" 安装 安装 samba sudo pacman -S samba 创建配置文件sudo nvim /etc/samba/smb.conf 实例内容 这里 获取 用户配置 ","date":"2022-05-21","objectID":"/posts/smb/:0:0","tags":null,"title":"SMB文件共享","uri":"/posts/smb/"},{"categories":null,"content":"添加用户 Samba 需要 Linux 账户才能使用 - 可以使用已有账户或 创建新用户. 虽然用户名可以和 Linux 系统共享，Samba 使用单独的密码管理，将下面的 samba_user 替换为选择的 Samba 用户 注意：添加的用户必须是系统用户 $ sudo smbpasswd -a minghui New SMB password: Retype new SMB password: Added user minghui. $ sudo pdbedit -L minghui:1000: ","date":"2022-05-21","objectID":"/posts/smb/:0:1","tags":null,"title":"SMB文件共享","uri":"/posts/smb/"},{"categories":null,"content":"创建sambashare用户组 sambashare 名字不要改 $ sudo groupadd sambashare 然后将samba用户添加到sambashare组 $ sudo usermod -aG sambashare minghui ","date":"2022-05-21","objectID":"/posts/smb/:0:2","tags":null,"title":"SMB文件共享","uri":"/posts/smb/"},{"categories":null,"content":"共享文件夹 将要分享的文件夹用户组改为sambashare $ sudo chown root:sambashare /mnt/move_disk/ 以下的操作将会让 sambashare 群组中的用户拥有读取，写入和执行此文件夹中内容的权限： 1770的1是设置粘滞位，创建的文件只有root和文件所属者才可删除 $ sudo chmod 1770 /mnt/move_disk ","date":"2022-05-21","objectID":"/posts/smb/:0:3","tags":null,"title":"SMB文件共享","uri":"/posts/smb/"},{"categories":null,"content":"修改配置文件实现共享 中括号里面的是名称，即共享文件夹的名称 [move_disk] comment = Mary's and Fred's stuff path = /mnt/move_disk valid users = minghui browsable = yes public = yes writable = yes printable = no create mask = 0765 ","date":"2022-05-21","objectID":"/posts/smb/:0:4","tags":null,"title":"SMB文件共享","uri":"/posts/smb/"},{"categories":null,"content":"启动服务 $ systemctl enable smb.service $ systemctl start smb.service ","date":"2022-05-21","objectID":"/posts/smb/:0:5","tags":null,"title":"SMB文件共享","uri":"/posts/smb/"},{"categories":null,"content":"参数说明 path = ：共享目录路径 public = yes/no：设置共享是否允许guest账户访问 browseable = yes/no：设置共享是否可浏览，如果no就表示隐藏，需要通过IP+共享名称进行访问（即其他设备看不到这个共享） read only = yes/no：设置共享是否具有只读权限 writable = yes/no：设置共享是否具有可写权限 printable = yes/no：打印机 write list = username：设置在共享具有写入权限的用户，例如例如write list = user1,user2,@group1,@group2（多用户或组使用逗号隔开，@group表示group用户组） valid users = username：设置允许访问共享的用户，例如valid users = user1,user2,@group1,@group2（多用户或组使用逗号隔开，@group表示group用户组） invalid users = username：设置不允许访问共享的用户 create mask = 0764：创建的文件权限为 764 directory mode = 0755：创建的文件目录为 755 [public] comment = Public Stuff path = /home/minghui/samba public = no browseable = yes read only = yes printable = no valid users = @sambashare write list = @sambashare create mask = 0764 directory mask = 0755 注意：writable与write list有个奇怪的问题，见下 writable = no write list = @sambashare 这样写同样能够写入，说明后者生效了 writable = yes write list = 这样写同样能够写入，说明前者生效了 避免出现这样的情况，统一使用write list来控制读权限 ","date":"2022-05-21","objectID":"/posts/smb/:0:6","tags":null,"title":"SMB文件共享","uri":"/posts/smb/"},{"categories":null,"content":" PPPoE拨号 先安装ppp、re-pppoe $ sudo pacman -S ppp re-pppoe 配置pppoe $ pppoe-setup 欢迎使用 RP-PPPoE 客户端设置。首先，我会对您的系统进行一些检查以确保已安装 PPPoE 客户端 适当地… /usr/bin/pppoe-setup: 抱歉，您必须是 root 才能运行此脚本 使用 root 运行 $ sudo pppoe-setup \u003e\u003e\u003e Enter your PPPoE user name (default bxxxnxnx@sympatico.ca): \u003e\u003e\u003e Enter the Ethernet interface connected to the DSL modem For Solaris, this is likely to be something like /dev/hme0. For Linux, it will be ethn, where 'n' is a number. (default eth0): \u003e\u003e\u003e Enter the demand value (default no): \u003e\u003e\u003e Enter the DNS information here: \u003e\u003e\u003e Please enter your PPPoE password: \u003e\u003e\u003e Please re-enter your PPPoE password: \u003e\u003e\u003e Choose a type of firewall (0-2): \u003e\u003e\u003e Accept these settings and adjust configuration files (y/n)? y Adjusting /etc/ppp/pppoe.conf Adjusting /etc/ppp/pap-secrets and /etc/ppp/chap-secrets (But first backing it up to /etc/ppp/pap-secrets-bak) (But first backing it up to /etc/ppp/chap-secrets-bak) Congratulations, it should be all set up! Type 'pppoe-start' to bring up your PPPoE link and 'pppoe-stop' to bring it down. Type 'pppoe-status' to see the link status. \u003e\u003e\u003e Enter your PPPoE user name (default bxxxnxnx@sympatico.ca):宽带帐号 (default eth0):有线网卡名称 \u003e\u003e\u003e Enter the demand value (default no):默认 no 即可 \u003e\u003e\u003e Enter the DNS information here:可以填百度DNS：180.76.76.76 \u003e\u003e\u003e Please enter your PPPoE password:宽带密码 \u003e\u003e\u003e Choose a type of firewall (0-2):填 0 即可 最后输入y 把配置写入了/etc/ppp/pppoe.conf and /etc/ppp/pap-secrets and /etc/ppp/chap-secret 使用命令 pppoe-start：拨号，显示Connected!表示拨号成功 ➜ ppp sudo pppoe-start . Connected! pppoe-stop：停止拨号 pppoe-status：查看状态 ➜ ppp pppoe-status pppoe-status: Link is up and running on interface ppp0 11: ppp0: \u003cPOINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP\u003e mtu 1492 qdisc fq_codel state UNKNOWN mode DEFAULT group default qlen 3 link/ppp 下面测试 先把 wifi 关闭：nmcli radio wifi off 尝试 ping 百度的 DNS，没有问题，说明已经连接到外网了 ➜ ppp ping 180.76.76.76 PING 180.76.76.76 (180.76.76.76) 56(84) 字节的数据。 64 字节，来自 180.76.76.76: icmp_seq=1 ttl=52 时间=24.2 毫秒 64 字节，来自 180.76.76.76: icmp_seq=2 ttl=52 时间=24.1 毫秒 64 字节，来自 180.76.76.76: icmp_seq=3 ttl=52 时间=25.0 毫秒 ^C --- 180.76.76.76 ping 统计 --- 已发送 3 个包， 已接收 3 个包, 0% packet loss, time 2002ms rtt min/avg/max/mdev = 24.135/24.417/24.955/0.380 ms ➜ ppp 然后尝试 ping 百度，半天没接收到响应 ➜ ppp ping www.baidu.com ^C 说明DNS解析没问题，如果DNS有问题则会显示如下，解决方法是编辑sudo vim /etc/ppp/pppoe.conf文件，把DNS替换成可用的 ➜ ppp ping www.baidu.com ping: www.baidu.com: 域名解析暂时失败 根据网上教程链接解决了该问题 ip a(address)查看网卡信息（省略了部分信息） ➜ ppp ip a 12: ppp0: \u003cPOINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP\u003e mtu 1492 qdisc fq_codel state UNKNOWN group default qlen 3 link/ppp inet 223.145.168.154 peer 223.145.168.1/32 scope global ppp0 valid_lft forever preferred_lft forever ip r(route)查看路由信息 ➜ ppp ip r default via 192.168.1.1 dev enp7s0 proto dhcp src 192.168.1.2 metric 20100 192.168.1.0/24 dev enp7s0 proto kernel scope link src 192.168.1.2 metric 100 192.168.140.0/24 dev vmnet1 proto kernel scope link src 192.168.140.1 192.168.164.0/24 dev vmnet8 proto kernel scope link src 192.168.164.1 223.145.168.1 dev ppp0 proto kernel scope link src 223.145.168.154 默认路由没走 pppoe，需要sudo ip r replace default via 223.145.168.154 dev ppp0 然后再次ip r查看 ➜ ppp ip r default via 223.145.168.154 dev ppp0 default via 192.168.1.1 dev enp7s0 proto dhcp src 192.168.1.2 metric 20100 192.168.1.0/24 dev enp7s0 proto kernel scope link src 192.168.1.2 metric 100 192.168.140.0/24 dev vmnet1 proto kernel scope link src 192.168.140.1 192.168.164.0/24 dev vmnet8 proto kernel scope link src 192.168.164.1 223.145.168.1 dev ppp0 proto kernel scope link src 223.145.168.154 ➜ ppp route -n Kernel IP routing table Destination Gateway Genmask Flags Metric Ref Use Iface 0.0.0.0 223.145.168.154 0.0.0.0 UG 0 0 0 ppp0 0.0.0.0 192.168.1.1 0.0.0.0 UG 20100 0 0 enp7s0 192.168.1.0 0.0.0.0 255.255.255.0 U 100 0 0 enp7s0 192.168.140.0 0.0.0.0 255.255.255.0 U 0 0 0 vmnet1 192.168.164.0 0.0.0.0 255.255.255.0 U 0 0 0 vmnet8 223.145.168.1 0.0.0.0 255.255.255.255 UH 0 0 0 ppp0 然后就解决了！ 有个疑问 我尝试输入sudo ip r replace default via 223.145.168.1 dev ppp0，然后ip r查看","date":"2022-03-02","objectID":"/posts/archlinux-pppoe%E6%8B%A8%E5%8F%B7/:0:0","tags":null,"title":"ArchLinux PPPoE拨号","uri":"/posts/archlinux-pppoe%E6%8B%A8%E5%8F%B7/"},{"categories":null,"content":" ArchLinux安装步骤 ","date":"2022-01-08","objectID":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/:0:0","tags":null,"title":"ArchLinux系统安装","uri":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"连接网络 由于我使用的是WIFI，所以需要手动连接，如果你连接的是路由器LAN口的网线，那么插上就行了！ 输入iwctl，会进入这个工具的使用模式 输入device list查看网卡设备，我是有一个 wlan0 的网卡设备 输入station wlan0 scan，扫描 WIFI 输入station wlan0 get-networks，查看可用 WIFI 列表 下面连接WIFI，输入station wlan0 connect 要连接的WIFI名称，回车后输入密码 然后更新一下系统时间 $ timedatectl set-ntp true 注意看我下面WIFI名称显示方块， 其实就是中文字符显示不出来，建议将WIFI名称改为非中文！ ","date":"2022-01-08","objectID":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/:1:0","tags":null,"title":"ArchLinux系统安装","uri":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"分区并挂载 查看当前磁盘分区fdisk -l详情 分区可以使用两个工具，cfdisk和gdisk，前者是有DOS界面的，后者命令行，下面我用的是 gdisk 然后就是分区了，最少建立两个分区（有boot分区的情况下），即根分区和swap分区 swap分区大小可以分内存一半，或者与内存等大 根分区为其他未分配空间 如果是硬盘里面只装这一个系统就还需要建立boot分区，用来引导系统。因为我原本是还有一个Windows系统，Windows已经创建了boot分区，我就可以不用创建了。 这里分区分好之后，假设分区情况如下 boot分区：/dev/nvme0n1p1 根分区：/dev/nvme0n1p5 swap分区：/dev/nvme0n1p6 下面将分区格式化，执行如下命令 $ mkfs.ext4 -L ArchFSBoot /dev/nvme0n1p5 # -L 指定卷标名 $ mkswap /dev/nvme0n1p6 $ swapon /dev/nvme0n1p6 # 打开交换分区 分区完成后，进行挂载 挂载的目的就是写文件到刚刚所建分区上（刚刚已经格式化了，什么东西都没有），因为我们现在所处的是光盘镜像（可以看到是红色的root），还未安装系统到新建分区上，因此需要通过挂载刚刚新建分区到光盘镜像的某个目录下，与此同时，Linux挂载目录通常是/mnt下 下面把根分区（/dev/nvme0n1p5）挂载到/nmt下 swap分区（/dev/nvme0n1p6）挂载到/mnt/boot下，在挂载前，需要创建/mnt/boot目录 下面开始挂载，注意挂载顺序，先挂载外面的/mnt，然后挂载/mnt下的boot，当然，挂载前需要创建该/mnt/boot目录 下面假设先创建/mnt/boot目录并将此目录作为硬盘/dev/nvme0n1p6的挂载点，直到这里没有任何问题，然后挂载硬盘/dev/nvme0n1p5到/mnt，然后你查看/mnt下的文件ls /mnt，会发现刚刚挂载的/mnt/boot没有了。这里我是认为是先挂载的/mnt/boot这个目录被后面挂载的/mnt所掩盖了，即挂载一个目录后，该目录原始的文件会看不到了，具体原因还未知！类比刚刚，先挂载的/mnt/boot被后面挂载的/mnt掩盖掉了。 $ mount /dev/nvme0n1p5 /mnt $ mkdir /mnt/boot $ mount /dev/nvme0n1p1 /mnt/boot ","date":"2022-01-08","objectID":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/:2:0","tags":null,"title":"ArchLinux系统安装","uri":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"设置镜像源 编辑/etc/pacman.d/mirrorlist文件，查找 China ，把国内源复制到最前面，最上面的源优先级最高 补充一个生成镜像源的网站：https://archlinux.org/mirrorlist/ ","date":"2022-01-08","objectID":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/:3:0","tags":null,"title":"ArchLinux系统安装","uri":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"开始装系统 书接上文，我们把上面的所做的工作用一个图表示 这里很好理解，/mnt等价于需装系统(ArchLinux)的/ 而/mnt/boot等价于/boot 知道了/mnt就是待装系统的/那么现在在/mnt下装系统，官方提供了一条命令pacstrap，下面是我安装的一些东西，按个人需求安装 $ pacstrap /mnt base base-devel linux linux-firmware networkmanager vim intel-ucode git 等待即可！！！ 安装好了之后生成文件表 $ genfstab -U /mnt \u003e\u003e /mnt/etc/fstab /etc/fstab是Linux系统下的n硬盘挂载点文件 ","date":"2022-01-08","objectID":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/:4:0","tags":null,"title":"ArchLinux系统安装","uri":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"新系统配置 刚刚已经将系统安装好了，并且生成了文件表，下面切换到新安装的ArchLinux系统 $ arch-chroot /mnt 语言 $ vim /ect/local.gen 找到zh_CN.UTF-8 UTF-8和en_US.UTF-8 UTF-8前面#删除 生成语言文件 $ locale-gen 设置系统缺省语言文件 $ echo LANG=en_US.UTF-8 \u003e /etc/locale.conf 设置时区 $ ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime $ timedatectl set-ntp true 硬件时钟 $ hwclock --systohc 主机名，我这里设置为 Mingarch $ echo Mingarch \u003e /etc/hostname 域名解析文件（hosts） $ vim /etc/hosts 我的内容如下 # Static table lookup for hostnames. # See hosts(5) for details. 127.0.0.1 localhost ::1 localhost 127.0.1.1 Mingarch.localdomain Mingarch 这里面的 Mingarch 是主机名，不要搞错了 给普通用户执行sudo命令权限 $ visudo 找到%wheel ALL=(ALL) ALL，前面#删除 给 root 用户重新设密码 $ passwd 新建用户并加入组 $ useradd -m minghui $ usermod -aG wheel,audio,video,optical,storage minghui $ passwd minghui 重要一部，安装引导，使用 systemd-boot 安装 systemd-boot系统自带：这是一个教程 $ bootctl install 安装好了之后，进行简单配置 需要配置/boot/loader/loader.conf和/boot/loader/entries/ 首先到/boot/loader/entries/新建一个.conf文件，我这里建为Arch.conf，然后编辑它，我的内容如下 title Arch Linux linux /vmlinuz-linux initrd /intel-ucode.img initrd /initramfs-linux.img options root=\"PARTUUID=87898fba-ac8a-4703-b317-a858ca9a7ffd\" rw vmlinuz-linux：内核文件 上面的options root=指点根文件系统在哪里，我这里使用了PARTUUID，具体查看方法，如果是在 vim 编辑器下，直接输入:r!blkid会写在当前打开文件，然后找到根分区的PARTUUID复制过去，最后别忘记删除无关内容 编辑/boot/loader/loader.conf文件 我的内容如下 default Arch timeout 5 default Arch：表示的是默认读取名为Arch的配置文件，该文件即为刚刚创建的，/boot/loader/entries/Arch.conf ","date":"2022-01-08","objectID":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/:5:0","tags":null,"title":"ArchLinux系统安装","uri":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"新系统重启 先回到光盘镜像文件exit或者Ctrl+D 卸载开始挂载的分区 $ umount -R /mntr 终于可以reboot了，完成 ","date":"2022-01-08","objectID":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/:6:0","tags":null,"title":"ArchLinux系统安装","uri":"/posts/archlinux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"这是一个关于我的页面 ","date":"2018-04-24","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"}]