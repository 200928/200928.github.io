<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>灰灰爱吃小云朵 - 云层小卖铺</title><meta name="author" content="xiaofan"><meta name="copyright" content="xiaofan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="灰灰爱吃小云朵">
<meta property="og:url" content="http://755400668.github.io/page/2/index.html">
<meta property="og:site_name" content="灰灰爱吃小云朵">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://755400668.github.io/img/%E5%A4%B4%E5%83%8F.gif">
<meta property="article:author" content="xiaofan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://755400668.github.io/img/%E5%A4%B4%E5%83%8F.gif"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://755400668.github.io/page/2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":500,"languages":{"author":"作者: xiaofan","link":"链接: ","source":"来源: 灰灰爱吃小云朵","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#ffc0cb","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: false,
  isHome: true,
  isHighlightShrink: true,
  isToc: false,
  postUpdate: '2022-04-11 16:45:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/css/mycss/background.css"><link rel="stylesheet" href="/css/mycss/footer.css"><link rel="stylesheet" href="/css/mycss/scroll_bar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/css/hideCategory.min.css"><link rel="stylesheet" href="/css/mycss/read.css"><link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('http://p1.qhimg.com/bdr/__85/t01013525c6b73d2c2f.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">灰灰爱吃小云朵</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">灰灰爱吃小云朵</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://github.com/755400668" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:755400668@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/08/02/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="RegExp">RegExp</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-02T04:32:33.000Z" title="发表于 2021-08-02 12:32:33">2021-08-02</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.946Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/javaSE/">javaSE</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/java/">java</a></span></div><div class="content">
正则表达式语法
限定符
选择匹配符
分组组合和反向引用
特殊字符
字符匹配符
定位符

元字符
转义号 \\

匹配某些特殊字符需要用到
一个 \ 开头的字符会被当作转义字符处理
Java 的正则表达式中，两个 \\ 代表其他语言的一个 \

需要用到转义符号的字符：* + ( ) $ / \ ? [ ] ^ &#123; &#125;
如匹配 “(“ 写成 \\(
匹配 “.” 写成 \\.

字符匹配符





符号
含义
示例
解释



[ ]
可接受的字符列表
[abcd]
abcd中的任意一个字符


[^ ]
不接受的字符列表
[^abcd]
除 abcd 以外的任一字符，包括数字和特殊符号


-
连字符
A-Z or [AB…Z]
任意大写字母


.
匹配除 \n 以外的任何字符。如果匹配自身，则需要使用\\.
a..b
匹配以 a 开头，b 结尾，中间两个字符任意，长度为 4 的字符串


\\d
匹配单个数字字符，等价于 [0-9]
\\d{3}(\\d)?
匹配 3 或 4 个数字的字符串


\\D
匹配单个非数字字符，等价于 [^0-9]
\\D(\\d)*
匹配以单个非数字开头，后任意个数字的字符串


\\w
匹配单个数字、大小写字母字符，等价于 [0-9a-zA-Z_]
\\d{3}\\w{4}
匹配以 3 个数字开头的长度为 7 的数字字母的字符串


\\W
匹配单个非数字、大小写字母字符，等价于[^0-9a-zA-Z_]
\\W+\\d{2}
匹配以至少 1 个非数字、大小写字母字符开头，2 个数字字符结尾的字符串


\\s
匹配任何空白字符（空格、制符表等）




\\S
匹配任何非空白字符





\\w匹配 4 类：数字，小写字母、大写字母、包括下划线
abc：匹配 abc 字符
(?!)abc：匹配 abc 和 ABC 字符


选择匹配符
一个|

限定符
用于限定前面的字符和组合项连续出现多少次



符号
含义
示例
解释



*
零次或多次匹配前面的字符或子表达式
zo*
zo* 匹配”z”和”zoo”。* 等效于 {0,}


+
一次或多次匹配前面的字符或子表达式
zo+
“zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}


?
零次或一次匹配前面的字符或子表达式
do(es)?
“do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}


&#123;n&#125;
只能输入 n 个字符
[abcd]{3}
由abcd中字母组成的任意长度为 3 的字符串，eg：abc、abd、dda


&#123;n,&#125;
指定至少 n  个匹配
[abcd]{3,}
由abcd中字母组成的任意长度至少为 3 的字符串，eg：abc、adbd、addaa


&#123;n,m&#125;
指定至少 n 个但不多于 m 个匹配
[abcd]{3,5}
由abcd中字母组成的任意长度至少为 3 但不多于 5 的字符串（即 3|4|5个）



定位符



符号
含义
示例
解释



^
指定起始字符
^[0-9]+[a-z]*
以至少一个数字开头，后面任意接小写字母的字符串（也可以没有小写字母字符串）


$
指定结束字符
^[0-9]-[a-z]+$
以一个数字开头后连接 “-”，并以至少一个小写字母结尾的字符串


\\b
匹配目标字符串的边界
abc\b
“abc123abc 4abc“ 会匹配尾部两个 abc，空格分隔会识别为 2 个目标字符串


\\B
匹配目标字符串的非边界
[abcd]{3}
与 \\b正好相反 “abc123abc 4abc” 会匹配头部一个 abc



捕获分组

非命名分组：根据括号个数依次编号为 1、2、3、4… 组，取组的时候用 group(name)

命名分组


group(int group)、group(String name)  重载了，前者通过编号取，后者通过命名取




非捕获分组









(?:pattern)



(?=pattern)



(?!pattern)





</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/07/26/Tree/" title="Tree[realize]">Tree[realize]</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-26T13:51:41.000Z" title="发表于 2021-07-26 21:51:41">2021-07-26</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.908Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/tree-java/">tree - java</a></span></div><div class="content">
二叉树BinaryTree-抽象类
因为树有很多种，有些功能的实现都是一样的，所以把这些实现一样的单独抽取出来放在父类 Tree 

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198public abstract class Tree&lt;E&gt; &#123;    protected int size;   // 节点个数    protected Node&lt;E&gt; root;   // 根节点    protected Comparator&lt;E&gt; comparator;   // 比较器        /*========================父类 Tree 的通抽象函数实现========================*/        // 增加元素    protected abstract void add(E element);    // 删除元素    protected abstract void remove(E element);    // 是否包含元素    protected abstract boolean contains(E element);    /*=====================================================================*/       /*========================父类 Tree 的通用函数实现========================*/        // 元素数量    protected int size() &#123;        return size;    &#125;    // 是否为空    protected boolean isEmpty() &#123;        return size == 0;    &#125;        // 清空所有元素    protected void clear() &#123;        root = null;        size = 0;    &#125;    // 前序遍历    protected void preorderTraversal(Node&lt;E&gt; node, Visitor&lt;E&gt; visitor) &#123;        if (node == null) &#123;            return;        &#125;        visitor.visit(node.element);        preorderTraversal(node.left, visitor);        preorderTraversal(node.right, visitor);    &#125;    // 中序遍历    protected void inorderTraversal(Node&lt;E&gt; node, Visitor&lt;E&gt; visitor) &#123;        if (node == null) &#123;            return;        &#125;        inorderTraversal(node.left, visitor);        visitor.visit(node.element);        inorderTraversal(node.right, visitor);    &#125;    // 后序遍历    protected void postorderTraversal(Node&lt;E&gt; node, Visitor&lt;E&gt; visitor) &#123;        if (node == null) &#123;            return;        &#125;        postorderTraversal(node.left, visitor);        postorderTraversal(node.right, visitor);        visitor.visit(node.element);    &#125;    // 层序遍历    protected void levelOrderTraversal(Node&lt;E&gt; node, Visitor&lt;E&gt; visitor) &#123;        if (node == null) &#123;            return;        &#125;        Queue&lt;Node&lt;E&gt;&gt; queue = new ArrayDeque&lt;&gt;();        queue.add(root);        Node&lt;E&gt; tmp = null;        while (!queue.isEmpty()) &#123;            tmp = queue.poll();            visitor.visit(tmp.element);            if (tmp.left != null) &#123;                queue.add(tmp.left);            &#125;            if (tmp.right != null) &#123;                queue.add(tmp.right);            &#125;        &#125;    &#125;    /**     * 树的高度     */    public int height() &#123;        return height(root);    &#125;    private int height(Node&lt;E&gt; node) &#123;        if (node == null) return 0;        return 1 + Math.max(height(node.left), height(node.right));    &#125;    public int heightIteration() &#123;        return heightIteration(root);    &#125;    private int heightIteration(Node&lt;E&gt; node) &#123;        int height = 0;        Queue&lt;Node&lt;E&gt;&gt; queue = new ArrayDeque&lt;&gt;();        queue.add(node);        int level = queue.size();   // 记录每层节点数量        while (!queue.isEmpty()) &#123;            Node&lt;E&gt; tmp = queue.poll();            if (tmp.left != null) &#123;                queue.add(tmp.left);            &#125;            if (tmp.right != null) &#123;                queue.add((tmp.right));            &#125;            if (0 == --level) &#123;                height++;                level = queue.size();            &#125;        &#125;        return height;    &#125;    /**     * 判断是否为完全二叉树     *///    public boolean isComplete() &#123;//        Queue&lt;Node&lt;E&gt;&gt; queue = new ArrayDeque&lt;&gt;();//        queue.add(root);//        boolean leaf = false;//        while (!queue.isEmpty()) &#123;//            Node&lt;E&gt; tmp = queue.poll();//            if (!tmp.isLeaf() &amp;&amp; leaf) &#123;//                return false;//            &#125;//            if (tmp.hasTowChildren()) &#123;//                queue.add(tmp.left);//                queue.add(tmp.right);//            &#125; else if (tmp.left == null &amp;&amp; tmp.right != null) &#123;//                return false;//            &#125; else &#123;//                leaf = true;//                if (tmp.left != null) &#123;//                    queue.add(tmp.left);//                &#125;//            &#125;//        &#125;//        return true;//    &#125;    public boolean isComplete() &#123;        Queue&lt;Node&lt;E&gt;&gt; queue = new ArrayDeque&lt;&gt;();        queue.add(root);        boolean leaf = false;        while (!queue.isEmpty()) &#123;            Node&lt;E&gt; tmp = queue.poll();            if (leaf &amp;&amp; !tmp.isLeaf()) &#123;                return false;            &#125;            if (tmp.left != null) &#123;         // left != null                queue.add(tmp.left);            &#125; else if (tmp.right != null) &#123; // left == null &amp;&amp; right != null                return false;            &#125;            if (tmp.right != null) &#123;                queue.add(tmp.right);            &#125; else &#123;    // left != null &amp;&amp; left == null                leaf = true;            &#125;        &#125;        return true;    &#125;            /*=====================================================================*/            protected static class Node&lt;E&gt; &#123;        public E element;        public Node&lt;E&gt; left;        public Node&lt;E&gt; right;        public Node&lt;E&gt; parent;        public Node(E element, Node&lt;E&gt; parent) &#123;            this.element = element;            this.parent = parent;        &#125;        // 判断是否为叶子节点        public boolean isLeaf() &#123;            return left == null &amp;&amp; right == null;        &#125;        // 判断是否度为 2        public boolean hasTowChildren() &#123;            return left != null &amp;&amp; right != null;        &#125;    &#125;&#125;
前驱节点
前驱节点（predecessor）：中序遍历时的前一个节点

下面这个树用这个网址生成：http://btv.melezinek.cz/binary-search-tree.html


中序遍历：33 35 38 39 40 44 57 59 60 61 62 67 68 76

比如 44 的前驱节点是 中序遍历的前一个节点 即 40
40 的前驱节点是 39
38 的前驱节点是 35
57 的前驱节点是 44
33 没有前驱节点
62 的前驱节点是 61
实现流程
根据中序遍历的流程，先遍历目标节点的左子树，那么左子树有无会成为首个判定条件


node.left != null

一直找到目标节点左子树的最右节点：node.left.right.right.right......


node.left == null
一直往上找：node.parent.parent......，直到当前节点是它父节点的右节点：（1）找到了这么一个节点，（2）找不到这么一个节点

比如 57 的父节点是 59(59不是它父节点的右边)，继续往上找，然后找到 59 的父节点 62(62是它父节点的右边)，所以 57 的前驱节点就是 62 的父节点 44
比如 33 的父节点是 35(35不是它父节点的右边)，继续往上找，然后找到 44(44没有父节点了)，因此 33 没有前驱结点


总之就是一直往上找父节点，直到当前节点成为了它父节点的右子树，那么它父节点就是目标节点的前驱结点
如果一直往上找，当前节点都是它父节点的左子树(即找到了顶部)，那么目标节点就没有前驱节点



123456789101112131415161718192021/** * 前驱节点 */public Node&lt;E&gt; predecessor(Node&lt;E&gt; node) &#123;    if (node == null) &#123;        return null;    &#125;    Node&lt;E&gt; cur = node.left;    // 如果左子树不空    if (node.left != null) &#123;        while (cur.right != null) &#123;            cur = cur.right;        &#125;        return cur;    &#125;    // 如果左子树为空，一直找父节点，直到在父节点的右子树上    while (node.parent != null &amp;&amp; node != node.parent.right) &#123;        node = node.parent;    &#125;    return node.parent;&#125;






后继节点实现流程
后继节点（successor）和找前驱异曲同工，同样根据中序遍历的流程，后继节点无非就是找目标节点的后一个，那么有无右子树成为首个判定条件


node.right != null

一直找到目标节点左子树的最右节点：node.right.left.left.left......


node.right == null

总之就是一直往上找父节点，直到当前节点成为了它父节点的左子树，那么它父节点就是目标节点的后继结点
如果一直往上找，当前节点都是它父节点的右子树(即找到了顶部)，那么目标节点就没有后继节点



123456789101112131415161718192021/** * 后继节点 */public Node&lt;E&gt; successor(Node&lt;E&gt; node) &#123;    if (node == null) &#123;        return null;    &#125;    Node&lt;E&gt; cur = node.right;    // 如果右子树不为空    if (node.right != null) &#123;        while (cur.left != null) &#123;            cur = cur.left;        &#125;        return cur;    &#125;    // 如果右子树为空，一直找父节点，直到在父节点的左子树上    while (node.parent != null &amp;&amp; node != node.parent.left) &#123;        node = node.parent;    &#125;    return node.parent;&#125;






二叉搜索树节点
BinaryTreeInfo：是别人写的一个工具，这里是引用

AVL 树概念
平衡因子（Balance Factor）：某节点的左右子树的高度差 
AVL 树特点：
每个节点的平衡因子都是：-1 0 1（绝对值 小于等于 1，如果大于1，称为 ”失衡“
每个节点的左右子树高度差不超过 1
搜索、添加、删除的时间复杂度是 O(logn)




平衡对比
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/07/22/data_struct_01/" title="复杂度">复杂度</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-22T04:32:33.000Z" title="发表于 2021-07-22 12:32:33">2021-07-22</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.887Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">C++ - 数据结构</a></span></div><div class="content">
复杂度
时间复杂度
空间复杂度
忽略低阶项和所有常数项系数
O(1)、O(logN)、O(N)、O(N*logN)、O(N^2)、O(N^3)、O(N^k)、O(2^N)、O(3^N)、O(k^N)、O(N!)


额外空间复杂度

实现一个算法流程，在实现过程中，需要开辟一些空间来完成这个算法过程
作为输入参数的空间，不算额外空间
作为输出结果的空间，也不算额外空间
好比题目要求你把这个数组拷贝一份，那么我肯定要申请数组空间，那么这个数组空间也不算额外空间，因为这是题目的需求，我不得不申请数组空间

如何比较两个算法的好坏


首先比较时间复杂度

如果时间复杂度一样，按理说是比较他们的常数项，但是这个不太现实
比如冒泡排序和插入排序，时间复杂度均为 O(N^2^)，但实际上肯定插入排序好，但是插入排序时间复杂度的常数项是随着测试数据改变而变化
所以我们不能靠理论比较，直接用随机数据测试比较
为什么不理论分析？
因为不同常数时间的操作，虽然时间都是固定的，但是还是有快慢，比如，位运算的常数时间小于算术运算的常数时间，这两个运算的常数时间又小于数组寻址的时间
在者理论分析很困难，很难定量分析



最优解


时间复杂度越低越好

空间复杂度越低越好

时间复杂度相同情况，比较空间复杂度

时间空间复杂度相同情况，两者认为相同
不能因为一些局部细节比较两者好坏，即使常数时间可能有快慢，因为这个因素只决定了实现层次的优化和考虑，而和怎么解决这个问题的思想无关


</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/07/22/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" title="滑动窗口">滑动窗口</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-22T04:32:33.000Z" title="发表于 2021-07-22 12:32:33">2021-07-22</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.948Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">C++ - 数据结构</a></span></div><div class="content">
滑动窗口
T1

假设一个固定大小为 W 的窗口，依次划过 arr
返回每一次滑出状况的最大值
例如：arr = [4,3,5,4,3,3,6,7], W = 3
返回：[5,5,5,4,6,7]

T2

给定一个数组 arr，和一个整数 num
某个 arr 中的子数组 sub，如果想达标，必须满足：
sub 中最大值 - sub 中最小值 &lt;= num
返回 arr 中达标子数组的数量
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/07/20/%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%88C++)/" title="随机数(C++)">随机数(C++)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-20T04:32:33.000Z" title="发表于 2021-07-20 12:32:33">2021-07-20</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.964Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a></span></div><div class="content">
rand()、srand()、time()、clock()rand()
rand()：随机函数，头文件 #include &lt;cstdlib&gt;有些时候不加也可以编译

看 rand() 函数原型
用户未设定随机数种子时，系统默认的随机数种子为1
123456static unsigned long int next = 1;unsigned int rand() &#123;    next = next * 1103515245 + 12345;    return (unsigned int)(next / 65535) % 32768;&#125;
产生的数范围 [0, RAND_MAX) ，RAND_MAX 是一个符号常量

在 Windows 上是 2^15^-1 = 32,768 - 1【0x7FFF】
在 Linux 上是 2^31^-1 = 2,147,483,648 - 1 【0x7FFFFFFF】


rand() 产生的是伪随机数字，每次执行时是相同的
想要每次结果都不同就要将种子时刻发生变化，我们通过 srand()函数传参来改变它的 next 大小


srand()
它会改变 rand() 函数中的参数 next
1234void srand(unsigned int seed) &#123;    next = seed;&#125;
因此可以通过传入一个 无符号整数 改变 next 值，但是这样比较麻烦，每次都要用户输入
可以选择时间作为参数传入


time()详细查看：C++ 日期 &amp; 时间

time(nullptr) 返回的是一个 无符号整数，值为 从1970年到当前时间的秒数

运行下面代码将会得到当前的 年 时 秒
12345unsigned int times = time(nullptr);cout &lt;&lt; times &lt;&lt; endl;cout &lt;&lt; times / 60 / 60 / 24 / 365 + 1970 &lt;&lt; endl;  // 年cout &lt;&lt; times / 60 % 60 &lt;&lt; endl;   // 时cout &lt;&lt; times % 60 &lt;&lt; endl;   // 秒




clock()
直接返回毫秒

随机数生成
rand()生成 [0, RAND_MAX) 的数

rand() % mod：[0, mod)
rand() % mod + k：[k, mod+k)


有了上面两条就可以推出很多公式了

[0, a)随机数：rand() % a

[a, b)随机数：(rand() % (b - a)) + a
1[a, b) --&gt; [0, b-a)+a --&gt; rand() % (b-a) + a 
(a, b]随机数：(rand() % (b - a)) + a + 1
123(a, b] --&gt; (0, b-a]+a --&gt; [1, b-a+1)+a --&gt; [0, b-a)+(a+1) --&gt; (rand()%(b-a))+a+1# 或者(a, b] --&gt; [a+1, b+1) --&gt; [0, b-a)+(a+1) --&gt; (rand()%(b-a))+a+1
[a, b]随机数：(rand() % (b + 1 - a)) + a
1[a, b] --&gt; [a, b+1) --&gt; [0, b+1-a)+a --&gt; (rand()%(b+1-a))+a
(a, b)随机数：(rand() % (b - a - 1)) + a + 1 
1(a, b) --&gt; [a+1, b) --&gt; [0, b-a-1)+(a+1) --&gt; rand()%(b-a-1)+a+1


浮点随机数（左右边界值是否可取没那么重要了）

[0, 1)浮点随机：rand() / double(RAND_MAX)

[0, a)浮点随机：rand() / double(RAND_MAX) * a

(a, b)浮点随机：(rand() / double(RAND_MAX)) * (b - a) + a
1(a, b) --&gt; 0~1之间浮点数 * (a, b) --&gt; rand()/double(RAND_MAX)*(b-a)+a






</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/07/19/Maven/" title="Maven">Maven</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-18T23:32:33.000Z" title="发表于 2021-07-19 07:32:33">2021-07-19</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.992Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/tools/">tools</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Maven/">Maven</a></span></div><div class="content">
Maven 理解当你正在开发两个项目（A和B），如果 A 项目要使用 B 项目的某一个功能（某个一类）。那么最直接的方法就是将 B项目打包成 jar 包，然后在导入 A项目中，这样 A项目就可以使用 B项目里面的功能了。
但是上面这样做非常的麻烦，如果 B项目修复了Bug，A又要重新导入 B项目的 jar包。
回到大局，如果我们需要很多外部 jar包（依赖），一个个手动导入也不是办法

而 Maven就是为了解决项目依赖的问题

Maven 有一个 pom.xml 文件，这个文件就是解决依赖的关键。通过编写该文件，Maven 会根据 pom.xml文件内容下载你需要的 jar包并放在本地的一个仓库。
那么 Maven项目和我们用 IDEA创建的普通 java项目有什么区别，本质没什么区别，个人理解为在普通 java项目上面添加了一个自动解决依赖关系的工具（Maven）
Maven 安装配置
检查 JDK版本 1.7及以上

Maven下载 

这里有 4 种类型的文件

首先明白 bin 和 src 的区别
bin：代表二进制class文件（由java文件编译而成）
src：代表源码（java源码）


zip 和 tar.gz
zip：适用于 Windows
tar.gz：适用于 Linux、MacOs



因此 Windows 平台下下载 bin.zip

配置 Maven 的环境变量

添加一个变量名 MAVEN_HOME （看个人喜好，也可直接添加到 path 中）


添加到 path




检查是否配置成功



切换源和仓库位置
配置好了 Maven环境之后，也简单介绍了 pom.xml文件的作用，项目会根据这个文件下载一些 jar包并且保存到本地一个目录下
但是默认源是国外，网速可能不好，所以可以切换为国内的 阿里源
同时也可以把 jar包的存储路径放到合适的位置

找到 Maven项目路径 –&gt; conf –&gt;  settings.xml

切换为阿里源
这里看到知乎上一篇文章，按照他这个改 将maven源改为国内阿里云镜像
123456789101112131415161718&lt;mirror&gt;    &lt;id&gt;aliyunmaven&lt;/id&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;name&gt;阿里云公共仓库&lt;/name&gt;    &lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;    &lt;id&gt;repo1&lt;/id&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;name&gt;central repo&lt;/name&gt;    &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;    &lt;id&gt;aliyunmaven&lt;/id&gt;    &lt;mirrorOf&gt;apache snapshots&lt;/mirrorOf&gt;    &lt;name&gt;阿里云阿帕奇仓库&lt;/name&gt;    &lt;url&gt;https://maven.aliyun.com/repository/apache-snapshots&lt;/url&gt;&lt;/mirror&gt;


改变 jar包仓库位置



创建 Maven项目
修改好 源 和 仓库位置，下面就创建项目


首先配置 IDEA 环境
全局配置

找到你自己的 Maven目录和仓库位置


创建 Maven项目（java项目）

选择 quickstart


设置 GroupId Artifactld


这一步就是配置了的 Maven环境和项目的参数，在确定一遍是否有错误


最后你可以设置项目保存的位置


进来之后选择箭头指向

过了一段时间下载好之后你就会发现仓库里面的一些 jar 文件





编译项目（使用IDEA的界面操作等同于在终端输入命令）举例添加编译命令

编辑命令


添加一条命令


还可以添加打包命令等等




Maven项目结构
Maven默认约定了一套目录结构，在通过Maven创建了项目以后，项目的目录结构就是以这套目录结构作为模板创建的

1234567891011121314151617$&#123;basedir&#125;|-- pom.xml|-- src|	|-- main|	|	`-- java|	|	`-- resources|	|	`-- filters|	`-- test|	|	`-- java|	|	`-- resources|	|	`-- filters|	`-- it|	`-- assembly|	`-- site`-- LICENSE.txt`-- NOTICE.txt`-- README.txt

src/main/java 项目的源代码
src/main/resources 项目的资源文件
src/main/filters 项目的资源过滤文件
src/main/webapp 如果是web项目，则该目录是web应用源代码所在的目录，比如html文件和web.xml等都在该目录下。
src/test/java 测试代码
src/test/resources 测试相关的资源文件
src/test/filters 测试相关的资源过滤文件
src/it 集成测试代码所在的目录，主要是供别的插件使用的。
src/assembly 组件（Assembly）描述符所在的目录
src/site 站点文件
LICENSE.txt 项目的许可文件
NOTICE.txt 该项目依赖的库的注意事项
README.txt 项目的readme文件


参考：https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/07/14/HTML/" title="HTML">HTML</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-14T01:29:57.000Z" title="发表于 2021-07-14 09:29:57">2021-07-14</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.975Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/HTML/">-HTML</a></span></div><div class="content">
元素head 元素
网站信息设置，比如设置内容的字符编码、网站标题

1234567meta		# 字符编码title		# 网站标题stylelinkbasescriptnoscritpt

h、p、strong 元素
h：标题等级
p：段落标签
strong：强调标签


pre
pre：会完整显示包住内容的格式


将保留元素内容里面的排版，注意缩进



p 标签里面可以嵌套 strong 标签，反之不行
pre 标签可以嵌套 code 标签，反之不行

字符实体
在 HTML 中，某些字符是预留的。
在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。
如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。
字符实体类似这样：

12345&amp;entity_name;或者&amp;#entity_number;


不间断空格
上面我们知道了字符实体
HTML 中的常用字符实体是不间断空格(&nbsp;)。
浏览器总是会截短 HTML 页面中的空格。如果您在文本中写 10 个空格，在显示该页面之前，浏览器会删除它们中的 9 个。如需在页面中增加空格的数量，您需要使用 &nbsp; 字符实体

img 元素
img：图片标签



alt 是 img 的必要属性
有些时候图片要进行缩放

可以直接设置 宽 和 高 。但是这样要安装图片原比例等比缩放，比较麻烦
设置 宽 或者 高，另外一个数据浏览器会自动根据图片的宽高比计算出另外一个数据



Web 图片常用格式

jpg：静态图片，不支持透明
png：静态图片，支持透明
gif：静态图片，动态图片、支持透明

HTML中图片属性的高度和宽度单位默认是 px (1个像素）

a 元素
a：定义超链接，打开新的 URL

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/07/13/oh-my-zsh/" title="oh my zsh">oh my zsh</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-13T02:05:07.000Z" title="发表于 2021-07-13 10:05:07">2021-07-13</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.999Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%BE%8E%E5%8C%96/">美化</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E8%AE%B0%E5%BD%95/">记录</a></span></div><div class="content">


安装 zsh1$ yum install -y zsh




zsh 的基础上安装 oh my zsh12$ sh -c &quot;$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;$ sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;

上面那个安装不了打开下面网址复制里面内容
1$ https://github.com/ohmyzsh/ohmyzsh/blob/master/tools/install.sh
随便在哪个文件夹新建 install.sh，然后把脚本内容粘贴上去
1$ vim install.sh
赋予执行权限
1$ chmod -x install.sh
执行脚本
1$ ./install.sh

如图安装成功




常用插件
git 插件
当有修改并未提交文件会出现一个小 × 符号


sudo 插件


wd 插件（相当于快捷方式，起名之后直接用 【wd + 名字】 跳转）

能够在常用文件夹之中快速切换访问

12345$ wd add name	# 给当前文件夹起名$ wd name		# 切换到name映射的路径下$ wd rm name	# 删除name的映射快捷方式$ wd list		# 查看现有映射$ wd show 		# 查看当前文件夹映射名称


zsh-syntax-highlighting 插件（命令高亮）
先在配置文件（.zshrc）添加插件名称，然后安装依赖

先克隆会失败，要先把插件名称加到配置文件去，具体原因未知

1$ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting


zsh-autosuggestions 插件（命令提示补全，按右键补全）
先添加到配置，在安装依赖
1$ git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions



主题
agnoster


amuse


bira


ys


jonathan


xiong-chiamiov-plus


re5et



1234567891011121314151617# ZSH_THEME=&quot;robbyrussell&quot;# ZSH_THEME=&quot;agnoster&quot;# ZSH_THEME=&quot;amuse&quot;# ZSH_THEME=&quot;random&quot;# ZSH_THEME=&quot;bira&quot;# ZSH_THEME=&quot;jonathan&quot;# ZSH_THEME=&quot;ys&quot;# ZSH_THEME=&quot;xiong-chiamiov-plus&quot;ZSH_THEME=&quot;re5et&quot;plugins=(gitsudowdzsh-syntax-highlightingzsh-autosuggestions)
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/06/04/vim/" title="vim">vim</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-04T04:32:33.000Z" title="发表于 2021-06-04 12:32:33">2021-06-04</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.910Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/tools/">tools</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/vim/">vim</a></span></div><div class="content">
vim常用命令
[ : ] + [ e ] == 保存文档

[ : ] + [ q ] == 退回

[ : ] + [ w ] + [ q ]== 退回

[ i ] == 光标前面写入

[ a ] == 光标后面写入，可在最后一个字符按a，这样就可以在行尾添加了

[ shift ] + [ a ] == 直接跳到行尾

[ shift ] + [ i ] == 直接跳到行前

[ o ] == 新建下一行并将光标跳到下一行

[ shift ] + [ o ] == 新建上一行并光标跳转

[ h ] [ j ] [ k ] [ l ] == 左，下，上，右

[ x ] == 删除当前字符

[ u ] == 撤销

[ d ] + [ num ] + [ 左 ] == 删除左边 num 个字符

[ d ] + [ num ] + [ 右 ] == 删除右边 num 个字符

[ d ] + [ d ] == 剪切这一行

[ y ] + [ num ] + [ 左 ] == 复制左边 num 个字符

[ y ] + [ num ] + [ 右 ] == 复制右边 num 个字符

[ p ] == 粘贴

[ c ] + [ w ] == 更改这个单词（即删除这个单词并进入写入模式）

[ b ] == 移到光标所在单词的第一个

[ c ] + [ i ] + [ 符号 ] == 将符号内的删除并进入写入模式
EX：”Hello World” 按下 ci” 就会删除 “” 里面的东西并开始写入

[ d ] + [ i ] + [ 符号 ] == 将符号内的删除不进入写入模式

[ 0 ] == 回到这行最开头

[ d ] + [ f ] + [ 符号 ] == 从光标处删除到包括符号的字符

[ y ] + [ f ] + [ 符号 ] == 从光标处复制到包括符号的字符

[ c ] + [ f ] + [ 符号 ] == 从光标处删除到包括符号的字符，并进入写入模式

[ / ] + [ 单词 ] == 即搜索单词并跳转到该单词


插件安装
安装 vim 插件管理器
12curl -fLo ~/.vim/autoload/plug.vim --create-dirs \    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim


安装插件

airline
在 GitHub 上搜索 airline 把地址中 github.com 后面的复制到如图位置





配置文件
放到 /root/.vim/vimrc

123456789101112131415161718192021222324252627# 例如syntax on &quot;代码高亮let mapleader=&quot; &quot;noremap J 5jnoremap K 5knoremap &lt;LEADER&gt;&lt;CR&gt; :nohlsearch&lt;CR&gt; &quot;按下空格然后回车取消搜索高亮map S :w&lt;CR&gt;map R :source $MYVIMRC&lt;CR&gt;set hlsearch &quot;搜索高亮exec &quot;nohlsearch&quot;set incsearch &quot;边搜索边高亮set nonumber &quot;行号set relativenumber &quot;行号(以当前行为基)set nocursorline &quot;所在行下划线set wrap &quot;自动折行取消set showcmd &quot;查看指令set wildmenu &quot;指令选择菜单set ignorecase &quot;忽略大小写搜索call plug#begin(&#x27;~/.vim/plugged&#x27;)Plug &#x27;vim-airline/vim-airline&#x27;call plug#end()


粘贴板
将 vim 粘贴板与系统粘贴板互通


查看是否支持 clipboard 
1vim --version | grep clipboard

-clipboard 表示不支持、+clipboard 表示支持


</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/05/09/HEXO%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="HEXO部署到云服务器">HEXO部署到云服务器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-09T08:05:22.000Z" title="发表于 2021-05-09 16:05:22">2021-05-09</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.974Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E8%AE%B0%E5%BD%95/">记录</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a></span></div><div class="content">
服务器购买
购买，这里以腾讯云服务器为例子

登录


不记得密码重置密码


重置密码之后用终端登录，用 xshell 为例



git及创建仓库git及用户
安装
1yum install git

查看 git 版本
1&gt;git version

创建一个 git 账户用来管理以后的博客
12345# 创建 git 账户adduser git# 为 git 账户设置密码passwd git
为 git 用户 添加权限
12vim /etc/sudoersgit     ALL=(ALL)       ALL


最后你为 git用户 添加秘钥（我理解为和本地进行身份校准，秘钥不一致就表示不匹配，就无法上传）
12mkdir -p /home/git/.sshvim /home/git/.ssh/authorized_keys
然后把本地的公钥粘贴进去：在本地的 C:\Users\用户名\ .ssh\ 下，如图

如果没有的话就创建秘钥，方法如下
1ssh-keygen -t rsa

上面对 git 用户操作就结束了，下面是创建一个 git仓库（存放博客）



仓库创建
切换到 git用户（重要）
1su git

这里忘记切换的话，后面从本地部署到服务器的时候会报 “权限不够” 错误
而且后面更改很麻烦，要更好很多，一定要先切换到 git用户 再创建仓库


创建仓库
选择一个路径存放：我这里选的是 /home/git/repo
12345mkdir /home/git/repogit init --bare name.git# 这里我的是仓库名是 huiHuiLovesToEatLittleClouds.git# git init --bare huiHuiLovesToEatLittleClouds.git


创建博客存放目录
上面创建了一个仓库用来存放博客，其实并不是真正存放了博客的渲染文件，故我们还需在创建一个文件夹保存真正的博客渲染文件
选择一个路径存放真正能渲染的博客文件：我这里是 /www/wwwroot/Blog_hexo
1mkdir -p /www/wwwroot/Blog_hexo


权限修改（可能不用修改）
现在看下我刚刚创建的 Blog_hexo 这个目录的 所有者和用户组 是 root ，这样的情况就要修改，如果是 git 则不修改，直接跳到 5
然后看下我另外一个博客目录 （hexo）的 所有者和用户组 是 git
这里我们要将 Blog_hexo 的 所有者和用户组 修改为 git

原因：因为我们到时候在本地部署然后上传到服务器的时候是使用 git用户 上传的，不修改的话权限不够，如果想够权限的话直接用 root用户 上传也可以


然后我们修改权限
1chown git:git -R /www/wwwroot/Blog_hexo
仓库和博客目录联系

这里我不太理解其中的逻辑

先梳理一下

仓库是：**/home/git/repo/huiHuiLovesToEatLittleClouds.git**
博客目录是：**/www/wwwroot/Blog_hexo**

然后我们使两者关联起来：先来到仓库，里面有一个 hooks 文件夹，进去创建一个名为 post-receive 文件
12345cd /home/git/repo/huiHuiLovesToEatLittleClouds.git/hooks/vim post-receive# 把下面这个话填进去保存退出# git --work-tree=你的博客目录 --git-dir=你的仓库目录 checkout -fgit --work-tree=/www/wwwroot/Blog_hexo --git-dir=/home/git/repo/huiHuiLovesToEatLittleClouds.git checkout -f

来到这里的话 git 已经配置好了，接下来是 Nginx 的配置



Nginx
安装
1yum install nginx

查看版本
1&gt;nginx -v

找到 nginx 的安装路径
这样是在：**/etc/nginx/** 目录下，找到 nginx.conf 配置文件并修改

server_name：你的域名或服务器IP
root：博客的目录

1vim /etc/nginx/nginx.conf





这里 Nginx 的配置也完成了，下面修改本地的配置文件即可

端口设置
当我们访问一个域名的时候默认是访问它指向的服务器的 80 端口，可以用一个域名对应多个端口



如果需要访问 81 端口：huige.link:81
当然也可以对应2个以上端口

本地
修改配置文件
本地的配置文件（博客的站点配置文件）修改上传仓库为刚刚配置的仓库，具体如图举例




git 表示使用 git 用户上传


本地部署上传到服务器 —— 成功状态



遇到的问题
当我要上传到服务器的时候报错如下


原因及解决如下


原因：由于我当时创建仓库的时候忘记切换到 git用户 创建了所以所有者是 root ，推送的时候没有权限


解决

法一：在创建仓库的时候就使用 git用户

法二：将这个仓库的所有者改为 git，并且仓库里面的子文件夹的所有者也是 git，一直到没有子文件夹为止
如下图这种还是会报错，必须仓库里面的每个文件夹及其子文件夹及其子子文件夹……的所有者均为 git 即可，然后在修改他们的读写执行的权限，看下面（RWX 权限设置）




RWX 权限设置




如果部署过程中遇到了 有关权限 的报错，看下仓库和博客目录是不是 root用户， 因为我们本地使用的是 git用户 进行部署，所以会不够权限。再不行查看文件夹以及文件的 RWX 权限


</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/05/01/MySQL/" title="MySQL基础">MySQL基础</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-01T02:32:33.000Z" title="发表于 2021-05-01 10:32:33">2021-05-01</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.996Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/MySQL/">MySQL</a></span></div><div class="content">

MySQL常用命令汇总



创建用户、删除用户、修改自己密码、修改其他用户密码
1234$ CREATE USER &#x27;user_name&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;user_password&#x27;;$ DROP USER &#x27;user_name&#x27;@&#x27;loaclhost&#x27;;$ SET PASSWORD = PASSWORD(&#x27;新密码&#x27;);$ SET PASSWORD FOR &#x27;user_name&#x27;@&#x27;localhost&#x27; = PASSWORD(&#x27;新密码&#x27;);


MySql安装 - Windows
如果安装过程中，出错了或者想重新再装
sc delete mysql （删除已经安装好的MySQL服务，慎重）


下面用MySQL-5.7.34 例子，注意：exe 文件和 zip 安装不一样


下载 mysql
1https://dev.mysql.com/downloads/mysql/5.7.html
解压后添加环境变量



添加 my.ini 文件
123456789101112[client]port=3306default-character-set=utf8[mysqld]# 设置自己为自己的 mysql 安装目录basedir=D:\Program Files\RELY\mysql-5.7.34-winx64\# 设置为 mysql 的数据目录，这个目录是系统创建，不用认为创建datadir=D:\Program Files\RELY\mysql-5.7.34-winx64\data\port=3306character_set_server=utf8# 跳过安全检查skip-grant-tables


用管理员权限打开 cmd，进入到 mysql 的 bin 目录下
1mysqld -install


初始化数据库
1mysqld --initialize-insecure --user=mysql





启动 mysql 服务
1net start mysql


停止 mysql 服务：net stop mysql


进入 mysql 管理终端
12# 表示当前 root 用户密码为空mysql -u root -p


修改 root 用户密码
1234567use mysql;# 下面语句就是表示 修改 root 用户密码为 123456update user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27; and Host=&#x27;localhost&#x27;;# 刷新权限flush privileges;# 退出（只是退出 mysql 终端）quit


修改 my.ini 文件，再次进入就会进行权限验证了


重新启动 mysql 
123net stop mysqlnet start mysqlmysql -u root -p




最后，全部指令浏览注：如果安装过程出错，清楚 mysql 服务（sc delete mysql），重新按照步骤安装


Windows下安装多个MySQL服务
由于我本机装了MySQL 5 点多
由于某些要求，需要比这个更高的版本，因此上网查找看能不能装两个 MySQL 服务

步骤有点简略，仅仅记录一下过程，前提是要学会怎么装 MySQL
端口不要和原来服务相同
1234567891011121314151617181920212223[mysqld]# 设置3307端口port=3307# 设置mysql的安装目录——文件路径basedir=D:\Program Files\RELY\mysql-8.0.21-winx64# 允许最大连接数max_connections=200# 允许连接失败的次数。max_connect_errors=10# 服务端使用的字符集默认为utf8mb4character-set-server=utf8mb4# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证#mysql_native_passworddefault_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8mb4[client]# 设置mysql客户端连接服务端时默认使用的端口port=3307default-character-set=utf8mb4
初始化数据库，密码在其中
1$ mysqld --initialize --console

安装 MySQL 服务，给他起个名字叫MySQL8，就这一步与单独安装 MySQL 不同，其他基本都相同
1$ mysqld install MySQL8 --defaults-file=&quot;D:\Program Files\RELY\mysql-8.0.21-winx64\my.ini&quot;

启动 mysql 服务


修改密码

然后尝试登陆两个 MySQL 服务

完美收官
MySQL安装 - CentOs
查看系统版本：

12$ uname -a$ uname -m



在某一个位置保存下载 MySQL RPM包
1$ wget https://dev.mysql.com/get/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar
PS：CentOS7.6 自带的类 mysql 数据库是 mariadb，会跟 mysql 冲突，要先删除

首先查询看有没有 mariadb
1$ rpm -qa | grep mariadb
有就删除
1$ rpm -e --nodeps mariadb-libs




解压 mysql RPM 包
1$  tar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar


然后安装 MySQL
1234$ rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm$ rpm -ivh  mysql-community-libs-5.7.26-1.el7.x86_64.rpm$ rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm$ rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm



启动 Mysql
1$ systemctl start mysqld.service


如果启动失败，如下图


出现此错误是由于多次安装mysql。运行命令：
1$ ps -A | grep mysql
使用以下命令终止进程：
1$ sudo pkill mysql
然后运行命令：
1$ ps -A | grep mysqld
还可以通过运行以下命令终止此进程：
1$ sudo pkill mysqld



查看默认分配密码登录
12$ grep &quot;password&quot; /var/log/mysqld.log$ mysql -u root -p[password]



如果输入第一个命令之后是这样的
现在我不知道是什么原因，可能是因为我没卸载干净吧！！



下面解决方法

vim /etc/my.cnf 修改里面代码
加上一行
1skip-grant-tables





修改密码
首先可以设置密码提示（默认 validate_password_policy=1）
1$ mysql&gt; set global validate_password_policy=0;
设置密码
1$ mysql&gt; set password for &#x27;root&#x27;@&#x27;localhost&#x27;=password(&#x27;自己的密码&#x27;);


如果设置不了，如图


12$ use mysql;$ update user set authentication_string=password(&#x27;123456&#x27;) where user=&quot;root&quot;;



设置好了之后刷新使密码生效
1$ mysql&gt; flush privileges;




MySQL卸载 - CentOs
查看 mysql 安装了哪些东西
1$ rpm -qa | grep -i mysql


卸载开始（要用 1 的结果卸载）
1234$ yum remove mysql-community-libs-5.7.26-1.el7.x86_64$ yum remove mysql-community-server-5.7.26-1.el7.x86_64$ yum remove mysql-community-common-5.7.26-1.el7.x86_64$ yum remove mysql-community-client-5.7.26-1.el7.x86_64

然后用 rpm -qa | grep -i mysql查看是否卸载干净


查找 mysql 相关目录
1$ find / -name mysql


删除相关文件（用 3 的结果删除）
1234$ rm -rf /var/lib/mysql$ rm -rf /var/lib/mysql/mysql$ rm -rf /usr/share/mysql$ rm -rf /etc/selinux/targeted/active/modules/100/mysql
删除 /etc/my.cnf
1$ rm -rf /etc/my.cnf


删除/var/log/mysqld.log（如果不删除这个文件，会导致新安装的mysql无法生存新密码，导致无法登陆）
1$ rm -rf /var/log/mysqld.log








数据库命令连接MySQL

登录前，保证 MySQL 服务已经启动

连接到 MySQL 服务（MySQL数据库）的指令
1mysql -h 主机ip -P 端口 -u 用户名 -p密码

-p密码不要有空格
-p后面没有写密码，回车会要求输入密码
如果没有写 -h 主机，默认就是本机
如果没有写 -P 端口，默认就是3306
在实际工作中，端口 3306 是会修改成其他的




图形界面 - Navicat
连接数据库


创建数据库


创建表……


数据库三层结构
所谓安装 MySQL 数据库，就是在主机安装一个数据库管理管理系统（DBMS），这个管理程序可以管理多个数据库。
DBMS（database manage system）

一个数据库中可以创建多个表，以保存数据（信息）

数据库管理系统（DBMS）、数据库和表的关系如图所示

数据库 - 普通表的本质是文件 




SQL语句分类
DDL：数据定义语句 [create 表，库……]
DML：数据操作语句 [增加 insert、修改 update、删除 delete]
DQL：数据查询语句 [select]
DCL：数据控制语句 [管理数据库：比如用户权限 grant revoke]

创建数据库123456CREATE DATABASE [IF NOT EXISTS] db_name[create_specification [, create_specification]...]create_specification:	[DEFAULT] CHARACTER SET charset_name	[DEFAULT] COLLATE collation_name

CHARACTER SET ：指定数据库采用的字符集，如果不指定字符集，默认 utf8
COLLATE ：指定数据库字符集的校对规则
常用的 utf8_bin [区分大小写]
utf8_general_ci [不区分大小写] 
注意默认是 utf8_general_ci




例子
分别创建 3 个数据库，看写法

1234567891011121314# 创建 db02 数据库，并且不设置字符集和校对规则# 字符集默认为 utf8# 校对规则默认为 utf8_general_ciCREATE DATABASE db02;# 创建 db03 数据库# 字符集设置为 utf8# 校对规则为默认CREATE DATABASE db03 CHARACTER SET utf8;# 创建 db04 数据库# 字符集设置为 utf8# 校对规则设置为 utf8_binCREATE DATABASE db04 CHARACTER SET utf8 COLLATE utf8_bin;

创建表
如果创建表的时候没有指定
引擎、字符集、排序规则等参数默认是数据库的字符集和排序规则
比如下面的 db02数据库为 utf8 utf8_general_ci
​                  db04数据库为 utf8 utf8_bin
那么创建表的时候不设置参数的话就默认是数据库的参数



查看删除数据库12345678# 显示数据库语句SHOW DATABASES# 显示数据库创建语句SHOW CREATE DATABASE db_name# 数据库删除语句 DROP DATABASE [IF EXISTS] db_name


备份恢复数据库
备份数据库（DOS下）
1mysqldump -u 用户名 -p -B 数据库1 数据库2 数据库n &gt; 文件名.sql

比如我把数据库 db01 db02 db03 db04 备份到 F 盘下取名为 bak.sql
其实 bak.sql 文件就是对应的 sql 语句



恢复数据库（进入 MySQL命令行）
1sourse 文件名.sql

法一：上面的命令


法二：直接复制备份文件 bak.sql 里面的 sql 语句，然后执行





备份恢复数据库的表
备份数据库的表
1mysqldump -u 用户名 -p 数据库 表1 表2 表n &gt; 文件名.sql

恢复数据表
连接数据库之后，使用需要恢复到的数据库中，然后执行source 路径+文件名.sql
使用哪个数据库就会恢复到哪个数据库中


表表的创建1234567891011CREATE TABLE table_name(    field1 datatype,    field2 datatype,    field3 datatype) character set 字符集 collate 校对规则 engine 存储引擎# field：指定列名 datatype：指定列类型（字段类型）# character set：如不指定则为坐在数据库的字符集# collate：如不指定则为所在数据库的校对规则# engine：引擎

EX：创建 id（整形）、name（字符串）、password（字符串）、birthday（日期），并且字符集设置为 utf8、校对规则为 utf8_bin、引擎为 INNODB

123456CREATE TABLE `user` (		id INT,		`name` VARCHAR(255),		`password` VARCHAR(32),		birthday DATE)		CHARACTER SET utf8 COLLATE utf8_bin ENGINE INNODB;


表数据添加1234-- 单列添加INSERT INTO table_name ( field1, field2,...fieldN ) VALUES(value1, value2,...valueN);-- 多列添加INSERT INTO table_name ( field1, field2,...fieldN ) VALUES(value1, value2,...valueN),(value1, value2,...valueN),.....;




MySql常用数据类型（列类型）


注意：
char(size)：这个 size 表示字符的个数，范围为 [0~255]
varchar(size)：这个size 也表示字符的个数，范围为[0~65535]

用户管理用户创建12345$ CREATE USER &#x27;用户名&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;用户密码&#x27;;# 赋全部权限$ GRANT ALL PRIVILEGES ON *.* TO &#x27;用户名&#x27;@&#x27;登录地址&#x27;;$ FLUSH PRIVILEGES;

下面演示


密码太简单了


密码复杂



给其他用户密码修改
root 用户修改普通用户的密码

1$ SET PASSWORD FOR &#x27;用户名&#x27;@&#x27;登录地址&#x27; = PASSWORD (&#x27;新密码&#x27;);

自己密码修改1$ SET PASSWORD=PASSWORD(&#x27;新密码&#x27;);

查看连接数12mysql&gt; SHOW FULL PROCESSLIST;mysql&gt; SHOW STATUS LIKE &#x27;Threads%&#x27;;

索引12345678910-- 创建索引-- index_name 索引名-- ON table_name(col_name) 表示在表(table_name)的属性(col_name)上建立索引CREATE INDEX index_name ON table_name(col_name)-- 查看表是否创建了索引SHOW INDEX FROM table_name-- 删除索引DROP INDEX index_name ON table_name
索引类型
主键索引：PRIMARY KEY 列自动生成索引
12345-- 建立主键索引ALTER TABLE table_name ADD PRIMARY KEY (col_name)-- 删除主键索引ALTER TABLE table_name DROP PRIMARY KEY


唯一索引：UNIQUE
1CREATE UNIQUE INDEX index_name ON table_name(col_name)


普通索引：INDEX
123456-- 建立普通索引CREATE INDEX index_name ON table_name(col_name)ALTER TABLE table_name ADD INDEX index_name (col_name)-- 删除普通索引DROP INDEX index_name ON table_name


全文索引：FULLTEXT
比如网站搜索一篇文章的内容，模糊查询
MySQL 自带全文索引不好用
开发中考虑使用：全文搜索两个框架：Solr 和 ElasticSearch（ES）



</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/03/27/Battle-of-Tanks/" title="Battle of Tanks">Battle of Tanks</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-27T08:28:58.000Z" title="发表于 2021-03-27 16:28:58">2021-03-27</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.862Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/java/">java</a></span></div><div class="content">
Java绘图坐标体系坐标原点位于左上角，以像素为单位


像素：密度单位
比如屏幕分辨率是 1920x1080 表示每一行有 1920 个像素点，共有 1080 行
所以该屏幕一共有 1920x1080=2,073,600 个像素

线程-基础
程序 Program：为了完成特定任务，用某种语言编写的一组指令的集合，也就是代码
进程：指运行中的程序、进程是一次执行过程，或是正在运行的一个程序、是动态过程，有产生 存在 消亡的过程
线程
由进程创建，是进程的一个实体
一个进程可以拥有多个线程



线程使用继承 Thread 实现多继承
创建一个 Cat 类 每隔 1 秒输出 喵喵
然后分别查看主线程和 Cat 创建的进程

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.ThreadUse;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 9:55 * @ Description: com.ThreadUse * @ Version: 1.0 * 演示通过继承 Thread 类创建线程 */public class Thread01 &#123;    public static void main(String[] args) throws InterruptedException &#123;        // 创建cat对象，可以当成线程使用        Cat cat = new Cat();        cat.start();    // 启动线程 -&gt; 最终会执行 Cat run 方法        // 说明：当 main 线程启动一个子线程 Thread-0 主线程不会阻塞，会继续执行        // 主线程和子线程交替执行        System.out.println(Thread.currentThread().getName());        for (int i = 0; i &lt; 60; i++) &#123;            System.out.println(&quot;主线程 i = &quot; + i);            Thread.sleep(1000);        &#125;    &#125;&#125;/** * 当一个类继承了 Thread 类，该类就可以当做线程使用 * 重写 run 方法，写上自己的业务代码 * run 方法来自 Thread 类实现了Runnable 接口的 run 方法 * *//*    @Override    public void run() &#123;        if (target != null) &#123;            target.run();        &#125;    &#125; */class Cat extends Thread &#123;    private int times = 0;    @Override    public void run() &#123;        while (true) &#123;            System.out.println(&quot;喵喵喵&quot; + (++times) + &quot;，线程名称：&quot; + Thread.currentThread().getName());            // 让该进程休眠 1 秒            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            if (times == 80) &#123;                 break;            &#125;        &#125;    &#125;&#125;

分析：
main 线程会创建一个 Cat 线程
main 函数的线程名为：main
Cat 线程名称为：Thread-0


因为 main 线程执行次数为 60，Thread-0 线程执行次数为80
所以 main 线程先消亡，Thread-0 线程后消亡





这里为何不直接调用 cat.run()，并没有创建新线程

如果调用了 cat.run() 那么下面的代码就要等这个方法执行完成后方可执行（看下图），串行执行了
而且 cat 的线程名称就是 mian 并没有开辟新线程





下面看 start(); 执行源码分析主要执行，无用的省略

12345678// 1	public synchronized void start() &#123;        start0();    &#125;// 2	// start0() 是本地方法，由JVM调用，底层是 C/C++实现	// 真正实现多线程的是 start0() 方法    private native void start0();

通过实现 Runnable 接口实现多线程
说明：由于Java 是单继承的，如果一个类继承了其他类就不能继承 Thread 类了，所以想要实现多线程就可以通过实现 Runnable 接口来实现多线程


12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.ThreadUse;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 11:40 * @ Description: com.ThreadUse * @ Version: 1.0 * 通过实现 Runnable 接口实现多线程 */public class Thread02 &#123;    public static void main(String[] args) &#123;       Dog dog = new Dog();       // 创建一个 Thread 对象，把 dog对象(实现Runnable)，放入 Thread        Thread thread = new Thread(dog);        thread.start();                ThreadProxy threadProxy = new ThreadProxy(dog);        threadProxy.start();    &#125;&#125;class Dog implements Runnable &#123;    @Override    public void run() &#123;        int count = 0;        while (true) &#123;            System.out.println(&quot;汪汪叫：&quot; + (++count) + Thread.currentThread().getName());            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            if (count == 10) &#123;                break;            &#125;        &#125;    &#125;&#125;// 线程代理类，模拟了一个极简的 Thread类class ThreadProxy implements Runnable &#123;    private Runnable target = null;    @Override    public void run() &#123;        if (target != null) &#123;            target.run();        &#125;    &#125;    public ThreadProxy(Runnable target) &#123;        this.target = target;    &#125;    public void start() &#123;        start0();   // 真正实现多线程的方法    &#125;    public void start0() &#123;        run();    &#125;&#125;

上面代码的 ThreadProxy 只是模拟Thread


构造器接受一个实现了 Runnable 类的对象实例 

用户创建线程需要调用 start() 方法

start() 方法再调用 start0() 方法

start0() 方法再调用 run() （这个run方法是传经来的对象）
比如上面代码就是 Dog 的实例 dog


实现两个线程并发123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.ThreadUse;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 12:28 * @ Description: com.ThreadUse * @ Version: 1.0 * main 函数启动两个子线程 */public class Thread03 &#123;    public static void main(String[] args) &#123;        T1 t1 = new T1();        T2 t2 = new T2();        Thread thread1 = new Thread(t1);        Thread thread2 = new Thread(t2);        thread1.start();        thread2.start();    &#125;&#125;class T1 implements Runnable &#123;    private int count = 0;    @Override    public void run() &#123;        do &#123;            System.out.println(&quot;T1:Hello,World &quot; + (++count) + Thread.currentThread().getName());            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125; while (count != 80);    &#125;&#125;class T2 implements Runnable &#123;    private int count = 0;    @Override    public void run() &#123;        do &#123;            System.out.println(&quot;T2:Hello,World &quot; + (++count) + Thread.currentThread().getName());            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125; while (count != 80);    &#125;&#125;// OutT1:Hello,World 1Thread-0T2:Hello,World 1Thread-1T1:Hello,World 2Thread-0T2:Hello,World 2Thread-1T1:Hello,World 3Thread-0T2:Hello,World 3Thread-1................T1:Hello,World 79Thread-0T2:Hello,World 79Thread-1


继承 Thread 和 实现 Runnable 的区别
从java的设计看，这两者本身没有本质的区别，Thread本身就实现了 Runnable 接口
start() -&gt; start0()

实现 Runnable 接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制


12345T3 t3 = new T3();Thread thread1 = new Thread(t3);Thread thread2 = new Thread(t3);thread1.start();thread2.start();


卖票
下面是分别通过 继承和实现接口 两种方法，但都会出现超卖

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.Thread.ThreadUse;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 12:55 * @ Description: com.ThreadUse * @ Version: 1.0 * 使用多线程模拟三个窗口同事售票 100 张 */public class SellTicket &#123;    public static void main(String[] args) &#123;        // 通过继承实现//        SellTicket01 sellTicket01 = new SellTicket01();//        SellTicket01 sellTicket02 = new SellTicket01();//        SellTicket01 sellTicket03 = new SellTicket01();//        sellTicket01.start();//        sellTicket02.start();//        sellTicket03.start();        // 通过接口实现        SellTicket02 sellTicket = new SellTicket02();        Thread thread01 = new Thread(sellTicket);        Thread thread02 = new Thread(sellTicket);        Thread thread03 = new Thread(sellTicket);        thread01.start();        thread02.start();        thread03.start();    &#125;&#125;// 通过继承方式class SellTicket01 extends Thread &#123;    private static int ticketNum = 100; // 让多个线程去销售    @Override    public void run() &#123;        while (true) &#123;            if (ticketNum &lt;= 0) &#123;                System.out.println(&quot;票以售完&quot;);                break;            &#125;            try &#123;                Thread.sleep(50);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;窗口：&quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot; +                    &quot; 剩余票数：&quot; + (--ticketNum));        &#125;    &#125;&#125;// 通过 接口方式class SellTicket02 implements Runnable &#123;    private int ticketNum = 100; // 让多个线程去销售    @Override    public void run() &#123;        while (true) &#123;            if (ticketNum &lt;= 0) &#123;                System.out.println(&quot;票以售完&quot;);                break;            &#125;            try &#123;                Thread.sleep(50);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;窗口：&quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot; +                    &quot; 剩余票数：&quot; + (--ticketNum));        &#125;    &#125;&#125;


线程终止
设置 loop 值实现——通知方式

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.Thread.ThreadExit;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 14:04 * @ Description: com.Thread.ThreadExit * @ Version: 1.0 */public class ThreadExit01 &#123;    public static void main(String[] args) throws InterruptedException &#123;        T t = new T();        t.start();        System.out.println(&quot;主线程休眠 10s&quot;);        Thread.sleep(10000);        t.setLoop(false);    &#125;&#125;class T extends Thread &#123;    private int num = 0;    private boolean loop = true;    @Override    public void run() &#123;        while (loop) &#123;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;T运行中......&quot; + (++num));        &#125;    &#125;    public void setLoop(boolean loop) &#123;        this.loop = loop;    &#125;&#125;// Out主线程休眠 10sT运行中......1T运行中......2T运行中......3T运行中......4T运行中......5T运行中......6T运行中......7T运行中......8T运行中......9T运行中......10Process finished with exit code 0
线程常用方法
setName    // 设置线程名称

getName   // 返回线程名称

start

run    // 调用线程对象 run 方法

setPriority    // 更改线程的优先级
12345678910111213141516    /**  * The minimum priority that a thread can have.  */ public static final int MIN_PRIORITY = 1;   /**  * The default priority that is assigned to a thread.  */ public static final int NORM_PRIORITY = 5;    /**  * The maximum priority that a thread can have.  */ public static final int MAX_PRIORITY = 10;   
getPriority    // 获取线程的优先级

sleep    // 在指定的毫秒数内让当前正在执行的线程休眠

interrupt    // 中断程序

yield    // 线程礼让，让出cpu，让其他线程执行，但礼让时间不确定，故不一定礼让成功

join    // 线程插队，插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.Thread.Method;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 15:25 * @ Description: com.Thread.Method * @ Version: 1.0 */public class ThreadMethod01 &#123;    public static void main(String[] args) throws InterruptedException &#123;        T t = new T();        t.start();        // 主线程吃包子        for (int i = 1; i &lt;= 20; i++) &#123;            Thread.sleep(1000);            System.out.println(&quot;主线程（小弟）吃了 &quot; + i + &quot; 个包子&quot;);            // 主线程吃 5 个包子就让老大吃完 20 个然后在吃            if (i == 5) &#123;                System.out.println(&quot;主线程（小弟）让 包子给 老大吃&quot;);                // join 线程插队                t.join();                // yield 礼让//                Thread.yield();                System.out.println(&quot;老大吃完了，接下来主线程（小弟）吃&quot;);            &#125;        &#125;    &#125;&#125;class T extends Thread &#123;    @Override    public void run() &#123;        for (int i = 1; i &lt;= 20; i++) &#123;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;子线程（老大）吃了 &quot; + i + &quot; 个包子&quot;);        &#125;    &#125;&#125;// Out子线程（老大）吃了 1 个包子主线程（小弟）吃了 1 个包子主线程（小弟）吃了 2 个包子子线程（老大）吃了 2 个包子主线程（小弟）吃了 3 个包子子线程（老大）吃了 3 个包子主线程（小弟）吃了 4 个包子子线程（老大）吃了 4 个包子主线程（小弟）吃了 5 个包子主线程（小弟）让 包子给 老大吃子线程（老大）吃了 5 个包子子线程（老大）吃了 6 个包子子线程（老大）吃了 7 个包子子线程（老大）吃了 8 个包子子线程（老大）吃了 9 个包子子线程（老大）吃了 10 个包子子线程（老大）吃了 11 个包子子线程（老大）吃了 12 个包子子线程（老大）吃了 13 个包子子线程（老大）吃了 14 个包子子线程（老大）吃了 15 个包子子线程（老大）吃了 16 个包子子线程（老大）吃了 17 个包子子线程（老大）吃了 18 个包子子线程（老大）吃了 19 个包子子线程（老大）吃了 20 个包子老大吃完了，接下来主线程（小弟）吃主线程（小弟）吃了 6 个包子主线程（小弟）吃了 7 个包子主线程（小弟）吃了 8 个包子主线程（小弟）吃了 9 个包子主线程（小弟）吃了 10 个包子主线程（小弟）吃了 11 个包子主线程（小弟）吃了 12 个包子主线程（小弟）吃了 13 个包子主线程（小弟）吃了 14 个包子主线程（小弟）吃了 15 个包子主线程（小弟）吃了 16 个包子主线程（小弟）吃了 17 个包子主线程（小弟）吃了 18 个包子主线程（小弟）吃了 19 个包子主线程（小弟）吃了 20 个包子




用户线程和守护线程
用户线程：也叫工作线程，当线程的任务执行完或通知方式
守护线程：一般为工作线程服务，当所有的用户线程结束，守护线程自动结束
常见的守护线程：垃圾回收机制


下面测试如何将一个线程设置为守护线程
ThreadMethod02

12345678910111213141516171819202122232425262728293031323334353637package com.Thread.Method;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 16:03 * @ Description: com.Thread.Method * @ Version: 1.0 */public class ThreadMethod02 &#123;    public static void main(String[] args) throws InterruptedException &#123;        Thread thread = new Thread(new MyDaemonThread());        // 如果我们希望当 main 线程结束以后，子线程自动结束        // 只需将子线程设置为守护线程        thread.setDaemon(true);        thread.start();        for (int i = 1; i &lt;= 5; i++) &#123;            Thread.sleep(1000);            System.out.println(&quot;我是 main&quot;);        &#125;    &#125;&#125;class MyDaemonThread implements Runnable &#123;    @Override    public void run() &#123;        for (; ; ) &#123;            try &#123;                Thread.sleep(50);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;我是MyDaemonThread&quot;);        &#125;    &#125;&#125;


线程生命周期


通过下面代码查看状态

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.Thread.State;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 16:47 * @ Description: com.Thread.State * @ Version: 1.0 */public class ThreadState &#123;    public static void main(String[] args) throws InterruptedException &#123;        T t = new T();        System.out.println(t.getName() + &quot; 状态 &quot; + t.getState());        t.start();        while (Thread.State.TERMINATED != t.getState()) &#123;            System.out.println(t.getName() + &quot; 状态 &quot; + t.getState());            Thread.sleep(1000);        &#125;        System.out.println(t.getName() + &quot; 状态 &quot; + t.getState());    &#125;&#125;class T extends Thread &#123;    @Override    public void run() &#123;       for (int i = 0; i &lt; 10; i++) &#123;           try &#123;               Thread.sleep(1000);           &#125; catch (InterruptedException e) &#123;               e.printStackTrace();           &#125;           System.out.println(&quot;Hi &quot; + i);       &#125;    &#125;&#125;// OutThread-0 状态 NEWThread-0 状态 RUNNABLEThread-0 状态 RUNNABLEHi 0Thread-0 状态 RUNNABLEHi 1Thread-0 状态 TIMED_WAITINGHi 2Thread-0 状态 TIMED_WAITINGHi 3Thread-0 状态 TIMED_WAITINGHi 4Thread-0 状态 TIMED_WAITINGHi 5Thread-0 状态 TIMED_WAITINGHi 6Thread-0 状态 TIMED_WAITINGHi 7Thread-0 状态 TIMED_WAITINGHi 8Thread-0 状态 TIMED_WAITINGHi 9Thread-0 状态 TERMINATED


线程同步机制
Synchronize
在多线程编程中，一些敏感数据不允许被多个线程同时访问，保证数据在任何时刻，最多有一个线程访问，以保证数据的完整性

12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.Thread.Synchronize;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 12:55 * @ Description: com.Thread.Synchronize * @ Version: 1.0 * 使用多线程模拟三个窗口同事售票 100 张 */public class SellTicket &#123;    public static void main(String[] args) &#123;        // 通过继承实现        SellTicket01 sellTicket01 = new SellTicket01();        SellTicket01 sellTicket02 = new SellTicket01();        SellTicket01 sellTicket03 = new SellTicket01();        sellTicket01.start();        sellTicket02.start();        sellTicket03.start();        // 通过接口实现//        SellTicket02 sellTicket = new SellTicket02();//        Thread thread01 = new Thread(sellTicket);//        Thread thread02 = new Thread(sellTicket);//        Thread thread03 = new Thread(sellTicket);//        thread01.start();//        thread02.start();//        thread03.start();    &#125;&#125;class SellTicket01 extends Thread &#123;    private static int ticketNum = 100; // 让多个线程去销售    private boolean loop = true;    static Object object = new Object();    public void sell() &#123;  // 同步方法，在同一时刻，只能有一个线程来执行该方法        synchronized (object) &#123;            if (ticketNum &lt;= 0) &#123;                loop = false;                System.out.println(&quot;票以售完&quot;);                return;            &#125;            try &#123;                Thread.sleep(50);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;窗口：&quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot; +                    &quot; 剩余票数：&quot; + (--ticketNum));        &#125;    &#125;    @Override    public void run() &#123;        while (loop) &#123;            sell();        &#125;    &#125;&#125;class SellTicket02 implements Runnable &#123;    private static int ticketNum = 100; // 让多个线程去销售    private boolean loop = true;    Object object = new Object();    // 同步方法实现加锁    // 这时锁在 this 对象    // 也可以在代码块写 synchronized ，这是同步代码块    public /*synchronized*/ void sell() &#123;  // 同步方法，在同一时刻，只能有一个线程来执行该方法        synchronized (/*this*/ object) &#123;    // 写this或object都可以            if (ticketNum &lt;= 0) &#123;                loop = false;                System.out.println(&quot;票以售完&quot;);                return;            &#125;            try &#123;                Thread.sleep(50);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;窗口：&quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot; +                    &quot; 剩余票数：&quot; + (--ticketNum));        &#125;    &#125;    @Override    public void run() &#123;        while (loop) &#123;            sell();        &#125;    &#125;&#125;


线程死锁
多个线程都占用了对方的锁资源，但不肯相让，导致了死锁


举例

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.Thread.Synchronize;import javax.sound.midi.Soundbank;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 20:06 * @ Description: com.Thread.Synchronize * @ Version: 1.0 */public class DeadLock &#123;    public static void main(String[] args) &#123;        DeadLockDemo deadLockDemo = new DeadLockDemo(true);        DeadLockDemo deadLockDemo1 = new DeadLockDemo(false);        deadLockDemo.start();        deadLockDemo1.start();    &#125;&#125;class DeadLockDemo extends Thread &#123;    private boolean flag;    static Object o1 = new Object();    static Object o2 = new Object();    public DeadLockDemo(boolean flag) &#123;        this.flag = flag;    &#125;    @Override    public void run() &#123;        while (true) &#123;            if (flag) &#123;                synchronized (o1) &#123;                    System.out.println(Thread.currentThread().getName() + &quot; 进入了 1 &quot;);                    synchronized (o2) &#123;                        System.out.println(Thread.currentThread().getName() + &quot; 进入了 2 &quot;);                    &#125;                &#125;            &#125; else &#123;                synchronized (o2) &#123;                    System.out.println(Thread.currentThread().getName() + &quot; 进入了 3 &quot;);                    synchronized (o1) &#123;                        System.out.println(Thread.currentThread().getName() + &quot; 进入了 4 &quot;);                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;


释放锁
当前线程的同步方法、同步代码执行结束
当前线程在同步代码块、同步方法中遇到了 break、return
当前线程在同步代码块、同步方法中出现了未处理的 Error、Exception，导致异常结束
当前线程在同步代码快、同步方法中执行了线程对象的 wait() 方法，当前线程暂停，并释放锁


下面操作不会释放锁


线程执行同步代码块或者同步方法时，程序调用了 Thread.sleep()、Thread.yield() 方法暂停当前线程的执行，不会释放锁
线程执行同步代码块时，其他线程调用了该线程的 suspend() 方法将该线程挂起，该线程不会释放锁

练习
（1）在main方法中启动两个线程
（2）第 1 个线程循环随机打印 100 以内的整数
（3）直到第 2 个线程从键盘读取了 “Q” 命令

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.Homework;import java.util.Scanner;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 21:11 * @ Description: com.Homework * @ Version: 1.0 */public class Homework01 &#123;    public static void main(String[] args) &#123;        T1 t1 = new T1();        Thread thread = new Thread(t1);        thread.start();        T2 t2 = new T2(t1);        Thread thread1 = new Thread(t2);        thread1.start();    &#125;&#125;// 随机输出 1-100 数字class T1 implements Runnable &#123;    private boolean loop = true;    public boolean isLoop() &#123;        return loop;    &#125;    public void setLoop(boolean loop) &#123;        this.loop = loop;    &#125;    @Override    public void run() &#123;        // 输出 1-100 数字        while (loop) &#123;            System.out.println((int) (Math.random() * 100) + 1);            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(&quot;T1 线程退出&quot;);    &#125;&#125;// 输入 Q 上面的线程就会退出class T2 implements Runnable &#123;    private T1 a;    private Scanner scanner = new Scanner(System.in);    public T2(T1 a) &#123;   // 构造器传入 T1 对象        this.a = a;    &#125;    @Override    public void run() &#123;        while (true) &#123;            // 接受到用户的输入            System.out.println(&quot;请输入指令(Q)表示退出 : &quot;);            char key = scanner.next().toUpperCase().charAt(0);            if (key == &#x27;Q&#x27;) &#123;                // 以通知的方式结束 a                a.setLoop(false);                break;            &#125;        &#125;        System.out.println(&quot;T2 线程退出&quot;);    &#125;&#125;





（1）有 2 个用户分别从同一个卡上取钱 总额为 10000
（2）每次都取 1000，当余额不足时，不能取款
（3）不能出现超取现象

12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.Homework;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 21:47 * @ Description: com.Homework * @ Version: 1.0 */public class Homework02 &#123;    public static void main(String[] args) &#123;        T t = new T();        Thread thread1 = new Thread(t);        thread1.setName(&quot;T1&quot;);        Thread thread2 = new Thread(t);        thread2.setName(&quot;T2&quot;);        thread1.start();        thread2.start();    &#125;&#125;// 取款线程class T implements Runnable &#123;    private int money = 10000;    @Override    public void run() &#123;        while (true) &#123;            synchronized (this) &#123;                if (money &lt; 1000) &#123;                    System.out.println(&quot;余额不足！！！&quot;);                    break;                &#125;                money -= 1000;                System.out.println(Thread.currentThread().getName() + &quot; 取出 1000, 当前余额 : &quot; + money);            &#125;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/03/22/STL/" title="STL">STL</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-22T10:30:25.000Z" title="发表于 2021-03-22 18:30:25">2021-03-22</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.823Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a></span></div><div class="content">
vector接口
构造函数

vector    // 采用模板实现类实现，默认构造函数
vector(v.begin(), v.end)    // 拷贝 v[begin(), end())区间的元素
vector(n, elem)    // 构造函数将 n 个 elem 拷贝给本身
vector(const vector &amp;vec)   // 拷贝构造函数


常用赋值

assign(beg, end);    // 将 [begin, end) 区间的数据拷贝赋值给本身
assign(n, elem);    // 将n个elem拷贝赋值给本身
vector&amp; operator=(const vector &amp;vec);    // 重载等号操作符
swap(vec);    // 将vec与本身的元素互换

12345678910111213// 构造vector&lt;int&gt; v1;vector&lt;int&gt; v2(10, 5);	// 10个5vector&lt;int&gt; v3(v2.begin(), v2.end());	// 将v2拷贝到v3// 赋值vector&lt;int&gt; v4;v4.assign(v3.begin(), v3.end());	// 将v3赋值给v4vector&lt;int&gt; v5;v5 = v3;	// 用等号赋值一样的//swap交换v5.swap(v4);	// 将v5和v4内容互换


大小操作

size();     // 返回元素个数
empty();
resize(int num);     // 重新定义容器长度，如果变长，则用默认值填充新位置，如果变短，则超出的部分元素舍弃
resize(int num, elem);
capacity();     // 容器的容量
reserve(int len);    // 预留len和元素长度，预留位置不初始化，元素不可访问


数据存储操作

at(int index);    // 越界抛异常 out_of_range
operator[];    // 越界运行直接报错
front();    // 返回第一个元素
back();    // 返回最后一个元素


插入和删除

insert(const_iterator pos, int count, elem);    // 迭代器指向位置 pos 插入 count 个 元素 elem
insert(const_iterator pos, elem);    // 同上，不过默认插入一个 elem

123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void printVector(vector&lt;int&gt;&amp;v) &#123;    vector&lt;int&gt;::iterator it;    for (it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot;_&quot;;    &#125;    cout &lt;&lt; endl;&#125;int main() &#123;    vector&lt;int&gt; vec;    vec.push_back(1);    vec.push_back(2);    vec.push_back(3);    vec.push_back(4);    vec.insert(vec.begin(), 100);    printVector(vec);    vec.insert(vec.end(),3, 100);    printVector(vec);    return 0;&#125;/* out100_1_2_3_4_100_1_2_3_4_100_100_100_*/



push_back(elem);     // 尾部插入元素
pop_back();    // 删除最后一个元素
erase(const_iterator start, const_iterator end);     // 删除迭代器从 start 到 end 之间的元素
erase(const_iterator pos);     // 删除迭代器指向的元素
clear();     // 删除容器中所有元素




去重 unique


输出函数1234567891011121314151617// 正序void printVector(vector&lt;int&gt;&amp;v) &#123;    vector&lt;int&gt;::iterator it;    for (it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot;_&quot;;    &#125;    cout &lt;&lt; endl;&#125;// 逆序void printVector_reverse(vector&lt;int&gt;&amp;v) &#123;    vector&lt;int&gt;::reverse_iterator it;    for (it = v.rbegin(); it != v.rend(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot;_&quot;;    &#125;    cout &lt;&lt; endl;&#125;


swap
例子




将未使用的空间进行释放
方法如下


作用：

vector(vec)：利用拷贝构造初始匿名对象

然后匿名创建的占用空间就是使用容量
然后匿名对象和 vec 互换
之后匿名对象会自己析构









priority_queue优先队列，int 默认大的优先123456789101112131415161718192021# include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    priority_queue&lt;int&gt;q;    int n = 5;    for (int i = 0; i &lt; n; i++) &#123;        q.push(i);    &#125;    while (!q.empty()) &#123;        cout &lt;&lt; q.top() &lt;&lt; &quot; &quot;;        q.pop();    &#125;    return 0;&#125;// out// 4 3 2 1 0
priority_queue 小的优先写法12345678910111213141516171819202122# include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;&gt;&gt;q;    int n = 5;    for (int i = 0; i &lt; n; i++) &#123;        q.push(i);    &#125;    while (!q.empty()) &#123;        cout &lt;&lt; q.top() &lt;&lt; &quot; &quot;;        q.pop();    &#125;    return 0;&#125;// out//  0 1 2 3 4
结构体优先写法
不同于 sort() 函数

1234567891011121314151617181920212223242526272829303132# include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node &#123;    int val;    bool friend operator&lt;(node x, node y) &#123;        return x.val &lt; y.val;	// 这样反而是 大的 优先        // 小的优先        // return x.val &gt; y.val;    &#125;&#125;;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    priority_queue&lt;node&gt;q;    int n = 5;    for (int i = 0; i &lt; n; i++) &#123;        node tmp&#123;&#125;;        tmp.val = i;        q.push(tmp);    &#125;    while (!q.empty()) &#123;        cout &lt;&lt; q.top().val &lt;&lt; &quot; &quot;;        q.pop();    &#125;    return 0;&#125;// out// 4 3 2 1 0 


sort() 结构体比较写法1sort(v.begin(), v.begin() + k, Cmp);

写在结构体内
123456struct node &#123;    int val;    bool friend operator&lt;(node x, node y) &#123;        return x.val &lt; y.val;	// 小到大排序    &#125;&#125;;
写在结构体外
1234567struct node &#123;    int val;&#125;;bool Cmp(node x, node y) &#123;    return x.val &gt; y.val;  // 大到小排序&#125;






全排列模板
注意 while (next_permutation(左下标, 右下标))
排列的区间是 [左下标, 右下标)
此例子是 [1, 5) 不包括 m[5]

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    int count = 0;    int m[100];    int n;  cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++) &#123;        m[i] = i;    &#125; do &#123;        for (int i = 1; i &lt;= n; i++) &#123;            cout &lt;&lt; m[i] &lt;&lt; &quot; &quot;;        &#125;        count++;        cout &lt;&lt; endl;    &#125; while (next_permutation(m+1, m+5)); // 左闭右开 [m+1, m+5) 之间的数全排列    cout &lt;&lt; &quot;排列总数：&quot; &lt;&lt; count &lt;&lt; endl;    return 0;&#125;101 2 3 4 5 6 7 8 9 10 1 2 4 3 5 6 7 8 9 10 1 3 2 4 5 6 7 8 9 10 1 3 4 2 5 6 7 8 9 10 1 4 2 3 5 6 7 8 9 10 1 4 3 2 5 6 7 8 9 10 2 1 3 4 5 6 7 8 9 10 2 1 4 3 5 6 7 8 9 10 2 3 1 4 5 6 7 8 9 10 2 3 4 1 5 6 7 8 9 10 2 4 1 3 5 6 7 8 9 10 2 4 3 1 5 6 7 8 9 10 3 1 2 4 5 6 7 8 9 10 3 1 4 2 5 6 7 8 9 10 3 2 1 4 5 6 7 8 9 10 3 2 4 1 5 6 7 8 9 10 3 4 1 2 5 6 7 8 9 10 3 4 2 1 5 6 7 8 9 10 4 1 2 3 5 6 7 8 9 10 4 1 3 2 5 6 7 8 9 10 4 2 1 3 5 6 7 8 9 10 4 2 3 1 5 6 7 8 9 10 4 3 1 2 5 6 7 8 9 10 4 3 2 1 5 6 7 8 9 10 排列总数：24


lower_bound( )、upper_bound( )
数组从小到大顺序时
lower_bound(begin, end, num);    // 返回第一个 大于等于 num 的地址
upper_bound(begin, end, num);   // 返回第一个 大于 num 的地址


数组从大到小顺序时，重载lower_bound()和upper_bound() 即可找到第一个小于等于 num 的地址
lower_bound(begin, end, num, greater);    // 返回第一个 小于等于 num 的地址
upper_bound(begin, end, num, greater);     // 返回第一个 小于 num 的地



1234567891011121314151617181920212223242526272829303132333435363738# include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    int m[5];    m[0] = 0;    m[1] = 2;    m[2] = 4;    m[3] = 6;    m[4] = 8;    int pos1 = lower_bound(m, m+5, 4) - m;    int pos2 = upper_bound(m, m + 5, 4) - m;    cout &lt;&lt; &quot;pos1:&quot; &lt;&lt; pos1 &lt;&lt; endl;    cout &lt;&lt; &quot;pos2:&quot; &lt;&lt; pos2 &lt;&lt; endl;    sort(m, m + 5, greater&lt;int&gt;());    for (int i = 0; i &lt; 5; i++) &#123;        cout &lt;&lt; m[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;        int pos3 = lower_bound(m, m+5, 4, greater&lt;int&gt;()) - m;    int pos4 = upper_bound(m, m + 5, 4, greater&lt;int&gt;()) - m;    cout &lt;&lt; &quot;pos3:&quot; &lt;&lt; pos3 &lt;&lt; endl;    cout &lt;&lt; &quot;pos4:&quot; &lt;&lt; pos4 &lt;&lt; endl;    return 0;&#125;// outpos1:2pos2:38 6 4 2 0 pos3:2pos4:3
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/03/17/data%20struct%20two/" title="data struct two">data struct two</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-17T11:02:24.000Z" title="发表于 2021-03-17 19:02:24">2021-03-17</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.886Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">
前缀树code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package Trees.TrieTree;/** * @ Author: MingHuiFan * @ Date: 2021/3/3 - 21:09 * @ Description: Trees.PrefixTree * @ Version: 1.0 */public class trieTree &#123;    // 前缀树节点    static class TrieNode &#123;        int pass;   // 记录进过了几次        int end;    // 记录以当前节点为尾的字符串        TrieNode[] nexts;   // 记录 &#x27;a&#x27;-&#x27;z&#x27; 的路径        public TrieNode() &#123;            nexts = new TrieNode[26];        &#125;    &#125;    // 前缀树实现    public static class Trie &#123;        private TrieNode root;        public Trie() &#123;            root = new TrieNode();        &#125;        public int size() &#123;            return root.pass;        &#125;        // 插入一段字符串        public void insert(String word) &#123;            if (word == null) &#123;                return;            &#125;            TrieNode node = root;            node.pass++;            int index = 0;  // 记录字母            char[] chars = word.toCharArray();            for (int i = 0; i &lt; chars.length; i++) &#123;                index = chars[i] - &#x27;a&#x27;; // a 对应 0, b 对应 1.....                if (node.nexts[index] == null) &#123;    // 如果未出现过该字母,则创建                    node.nexts[index] = new TrieNode();                &#125;                node = node.nexts[index];                node.pass++;            &#125;            node.end++;        &#125;        // 删除一段字符        public void delete(String word) &#123;            if (search(word) == 0) &#123;                return;            &#125;            TrieNode node = root;            node.pass--;            char[] chars = word.toCharArray();            int index = 0;            for (int i = 0; i &lt; chars.length; i++) &#123;                index = chars[i] - &#x27;a&#x27;;                if (--node.nexts[index].pass == 0) &#123;                    node.nexts[index] = null;                &#125;                node = node.nexts[index];            &#125;            node.end--;            return;        &#125;        // 查询字符在树中出现的次数        public int search(String word) &#123;            if (word == null) &#123;                return 0;            &#125;            TrieNode node = root;            char[] chars = word.toCharArray();            int index = 0;            for (int i = 0; i &lt; chars.length; i++) &#123;                index = chars[i] - &#x27;a&#x27;;                // 如果未在树中存在该路径则直接返回 0                if (node.nexts[index] == null) &#123;                    return 0;                &#125;                node = node.nexts[index];            &#125;            return node.end;        &#125;        // 所有加入的字符串中，计算有多少个是以 pre 为前缀的        public int prefixNumber(String pre) &#123;            if (pre == null) &#123;                return 0;            &#125;            TrieNode node = root;            char[] chars = pre.toCharArray();            int index = 0;            for (int i = 0; i &lt; chars.length; i++) &#123;                index = chars[i] - &#x27;a&#x27;;                if (node.nexts[index] == null) &#123;                    return 0;                &#125;                node = node.nexts[index];            &#125;            return node.pass;        &#125;    &#125;    public static void main(String[] args) &#123;        Trie trie = new Trie();        String string0 = &quot;abc&quot;;        String string1 = &quot;abc&quot;;        String string2 = &quot;acdefg&quot;;        String string3 = &quot;minghuifan&quot;;        trie.insert(string0);        trie.insert(string1);        trie.insert(string2);        trie.insert(string3);        trie.delete(string1);        System.out.println(trie.size());        System.out.println(trie.search(&quot;abc&quot;));    &#125;&#125;





Hash
out f(in)


in -&gt; 无穷
out -&gt; S（一个范围）

MD5：0 ~ 2^64-1
十六进制为16位的字符串，即每个位表示16中状态(00001111 or 0F)

SHA1：0 ~ 2^128-1
十六进制为32位的字符串



相同的in -&gt; 相同的out
说明哈希函数不随机

不同的输入 -&gt; 相同的输出（哈希碰撞）

输入得到的哈希值都均匀且离散的分布在 S 域上

取模



EX1有40亿个无符号整数的文件，无符号整数范围是(0 ~ 2^32^-1)，给 1G 内存返回出现次数最多的整数

2^32^ = 4,294,967,296 约为 43 亿


布隆过滤器
先引入位图

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package Chapter_9;/** * @ Author: MingHuiFan * @ Date: 2021/3/18 - 18:52 * @ Description: Chapter_9 * @ Version: 1.0 */public class BitArr &#123;    // 加入数组中一共有 N 个数，每个数占 4 字节    // 共有 4N Byte = 4N*8 bit    /**     * 改变第 index 位的 0 1     * @param arr     */    static int bitarr(int[] arr, int index) &#123;        int numIndex = index / 32;  // 定位到数组的哪一位        int bitIndex = index % 32;  // 定位在该数的第多少位        int bit = (arr[numIndex] &gt;&gt; bitIndex) &amp; 1;  // 拿到第 index 位的状态        arr[numIndex] = arr[numIndex] | (1 &lt;&lt; bitIndex);    // 将 index 位的数修改为 1//        arr[numIndex] = arr[numIndex] &amp; (~(1 &lt;&lt; bitIndex));   // 将 index 位的数修改为 0        // 总结：取得第 i 位的 0/1 状态 int bit = (arr[i / 32] &gt;&gt; (i % 32)) &amp; 1        return bit;    &#125;    // 打印二进制数    static void test1() &#123;        int[] arr = &#123;1, 2, 3, 4, 5, 6&#125;;        int sum = 0;        for (int i = 0; i &lt; 192; i++) &#123;            System.out.print(bitarr(arr, i));            if (sum++ % 32 == 31) &#123;                System.out.println();            &#125;        &#125;    &#125;    // 一位一位的改变, 下面写法省略了前面 28 个0    // 1 0001   0~31    // 2 0010   32~63    // 3 0011   64~95    // 4 0100   96~127    static void test2() &#123;        int[] arr = &#123;1, 2, 3, 4&#125;;        bitarr(arr, 1);        bitarr(arr, 32);        bitarr(arr, 66);        bitarr(arr, 96);        for (int i : arr) &#123;            System.out.print(i + &quot;_&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        test1();        test2();    &#125;&#125;/** out * 10000000000000000000000000000000 * 01000000000000000000000000000000 * 11000000000000000000000000000000 * 00100000000000000000000000000000 * 10100000000000000000000000000000 * 01100000000000000000000000000000 * 3_3_7_5_ */

题目：
不安全网页的黑名单包含 100亿 个黑名单网页，每个网页的 URL 最多占用 64B。现在想要实现一个网页过滤系统，利用该系统可以根据网页的 URL 判断该网页是否在黑名单上，请设计该系统。
要求：

该系统允许有万分之一以下的判断失误率
使用的额外空间不要超过 30G


这个问题可以使我们认识布隆过滤器器

分析：
如果我们使用 HashSet 来保存每一个 URL，一个 URL 就是 64B，100亿个就是 6400亿B 约为 640G，显然超出要求的额外空间
通过把 URL 保存起来显然是不行的，无法达到题目要求的 30G 以下额外空间
那么就要用到布隆过滤器

通过例子了解实现
上诉我们已经了解了 位图，那么如果我们用位图中的每一个位置来保存一个 URL 需要的内存约为 640/8G 80G，还超过了 30G
但是我们不需要URL个位置，因此还可以将位图进一步缩小至 30G

如何用位图来保存 URL？

每个 URL 通过 k 个哈希函数计算得到一个哈希值然后在模上m（m为位图数位数），当然也可能出现哈希值相同的情况
然后此时每个哈希值对应位图中的每一位，进行描黑（也就是变为1）
然后对每一个 URL 重复上两个操作



然后每个 URL 都通过多个哈希值找到了对应的位置进行描黑处理了

然后查找方式如下，比如查找 URLx 是否在黑名单上

URLx 通过那 k 个哈希函数然后模上m，得到了 k 个位置
然后看这 k 个位置在位图中是否全是黑的状态（即为1状态）


黑URL -&gt; 白   不存在
白URL -&gt; 黑   存在
为什么黑URL不可能报错成白URL：因为同一个 URL 通过相同的哈希函数得到的哈希值是一样的，那么肯定会描黑这些位置的，那么查找的时候这些位置必全为黑
白URL误报成黑URL：如果白URL计算出来的 K个 哈希值刚好是全黑，也就是说当 位图数m 较小、URL数量多且k较多时候可能位图中的每一个位置都描黑了。
那么我们就要降低白报成黑的概率，尽可能减少误报。


那么如何确定 ①k ②m ③url个数 
先确定 m 然后根据样本量和预期失误率来确定 k



n 样本量
p 预期失误率
只需要这两个参数，与单样本大小无关（比如这道题中的一个URL 64B 这个条件无用）



比如这道题中
n = 100亿
p = 0.01%
m = 19.19n = 20n = 2000亿bit = 25G
k = 14
最后计算出真实失误率 p(真) = 0.006%




一致性哈希原理
并查集
通用写法

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package UnionFind;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Stack;/** * @ Author: MingHuiFan * @ Date: 2021/3/19 - 12:17 * @ Description: UnionFind * @ Version: 1.0 */public class UnionFindUniversal&lt;V&gt; &#123;    /*    将 V 类型数据包装成集合形式     */    private static class Element&lt;V&gt; &#123;        V value;        public Element(V value) &#123;            this.value = value;        &#125;    &#125;    // 并查集    public static class UnionFindSet&lt;V&gt; &#123;        HashMap&lt;V, Element&lt;V&gt;&gt; elementHashMap;        HashMap&lt;Element&lt;V&gt;, Element&lt;V&gt;&gt; fatherMap;        HashMap&lt;Element&lt;V&gt;, Integer&gt; sizeMap;        // 遍历元素，将每个元素都包装成一个集合        public UnionFindSet(List&lt;V&gt; list) &#123;            elementHashMap = new HashMap&lt;&gt;();            fatherMap = new HashMap&lt;&gt;();            sizeMap = new HashMap&lt;&gt;();            for (V value : list) &#123;                Element&lt;V&gt; element = new Element&lt;&gt;(value);                elementHashMap.put(value, element);                fatherMap.put(element, element);                sizeMap.put(element, 1);            &#125;        &#125;        // 给一个元素寻找这个元素所在集合的代表元素        public Element&lt;V&gt; findHead(Element&lt;V&gt; element) &#123;            Stack&lt;Element&lt;V&gt;&gt; path = new Stack&lt;&gt;(); // 用于存放元素            while (element != fatherMap.get(element)) &#123; // 如果该元素不属于                path.push(element); // 如果不是代表元素入栈                element = fatherMap.get(element);            &#125;            while (!path.empty()) &#123;                fatherMap.put(path.pop(), element);            &#125;            return element;        &#125;        public boolean isSameSet(V a, V b) &#123;            // 判断ab是否在集合中            if (elementHashMap.containsKey(a) &amp;&amp; elementHashMap.containsKey(b)) &#123;                return findHead(elementHashMap.get(a)) == findHead(elementHashMap.get(b));            &#125;            return false;        &#125;        public void union(V a, V b) &#123;            if (elementHashMap.containsKey(a) &amp;&amp; elementHashMap.containsKey(b)) &#123;                Element&lt;V&gt; aF = findHead(elementHashMap.get(a));                Element&lt;V&gt; bF = findHead(elementHashMap.get(b));                // 判断两个元素是否在同一集合                if (aF != bF) &#123;                    Element&lt;V&gt; maxSet = sizeMap.get(aF) &gt; sizeMap.get(bF) ? aF : bF;                    Element&lt;V&gt; minSet = maxSet == aF ? bF : aF;                    fatherMap.put(minSet, maxSet);  // 将小集合的父亲变为大集合，实现合并操作                    sizeMap.put(maxSet, sizeMap.get(maxSet) + sizeMap.get(minSet));                    sizeMap.remove(minSet);                &#125;            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        list.add(1);        list.add(2);        list.add(3);        list.add(4);        list.add(5);        UnionFindSet&lt;Integer&gt; u1 = new UnionFindSet&lt;&gt;(list);        u1.union(1, 3);        u1.union(1, 4);        System.out.println(u1.isSameSet(3,4));        System.out.println(u1.isSameSet(1,2));        System.out.println(u1.isSameSet(1,3));    &#125;&#125;/* Outtruefalsetrue */

findHead 函数调用的次数越多 平均时间复杂度越接近 O(1)


KMP
先看下暴力方法

123456789101112131415161718public static int force(String text, String pattern)  &#123;    int tlen = text.length();    int plen = pattern.length();    int ti = 0;    int pi = 0;    // 但凡有一个下标越界都退出    while (pi &lt; plen &amp;&amp; ti &lt; tlen) &#123;        if (text.charAt(ti) == pattern.charAt(pi)) &#123;            ti++;            pi++;        &#125; else &#123;            ti -= pi - 1;   // 退回到下一个位置            pi = 0;         // 匹配串回到 0 位置        &#125;    &#125;    // 如果是匹配串越界了一定是匹配成功    return pi == plen ? ti - pi : -1;&#125;
暴力解法就不多说了，文本串一个一个位置滑动

KMP解法为什么快
其实是在暴力解法中文本串中一个一个位置滑动的基础上进行了加速，可以实现跳跃的滑动


先看一个概念
==某一位置前缀和后缀最大匹配长度==
​        即该位置前的前缀和后缀最大匹配长度，但长度并不包括该位置前面的全部
​        如 ababc 
​        c 位置的前缀后缀最大匹配长度为 2 (前缀：ab、后缀：ab)
​        而不是 4（前缀：abab、后缀：abab）,不包括该位置前面全部字符串
​        如果包括的话那么每个字符位置的前缀后缀的最大匹配长度就是前面的长度

例子



位置 0 前面没有信息 —— 0
位置 1 —— 0
位置 2 —— 0
位置 3 —— 0
位置 4 —— 1 （前缀：a、后缀：a）
位置 5 —— 2 （前缀：ab、后缀：ab）
位置 6 —— 3 （前缀：abc、后缀：abc）


然后引入 next 数组
其实就是上面说的 前缀和后缀的最大匹配长度

例子：求法看上面


然后看 KMP 是如何加速的


绿色的为最大前缀和后缀标识，表示 Y 位置前缀后缀的最大匹配长度为 4
当匹配到 XY 位置发现不匹配

按照暴力匹配的话文本串跳到 i + 1 位置，模式串跳到 0 位置，然后开始新的一轮比较

如果是KMP的话，那么直接滑动到如图位置，然后从 X 位置和 j 位置开始比较即可（本质就是 从 i + 5 的位置和 0 位置开始比较）
但是由于后缀和前缀相等，所以 i + 5 —— X 的位置和 0 —— j 的位置必然匹配，所以直接从 X 和 j 位置开始比对所以就加速了整个比对的过程


如果 X 和 j 又不匹配呢如果 next[j] = 3


如果 X 和 j-1 又不匹配呢
重复上述过程
最坏的结果就是滑动到 0 和 X 比较



这里有个问题需要证明：为什么文本串的 i~K 的任何位置都配不出模式串
假设 i~K 中有位置 M 可以匹配出模式串


则 M(X-1) 必然与 0(j+2) 完全匹配 则下图椭圆区域必然完成一致


那么看 next[Y] 是不是就有问题了，next[Y] 本来是 4 但是你又找到了一个比 4 更长的前缀后缀匹配
矛盾，因为 原next[Y] 不可能计算出错。
所以 i~K 位置不可能与匹配串匹配成功。



code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package String;/** * @ Author: MingHuiFan * @ Date: 2021/3/20 - 15:18 * @ Description: String * @ Version: 1.0 */public class KMP &#123;    /*    KMP    O(N)     */    public static int getIndexOf(String text, String pattern) &#123;        if (text.length() &lt; pattern.length() || text.length() &lt; 1) &#123;            return -1;        &#125;        char[] str1 = text.toCharArray();   // 文本串        char[] str2 = pattern.toCharArray();    // 匹配串        int[] next = getNextArray(str2);    // next 数组        int i1 = 0;        int i2 = 0;        while (i1 &lt; str1.length &amp;&amp; i2 &lt; str2.length) &#123;            if (str1[i1] == str2[i2]) &#123; // 如果字符相等两者同时移动到下一个字符                i1++;                i2++;            &#125; else if (next[i2] == -1) &#123;    // str2 中比对的位置已经无法往前跳了                i1++;            &#125; else &#123;                i2 = next[i2];            &#125;        &#125;        // 只要是 i2 越界了，那么一定匹配成功        // 但是 i1 越界不一定匹配失败，因为 i1 i2 可能同时越界        return i2 == str2.length ? i1 - i2 : -1;    &#125;    /*    next 数组    O(M)     */    public static int[] getNextArray(char[] str2) &#123;        if (str2.length == 1) &#123;            return new int[] &#123;-1&#125;;        &#125;        int[] next = new int[str2.length];        next[0] = -1;        next[1] = 0;        int i = 2;        int cn = 0;        while (i &lt; next.length) &#123;            if (str2[i - 1] == str2[cn]) &#123;                next[i++] = ++cn;            &#125; else if (cn &gt; 0) &#123;   // cn 位置和 i - 1 不匹配，继续向前找                cn = next[cn];            &#125; else &#123;                next[i++] = 0;            &#125;        &#125;        return next;    &#125;    public static void main(String[] args) &#123;            &#125;&#125;


</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/03/08/data%20struct%20one/" title="data struct one">data struct one</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-08T08:31:39.000Z" title="发表于 2021-03-08 16:31:39">2021-03-08</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.879Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">
快排
补充：荷兰国旗问题



分析


问题一：


用一个变量 left 标记 &lt;= num 的右边界

此时遍历数组 arr 会出现两种情况

arr[i] &lt;= num：
  arr[i] 和小于等于部分右边界下标的后一个数交换，然后 小于等于区域右扩，i++

arr[i] &gt; num：区域不变, i++



直到越界，如下图例子






问题二：和问题一类似


arr[i] &lt; num，arr[i] 和 &lt; 区域下一个交换，**&lt; 区域右阔，i++**
arr[i] = num，i++
arr[i] &gt; num，arr[i] 和 &gt; 区域前一个交换，**&gt; 区域左扩，i++**



归并排序
时间复杂度：O(N*logN)
空间复杂度：O(N)

Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package Sort;import java.util.Random;/** * @ Author: MingHuiFan * @ Date: 2021/3/8 - 15:05 * @ Description: Sort * @ Version: 1.0 *//** * 时间复杂度分析 *  T(N) = a * T(N/b) + O(N^d) *  T(N) = 2 * T(N/2) + O(N) *  log(a,b) == d   -&gt;  O(N) = O(N*logN) * 空间复杂度：O(N) */public class MergeSort &#123;    // 注意 R 是数组最后一个下标，不是下标加一    public static void process(int[] arr, int L, int R) &#123;        if (L == R) &#123;            return;        &#125;        int mid = L + ((R - L) &gt;&gt; 2);        process(arr, L, mid);   // 左边排序        process(arr, mid + 1, R);   // 右边排序        merge(arr, L, mid, R);  // 整合        return;    &#125;    // 注意这里 R 是数组最后一个下标，不是下标加一    public static void merge(int[] arr, int L, int M, int R) &#123;        int[] help = new int[R - L + 1];        int i = 0;        int left = L;        int right = M + 1;        while (left &lt;= M &amp;&amp; right &lt;= R) &#123;            help[i++] = arr[left] &lt;= arr[right] ? arr[left++] : arr[right++];        &#125;        while (left &lt;= M) &#123;            help[i++] = arr[left++];        &#125;        while (right &lt;= R) &#123;            help[i++] = arr[right++];        &#125;        for (i = 0; i &lt; help.length; i++) &#123;            arr[L + i] = help[i];        &#125;        return;    &#125;    public static void main(String[] args) &#123;        int[] arr = new int[new Random().nextInt(51) + 50]; // 数组大小区间 [50, 100]        for (int i = 0; i &lt;arr.length; i++) &#123;            arr[i] = new Random().nextInt(100) + 100;        &#125;        for (int i = 0; i &lt; arr.length; i++) &#123;            System.out.print(arr[i] + &quot;_&quot;);        &#125;        System.out.println(arr.length);        process(arr, 0, arr.length - 1);        for (int i = 0; i &lt; arr.length; i++) &#123;            System.out.print(arr[i] + &quot;_&quot;);        &#125;    &#125;&#125;


拓展
小和问题-code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package Sort.Merge;import tools.Asserts;import tools.Times;import java.util.Arrays;import java.util.Random;/** * @ Author: MingHuiFan * @ Date: 2021/3/8 - 18:16 * @ Description: Sort.Merge * @ Version: 1.0 */// 小和问题public class SmallSum &#123;    // 小和问题求解函数    public static int smallSum(int[] arr) &#123;        if (arr == null || arr.length &lt; 2) &#123;            return 0;        &#125;        return mergeSort(arr, 0, arr.length - 1);    &#125;    // 递归过程    public static int mergeSort(int[] arr, int l, int r) &#123;        if (l == r) &#123;            return 0;        &#125;        int mid = l + ((r - l) &gt;&gt; 2);        int left = mergeSort(arr, l, mid);  // 左边小和        int right = mergeSort(arr, mid + 1, r); // 右边小和        int sum = merge(arr, l, mid, r);    // 左右合并求小和        return left + right + sum;    &#125;    // 左右两边排序并返回此次左右两边的小和    public static int merge(int[] arr, int l, int m, int r) &#123;        int[] help = new int[r - l + 1];    // 辅助数组        int left = l;        int right = m + 1;        int i = 0;        int res = 0;        // 如果左边不越界并且右边不越界        while (left &lt;= m &amp;&amp; right &lt;= r) &#123;            res += arr[left] &lt; arr[right] ? arr[left] * (r - right + 1) : 0;            help[i++] = arr[left] &lt; arr[right] ? arr[left++] : arr[right++];        &#125;        // 下面两个 while 循环只会进入其一        while (left &lt;= m) &#123;            help[i++] = arr[left++];        &#125;        while (right &lt;= r) &#123;            help[i++] = arr[right++];        &#125;        for (i = 0; i &lt; help.length; i++) &#123;            arr[l + i] = help[i];        &#125;        return res;    &#125;    // 暴力求解小和    public static int force(int[] arr) &#123;        int res = 0;        for (int i = 0; i &lt; arr.length - 1; i++) &#123;            for (int j = i + 1; j &lt; arr.length; j++) &#123;                if (arr[i] &lt; arr[j]) &#123;                    res += arr[i];                &#125;            &#125;        &#125;        return res;    &#125;    public static void main(String[] args) &#123;        int testSum = 100000;   // 测试的次数        // Times测试时间工具        Times.test(&quot;小和计算&quot;, () -&gt; &#123;            for (int test = 0; test &lt; testSum; test++) &#123;                int sum = 100;  // 数组的大小                int[] arr0 = new int[sum];                for (int i = 0; i &lt; arr0.length; i++) &#123;                    arr0[i] = new Random().nextInt(500);                &#125;                int[] arr1 = Arrays.copyOf(arr0, arr0.length);                Asserts.test(force(arr0) == smallSum(arr1));//                System.out.println(Arrays.toString(arr0));//                System.out.println(Arrays.toString(arr1));//                System.out.println(&quot;递归求小和：&quot; + smallSum(arr0));//                System.out.println(&quot;暴力求小和：&quot; + force(arr1));            &#125;        &#125;);    &#125;&#125;


逆序对数量-code
和上面求小和问题是差不多的，这是下面的微小区别



123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package Sort.Merge;import tools.Asserts;import tools.Times;import java.util.Arrays;import java.util.Random;/** * @ Author: MingHuiFan * @ Date: 2021/3/9 - 12:30 * @ Description: Sort.Merge * @ Version: 1.0 */// 逆序对数量public class Reverse &#123;    public static int reverse(int[] arr) &#123;        if (arr == null || arr.length &lt; 2) &#123;            return 0;        &#125;        return mergeSort(arr, 0, arr.length - 1);    &#125;    public static int mergeSort(int[] arr, int l, int r) &#123;        if (l == r) &#123;            return 0;        &#125;        int mid = l + ((r - l) &gt;&gt; 2);        int L = mergeSort(arr, l, mid);        int R = mergeSort(arr, mid + 1, r);        int sum = merge(arr, l, mid, r);        return L + R + sum;    &#125;    public static int merge(int[] arr, int l, int m, int r) &#123;        int[] help = new int[r - l + 1];        int ans = 0;        int left = l;        int right = m + 1;        int i = 0;        while (left &lt;= m &amp;&amp; right &lt;= r) &#123;            ans += arr[left] &gt; arr[right] ? r - right + 1 : 0;            // 大-&gt;小排序 并且 相等要先移右边            help[i++] = arr[left] &gt; arr[right] ? arr[left++] : arr[right++];        &#125;        // 把未排好的排好        while (left &lt;= m) &#123;            help[i++] = arr[left++];        &#125;        while (right &lt;= r) &#123;            help[i++] = arr[right++];        &#125;        for (i = 0; i &lt; help.length; i++) &#123;            arr[l + i] = help[i];        &#125;        return ans;    &#125;    // 暴力求解    public static int force(int[] arr) &#123;        int ans = 0;        for (int i = 0; i &lt; arr.length - 1; i++) &#123;            for (int j = i + 1; j &lt; arr.length; j++) &#123;                if (arr[i] &gt; arr[j]) &#123;                    ans++;                &#125;            &#125;        &#125;        return ans;    &#125;    public static void main(String[] args) &#123;        int testSum = 10000000;        Times.test(&quot;逆序数&quot;, () -&gt; &#123;            for (int test = 0; test &lt; testSum; test++) &#123;                int sum = 5;                int[] arr0 = new int[sum];                for (int i = 0; i &lt; sum; i++) &#123;                    arr0[i] = new Random().nextInt(51) + 50;                &#125;                int[] arr1 = Arrays.copyOf(arr0, arr0.length);                Asserts.test(reverse(arr0) == force(arr1));//                System.out.println(Arrays.toString(arr0));//                System.out.println(Arrays.toString(arr1));//                System.out.print(force(arr0) + &quot;_&quot; + reverse(arr1) + &#x27;\n&#x27;);            &#125;        &#125;);    &#125;&#125;
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/03/04/Linux-notes/" title="Linux_notes">Linux_notes</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-04T13:51:41.000Z" title="发表于 2021-03-04 21:51:41">2021-03-04</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.984Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E8%AE%B0%E5%BD%95/">记录</a></span></div><div class="content">
有趣
火车路过
12$ yum install sl$ sl
动物图案
123$ yum install cowsay$ cowsay$ cowsay -f tux &quot;这是Linux&quot;
2048游戏
12$ wget https://raw.githubusercontent.com/mevdschee/2048.c/master/2048.c # gcc编译即可
贪吃蛇变式
1$ ssh sshtron.zachlatta.com
文字显示
12$ yum install figlet$sudo apt-get install toilet$ figlet 文字
宠物猫
12$ yum install oneko $ oneko
在屏幕上出现一双眼睛，盯着你的鼠标指针
12$ yum install xeyes$ xeyes
不断输出文字
1$ yes Helloween # 这样就会不断输出&quot;Helloween&quot;
factor 分解因数


幽灵打字
12$ yum install pv$ echo &quot;hello world&quot; | pv -qL 10







韩顺平教育






Linux运维工程师：服务器规划、调试优化、市场键控、故障处理、数据备份恢复、日志分析……

Linux嵌入式工程师：linux下驱动开发、嵌入式系统程序开发（C/C++）

Linux应用领域：

服务器：C/C++、pup、java、python、go
嵌入式：机顶盒、数字电视、网络电话、程控交换机、手机、PDA、智能家居、物联网……



基础篇Linux主要发行版：Ubuntu、Redhat、CentOS、Debain(蝶变)、Fedora、SuSE、OpenSUSE(示意图)



VM及安装 CentOS
几个注意点


选择安装位置：分三个区：boot、swap、根分区





网络的三种模式
虚拟机克隆
直接将装好的系统文件夹拷贝即可，然后VM中打开这个文件即可
 

用VM的克隆：克隆时候需要把需要克隆的系统关闭
 其实就是拷贝，克隆的文件可以直接在其他电脑上使用


虚拟机快照
虚拟机迁移和删除
迁移：直接剪切
删除：VM删除、直接删除文件

install vmtoolsRoot用户下安装
用于管理母机和本机的共享文件夹
但是在实际开发中，文件的上传和下载是要使用远程方式完成的




然后终端进去 opt 目录解压这个文件

解压
  

安装：一路回车
  



Linux目录结构







实操篇远程登录Linux

XShell
下载安装后查看 Linux 的 ip
然后 XShell 链接


新建
  

这里填写 Linux 系统的用户名或者Root




填写对应用户的密码
  



XFTP
新建
  

同样用户名和密码
  


Vim


关机重启命令123456shutdown -h now		// 立刻关机shutdown -h 1		// 一分钟后关机shutdown 			// 和上面一行默认是1分钟关机halt 				// 关机reboot				// 重启sync				// 将内存数据同步到磁盘中

用户登录和注销
用户管理
Linux 系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统


创建用户1useradd	用户名		// 添加用户
这样会自动创建一个和用户名同名的家目录，存放在 
/home/用户名

如果想指定家目录的位置则如下例子

12useradd -d /home/test 用户名# 表示用户名的家目录存在放在 /home/test/ 下


设置用户密码1passwd 用户名
注意：如果不写用户名是在当前登录账户更改密码，也就是当前的 root 账户

pwd    // 显示当前绝对路径

删除用户：两种
删除用户，但是保留该用户的家目录
 1userdel 用户名
删除用户以及家目录
 1userdel -r 用户名





查询用户信息1id 用户名


切换用户1su - 用户名

查看当前登录用户信息12who am iwhoami

即使切换了用户，查看也是显示最先登录的用户信息
用户组
系统可以对有共性/权限的多个用户进行统一的管理


新增组：
 1groupadd 组名
删除组
 1groupdel 组名
增加用户的时候直接加上组
 123useradd -g 用户组 用户名如新增一个用户 zwj 并制定到 wudang 组里面去useradd -g wudang zwj
修改用户的组
 1234usermod -g 要放入的组 用户名如将 wudang组的 zwj 修改到 mojiao组里面去step1: groupadd mojiaostep2: usermod -g mojiao zwj




用户和组相关文件

passwd文件：
 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell
 
 Shell解释：
 

shadow文件：
 
 给 king 设置密码在打开看下：此时有了加密口令
 

group文件
 创建用户的时候如果没有之指定组的情况下，会创建一个和用户名相同的组
 



1.如果组里面由用户则不能删除该组

实用指令运行级别

EX：从运行级别 5 到 3（无图形界面）
远程登录也可以切换运行级别




即：

查看运行级别：
  1systemctl get-default
  

改变运行级别
  1systemctl set-default 运行级别
  



重启之后



接下来的每次重启都是进去 运行级别3


注：如果切到无图形化界面（运行级别3）登入不进去root，别使用数字小键盘输入密码（没解锁）

找回 Root 密码

在启动界面按 “e”
 

找到这一行，后面加上 
 1init=/bin/sh
 

然后 Ctrl + X 进入 单用户模式
 

然后在光标闪烁的位置输入下面命令，然后回车
 1mount -o remount,rw /
 

然后输入下面命令
 1passwd
 然后回车输入密码，然后回车后在此输入密码即可
 显示 passwd…..的样式表示密码修改成功
 

然后，在光标闪烁的位置输入下面命令并回车
 1touch /.autorelabel
 

接着在光标闪烁的位置输入下面命令并回车，等待系统自动修改密码，时间可能有点长，完成后，系统会自动重启，新的密码生效
 1exec /sbin/init
 



远程是无法修改 ROOT 密码的

帮助指令
man
 

help
 


文件目录类
pwd 指令
 12# pwdpwd		// 	绝对路径

ls 指令
 12345# lsls		// 显示文件ls -a	// 显示文件包括隐藏文件ls -l	// 列表显示ls -al	// 列表显示包括隐藏文件

cd 指令
 123456# cd# 基本语法# cd 参数cd ~	// 回到当前用户的家目录cd ..	// 回到上一级目录cd /	// 回到根目录
 
 

mkdir 指令
 123456# mkdir# 基本语法：mkdir [选项] 要创建的目录# 创建一个目录mkdir /home/dog		// 在home目录下创建dog目录此时要求home目录存在，不存在创建不成功# 创建多级目录mkdir -p /homg/animal/tiger	 // 此时animal不存在也可以创建

rmdir 指令
 123456# rmdir # 基本语法：rmdir [选项] 要删除的目录# 删除一个空目录rmdir /home/dog# 删除一个非空目录rm -rf /home/animal	// -r递归删除 -f强制删除不提示

touch 指令
 12# touch# 基本语法：touch 文件名称


cp 指令
 12345# cp# 基本语法：cp [选项] source dest# 常用选项：		-r 	递归复制整个文件夹 cp 待拷贝文件或目录 目标目录
 
 

rm 指令
 12345# rm# 基本语法：rm [选项] 要删除的文件或目录# 常用选项# 	-r : 递归删除整个文件夹#		-f : 强制删除不提示
 

mv 指令
 1234# mv # 基本语法：# 	- 重命名：mv oldNameFile newNameFile# 	- 移动文件：mv 需要移动的文件 新目录
 

cat 指令
1234# cat# 基本语法：cat [选项] 要查看的文件# 常用选项： 	-n : 显示行号


more指令


less 指令


echo 指令


head 指令：默认显示文章前 10 行内容


tail 指令（可用于查看日志）：默认显示文章尾部 10 行内容


输出重定向 &gt; 、追加 &gt;&gt; 




ln 指令：类似 win 下的快捷方式




history 指令








时间日期类
date 指令
 
 

cal 指令
 


搜索查找类
find 指令


locate 指令

先执行    updatedb




which 指令




grep 指令
 


压缩解压类
gzip、gunzip 指令：用于解压缩文件



zip、unzip 指令：可压缩文件和目录
1234567# 小结# 不指定路径写法,压缩的和解压的文件都保存在当前用户所在的目录zip -r 要压缩的目录unzip 要解压的xxx.zip# 指定路径写法zip -r 指定目录/xxx.zip 要压缩的目录unzip -d 要解压到的目录 要解压的xxx.zip
123456# 如果要压缩 /home/TEST 目录下的东西，不包含home# 下面这样写的话会把home也压缩进去，包含了homezip -r 存放的目录/xxx.zip /home/TEST# 正确做法# 先进去到/home目录下，下面这样压缩就不会把home也压进去zip -r 存放的目录/xxx.zip TEST




当一个文件夹里面有文件的时候，压缩的时候要使用 zip -r xxx.zip 要压缩的文件夹
不使用 -r 就会只是压缩一个目录，里面的东西进不去



tar 指令



组管理和权限管理组
每一个用户必须属于一个组，不能独立于组外
每一个文件有三个概念
所有者：一般是创建者
所在组：这个文件属于哪一个组，那么这个组里面的用户就对这个文件拥有一定的权限
其他组：不包含该文件的组称为其他组，其他组也对该文件有一定的权限




文件/目录 所有者
查看文件的所有者


修改文件所有者
1chown 用户名 文件



组的创建
文件/目录 所在组
查看文件/目录所在的组：

12ls -ahlll

修改文件所在组：

1chgrp 组名 文件名

EX：修改文件所在组，目录同理


先创建一个组 game
然后使用 root 用户创建文件 SuperMary.txt
查看这个文件属于哪个组 -&gt; root
chgrp game SuperMary.txt


其他组除文件的所有者和所在组的用户外，系统的其他用户都是文件的其它组
改变用户所在组
查看用户所在组

1id 用户名


查看组

123cat /etc/group# 查看是否有mojiao这个组cat /etc/group | grep mojiao
没有组则没有输出


改变用户所在组

1234usermod -g 新组名 用户名# 改变该用户登录的初始目录。# 说明：用户需要有进入到新目录的权限usermod -d 目录名 用户名


权限的基本介绍123ls -lls -lahll

一共十位 
123# 分为四段l    rwx    rwx    rwx类型  所有者  所属组  其他组用户

各位数表示的意义


第 0 位：确定文件类型

l 是链接

d 是目录

c 是 字符设备 文件，如键盘、鼠标

b 是块设备，如硬盘




第 1~3 位确定所有者（该文件的所有者）拥有该文件的权限。—User

第 4~6 位确定所属组（同用户组的）拥有该文件的权限。—Group

第 7~9 位确定其他用户拥有该文件的权限。—Other



各字母表示的意义


r w x 作用到文件
[ r ] : 表示可读
[ w ] : 代表可写，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件的目录有写权限，才能删除该文件
[ x ] : 代表可执行，可以被执行


r w x 作用到目录
[ r ] : 表示可读
[ w ] : 代表可写，可以修改，对目录内 创建 + 删除 + 重命名目录
[ x ] : 代表可执行，可以进入该目录



修改权限
chmod u=rwx,g=rwx,o=x 文件名或目录名
chmod u+w 文件名/目录名
chmod a-w 文件名/目录名
1234567891011   - u：所有者   - g：所有组   - o：其他人   - a：所有人（u，g，o 的总和）2. 通过数字变更权限   &#96;&#96;&#96;shell   chmod 751 文件名&#x2F;目录名   # 上面一句表示将 所有者权限设置为 rwx，所在组设置为 rx，其他组设置为 x
12345678910r=4 w=2	x=1	000 —— 其实就是二进制rwx=7rw =6r x=5r  =4 wx=3 w =2  x=1





修改文件/目录所有者12345chown newowner 文件/目录 #改变所有者chown newowner:newgroup 文件/目录 #改变所有者和所在组# -R 如果是目录，则使其下所有子文件或目录递归生效chown -R newowner 文件/目录 #递归改变所有者chown -R newowner:newgroup 文件/目录 #递归改变所有者和所在组


修改文件/目录所在组12chgrp newgroup 文件/目录 #改变所在组 chgrp -R newgroup 文件/目录 #改变所在组 




定时任务调度crontab 任务调度
crontab 进行 定时任务的设置介绍


概述

任务调度：是指系统在某个时间执行的特定的命令或程序
任务调度分类：
系统工作：有些重要的工作必须周而复始的执行，如病毒扫描
个别用户工作：个别用户希望执行某些特定程序，比如对MySQL数据库的备份




基本语法：
123456crontab [选项]# 常用选项    -e #编辑crontab定时任务    -l #查询crontab任务    -r #删除当前用户所有的crontab任务service crond restart #重启任务调度






使用方法

直接用 crontab -e 编辑crontab定时任务,写执行的语句



先写 shell 脚本，然后在 crontab -e 编辑crontab定时任务
（假如我所在路径是 /home）
123456vim my.sh	# date &gt;&gt; /home/mycal	# cal &gt;&gt; /home/mycalchmod u+x my.shcrontab -e	# */1 * * * * /home/my.sh






at 定时任务
概述

at 命令是一次性定时计划任务，at 的守护进程 atd 会以后台模式运行，检查作业队列来运行

默认情况下，atd 进程每 60s 检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业

at 命令是一次性定时计划 任务，执行完一个任务后不再执行任务了

在使用 at 命令的时候，一定要保证 atd 进程的启动，可以使用相关指令查看
1ps -ef | grep atd




at 命令格式
12at [选项] [时间]ctrl + D #结束 at 命令的输入，按两次


应用


rpm
介绍
rpm 用于互联网下载包的打包及安装工具，它包含在某些 Linux 分发版中。它生成具有 .RPM 拓展名的文件。RPM 是 RedHat Package Manager（RedHat 软件包管理工具）的缩写，类似 Windows 下的 setup.exe。

查询指令
123456789101112rpm -qa #查询所安装的所有 rpm 软件包rpm -qa | morerpm -qa | grep X #如 rpm -qa | grep nginxrpm -q 软件包名 # 查询软件包是否安装rpm -qi 软件包名 # 查询软件包信息rpm -ql 软件包名 # 查询软件包中的文件rpm -qf 文件全路径名 # 查询文件所属的软件包	# rpm -qf /etc/passwd	# rpm -qf /root/install.log
卸载 rpm 包
123rpm -e RPM包的名称	# rpm -e nginx 表示删除 nginx 软件包rpm -e --nodeps RPM包的名称


安装 rpm 包
1234rpm -ivh RPM包全路径名称	# i = install 安装	# v = verbose 提示	# h = hash 	  进度条




yum
介绍
yum 是一个 shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务期自动下载 RPM 包并且安装，可以自动处理依赖关系，并且一次性安装所有依赖的软件包

基本指令
查询 yum 服务器是否有需要安装的软件
1yum list | grep XX软件列表
安装指定 yum 包
1yum install XXX






Linux分区分区


这里截取我虚拟机磁盘分区和服务器分区情况
虚拟机：分了三个区（根分区、boot分区、SWAP分区）
服务器：默认只有一个根分区
UUID：分区的唯一标识符（40bit）
MOUNTPOINT：挂载点



增加一块硬盘
虚拟机添加硬盘
​    

分区

格式化

挂载

设置可以自动挂载


磁盘情况
查询整个情况
1df -h


查询指定目录的磁盘占用情况
1234567du -h /目录	# 默认为当前目录	# -s 指定目录占用大小汇总	# -h 带计量单位	# -a 含文件	# --max-depth=1 子目录深度	# -c 列出明细的同时，增加汇总值




工作实用指令
统计 /etc/ 目录下文件个数
1234ls -l /etc/ | grep &quot;^-&quot; | wc -l# 直接列出来ls -l /etc/ | grep &quot;^-&quot; 
统计 /etc/ 目录下目录的个数
1234ls -l /etc/ | grep &quot;^d&quot; | wc -l#直接列出来ls -l /etc/ | grep &quot;^d&quot;
统计 /etc/ 目录下文件个数，包括子文件夹里的文件
1234ls -lR /etc/ | grep &quot;^-&quot; | wc -l# 直接列出来ls -lR /etc/ | grep &quot;^-&quot; 
统计 /etc/ 目录下目录的个数，包括子文件夹里的目录
1234ls -lR /etc/ | grep &quot;^d&quot; | wc -l#直接列出来ls -lR /etc/ | grep &quot;^d&quot;
以树状显示目录结构
123# 如没安装，先安装yum install treetree /etc/






网络配置定制篇</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/02/28/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E8%AF%BE%E7%A8%8B%E6%8E%A8%E8%8D%90-%E8%AE%A1%E7%A7%91/" title="大二下资料推荐-仅个人推荐">大二下资料推荐-仅个人推荐</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-28T12:30:33.000Z" title="发表于 2021-02-28 20:30:33">2021-02-28</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.929Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E4%B8%AA%E4%BA%BA/">个人</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E4%B8%AA%E4%BA%BA/">个人</a></span></div><div class="content">
仅仅个人推荐，具体看个人风格喜好
更新中……..


概率论与数理统计宋浩：链接点我
小元老师：链接点我
张宇：链接点我
汤家凤：
B站找不到了，百度网盘(/手动滑稽)


基础：

​    链接：https://pan.baidu.com/s/16N6dx9X3jiKVyieJ5j8G1g​    提取码：1502 

强化

​    链接：https://pan.baidu.com/s/1iuARPXy7AzHdrVROBg2bjQ​    提取码：1502 
链接点我

操作系统链接点我
链接点我
链接点我
链接点我

算法设计与分析
这个课内容连接性没那么强，可以单独搜课看，如动态规划DP、分治、贪心等都可以单独搜到

链接点我
这个课算法有点全，可以挑书上的内容看：链接点我
左神（左程云）的课比较进阶：链接点我

计算机组成原理
暂时还没

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/02/25/%E4%B8%80%E4%BA%9B%E8%AE%BE%E7%BD%AE/" title="一些设置">一些设置</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-25T04:45:00.000Z" title="发表于 2021-02-25 12:45:00">2021-02-25</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.922Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E8%AE%B0%E5%BD%95/">记录</a></span></div><div class="content">
状态栏显秒
打开注册表 regedit

找到路径
1计算机\HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced
新建 DWORD(32位)值(D) 并命名为
1ShowSecondsInSystemClock


然后修改值为 1 


然后重新打开 Windows资源管理器 生效



共享文件夹一些问题
在控制面板打开了网络共享功能

然后去 计算机管理 设置 guest 账户密码


然后在 win7 的 Administrator 账户下进去出现如下情况



刚开始以为是 Administrator 账户的原因，换了一个账户也是同样的情况


解决方法

Guest 的账户已禁用不打勾





</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/02/22/Topic%20LinkedList/" title="Topic-LinkedList">Topic-LinkedList</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-22T07:32:33.000Z" title="发表于 2021-02-22 15:32:33">2021-02-22</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.905Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E9%93%BE%E8%A1%A8/">链表</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/LeetCode/">LeetCode</a></span></div><div class="content">

面试时链表解题方法论

对于笔试：不用太在乎空间复杂度，一切为了时间复杂度
对于面试：时间复杂度依然放在第一位，但是一定要找到空间最省的方法

重要技巧

额外数据结构记录（哈希表、队列、栈等）
快慢指针



==LeetCode : 相交链表的一系列问题
    ==
Topic-相交链表的一系列问题
题目：给定一个可能有环也可能无环的单链表，头结点 head1 和 head2。实现一个函数，如果两个链表相交，请返回相交的第一个节点。如果不想交，返回 null
要求：如果两个链表长度之和为 N，时间复杂度达到 O(N)，额外空间复杂度达到O(1)

分析
相交的第一个节点是指都指向同一个节点（地址相同的节点）

由于单链表不确定是否有环，所以首先要做出判断

一共有3中可能

head1, head2    都无环

遍历链表求的尾节点和长度

比较尾节点是否相同，不同则不相交，相同继续下面

然后让长链表先走长度差值( |len1 - len2| )，然后两者一起走

之后两者相交的节点就是第一个相交的节点




head1, head2     中一个为环一个不为环
 没有这种可能

head1, head2    都有环，且入环节点为 loop1,loop2

如果 loop1 == loop2，那么将loop1和loop2看成尾节点，因为共用环环长度一样，回到第一种情况

如果 loop1 != loop2，如何区分第一三种

loop1 继续遍历一圈，看是否能遇到 loop2
没遇到则是第一种情况，返回 null
遇到则是第三者情况，返回 loop1 或 loop2。loop1 和 loop2 都是第一个相交节点











判断是否有环
要如何知道一个单链表有环并且进一步知道入环节点？

可用快慢指针确定单链表是否有环

slow慢指针，fast快指针，都让它们指向单链表 head

快指针一次走两步，慢指针一次走一步

如果有环的情况下，快指针会先进入环，但此时不知道哪个是入环节点
 如果无环快指针会有指向 null 的情况

如有环，慢指针后来进入环，然后快慢指针都在环中。所以他们两个必定会相遇

并且慢指针最多走  N(环的节点数) - 1 步(&lt;1圈) 就可与快指针相遇
快指针最多走小于两圈即可相遇


相遇则表示该单链表是有环



那么如何找到入环节点

在上面 快慢指针在环中的某个地方相遇，然后将快指针指向 head，然后快慢指针每次都只走一步，下一个相遇的节点就是入环节点
证明：

先看下快慢指针的追赶
 

 此时以 fast 为原点，向右为正，设 slow 走了 k 步相遇，初始 fast slow 相距 n 个节点（不包括本身）
 追上只需要满足 2k + n + 1 = k 
 k = n + 1 (也就是快慢指针的间距数)
 所以追上的步数 = 相距数

未完待续



code

123456789101112131415161718192021// 判断单链表是否有环，有返回入环节点，无返回 nullstatic ListNode getLoopNode(ListNode head) &#123;    if (head == null || head.next == null || head.next.next == null) return null;    ListNode fast = head.next.next;    ListNode slow = head.next;    while (fast != slow) &#123;  // 相遇跳出        // 遍历到末尾都还不相遇        if (fast.next == null || fast.next.next == null) &#123;            return null;        &#125;        fast = fast.next.next;        slow = slow.next;    &#125;    fast = head;    // 快指针重新指向头结点    // 都走一步 相遇的节点即为入环节点    while (fast != slow) &#123;        fast = fast.next;        slow = slow.next;    &#125;    return fast;&#125;


Code
都无环
123456789101112131415161718192021222324252627282930313233// 都无环情况static ListNode noLoop(ListNode head1, ListNode head2) &#123;    ListNode cur1 = head1;    ListNode cur2 = head2;    int len = 0;    while (cur1.next != null) &#123;        len++;        cur1 = cur1.next;    &#125;    while (cur2.next != null) &#123;        len--;        cur2 = cur2.next;    &#125;    // 不相交    if (cur1 != cur2) &#123;        return null;    &#125;    // 相交    // cur1 指向长链表   cur2 指向短链表    cur1 = len &gt; 0 ? head1 : head2;    cur2 = cur1 == head1 ? head2 : head1;    len = Math.abs(len);    while (len-- != 0) &#123;        cur1 = cur1.next;    &#125;      while (cur1 != cur2) &#123;        cur1 = cur1.next;        cur2 = cur2.next;    &#125;    return cur1;&#125;  


都有环
 123456789101112131415161718192021222324252627282930313233343536373839// 都有环static ListNode bothLoop(ListNode head1, ListNode loop1, ListNode head2, ListNode loop2) &#123;    // 相交并且相交点不在环上    if (loop1 == loop2) &#123;        ListNode cur1 = head1;        ListNode cur2 = head2;        int len = 0;        while (cur1 != loop1) &#123;            len++;            cur1 = cur1.next;        &#125;        while (cur2 != loop2) &#123;            len--;            cur2 = cur2.next;        &#125;        cur1 = len &gt; 0 ? head1 : head2;        cur2 = cur1 == head1 ? head2 : head1;        len = Math.abs(len);        while (len-- != 0) &#123;            cur1 = cur1.next;        &#125;        while (cur1 != cur2) &#123;            cur1 = cur1.next;            cur2 = cur2.next;        &#125;        return cur1;    &#125; else &#123;   // 相交且在环上 或 不相交        ListNode tmp = loop1.next;        while (tmp != loop1) &#123;            if (tmp == loop2) &#123; // 相交且在环上                return loop1;            &#125;            tmp = tmp.next;        &#125;        // 不相交        return null;    &#125;&#125;	
最后合并
 123456789101112131415161718// 一起处理三种情况static ListNode getIntersectionNode(ListNode head1, ListNode head2) &#123;    if (head1 == null || head2 == null) &#123;        return null;    &#125;    ListNode loop1 = getLoopNode(head1);    ListNode loop2 = getLoopNode(head2);    // 都无环    if (loop1 == null &amp;&amp; loop2 == null) &#123;        return noLoop(head1, head2);    &#125;    // 都有环    if (loop1 != null &amp;&amp; loop2 != null) &#123;        return bothLoop(head1, loop1, head2, loop2);    &#125;    // 只有一个无环或有环    return null;&#125;




测试Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167package LinkedList;/** * @ Author: minghuifan * @ Date: 2021/3/2 - 16:13 * @ Description: LinkedList * @ Version: 1.0 */public class intersectLinkedList_相交链表 &#123;    static class ListNode &#123;        int val;        ListNode next;        ListNode() &#123;        &#125;        ListNode(int val) &#123;            this.val = val;        &#125;        ListNode(int val, ListNode next) &#123;            this.val = val;            this.next = next;        &#125;    &#125;    // 判断单链表是否有环，有返回入环节点，无返回 null    static ListNode getLoopNode(ListNode head) &#123;        if (head == null || head.next == null || head.next.next == null) return null;        ListNode fast = head.next.next;        ListNode slow = head.next;        while (fast != slow) &#123;  // 相遇跳出            // 遍历到末尾都还不相遇            if (fast.next == null || fast.next.next == null) &#123;                return null;            &#125;            fast = fast.next.next;            slow = slow.next;        &#125;        fast = head;    // 快指针重新指向头结点        // 都走一步 相遇的节点即为入环节点        while (fast != slow) &#123;            fast = fast.next;            slow = slow.next;        &#125;        return fast;    &#125;    // 都无环情况    static ListNode noLoop(ListNode head1, ListNode head2) &#123;        ListNode cur1 = head1;        ListNode cur2 = head2;        int len = 0;        while (cur1.next != null) &#123;            len++;            cur1 = cur1.next;        &#125;        while (cur2.next != null) &#123;            len--;            cur2 = cur2.next;        &#125;        // 不相交        if (cur1 != cur2) &#123;            return null;        &#125;        // 相交        // cur1 指向长链表   cur2 指向短链表        cur1 = len &gt; 0 ? head1 : head2;        cur2 = cur1 == head1 ? head2 : head1;        len = Math.abs(len);        while (len-- != 0) &#123;            cur1 = cur1.next;        &#125;        while (cur1 != cur2) &#123;            cur1 = cur1.next;            cur2 = cur2.next;        &#125;        return cur1;    &#125;    // 都有环    static ListNode bothLoop(ListNode head1, ListNode loop1, ListNode head2, ListNode loop2) &#123;        // 相交并且相交点不在环上        if (loop1 == loop2) &#123;            ListNode cur1 = head1;            ListNode cur2 = head2;            int len = 0;            while (cur1 != loop1) &#123;                len++;                cur1 = cur1.next;            &#125;            while (cur2 != loop2) &#123;                len--;                cur2 = cur2.next;            &#125;            cur1 = len &gt; 0 ? head1 : head2;            cur2 = cur1 == head1 ? head2 : head1;            len = Math.abs(len);            while (len-- != 0) &#123;                cur1 = cur1.next;            &#125;            while (cur1 != cur2) &#123;                cur1 = cur1.next;                cur2 = cur2.next;            &#125;            return cur1;        &#125; else &#123;   // 相交且在环上 或 不相交            ListNode tmp = loop1.next;            while (tmp != loop1) &#123;                if (tmp == loop2) &#123; // 相交且在环上                    return loop1;                &#125;                tmp = tmp.next;            &#125;            // 不相交            return null;        &#125;    &#125;    // 一起处理三种情况    static ListNode getIntersectionNode(ListNode head1, ListNode head2) &#123;        if (head1 == null || head2 == null) &#123;            return null;        &#125;        ListNode loop1 = getLoopNode(head1);        ListNode loop2 = getLoopNode(head2);        // 都无环        if (loop1 == null &amp;&amp; loop2 == null) &#123;            return noLoop(head1, head2);        &#125;        // 都有环        if (loop1 != null &amp;&amp; loop2 != null) &#123;            return bothLoop(head1, loop1, head2, loop2);        &#125;        // 只有一个无环或有环        return null;    &#125;    public static void main(String[] args) &#123;        ListNode head1 = null;        head1 = new ListNode(1);        head1.next = new ListNode(2);        head1.next.next = new ListNode(3);        head1.next.next.next = new ListNode(4);        head1.next.next.next.next = new ListNode(5);        head1.next.next.next.next.next = new ListNode(6);//        head1.next.next.next.next.next.next = new ListNode(7);        head1.next.next.next.next.next.next = head1.next.next.next;        ListNode head2 = null;        head2 = new ListNode(1);        head2.next = new ListNode(2);        head2.next.next = new ListNode(3);        head2.next.next.next = head1.next;//        head2.next.next.next = new ListNode(4);//        head2.next.next.next.next = new ListNode(5);//        head2.next.next.next.next.next = new ListNode(6);//        head2.next.next.next.next.next.next = new ListNode(7);        System.out.println(getIntersectionNode(head1, head2).val);    &#125;&#125;


相关题目
160. 相交链表






142. 环形链表 II






面试题 02.07. 链表相交
 

 





==LeetCode:判断一个链表是否为回文结构
    ==
Topic-判断一个链表是否为回文结构题目：给定一个单链表头结点 head，请判断该链表是否为回文结构
例子：1-&gt;2-&gt;1，返回true；1-&gt;2-&gt;2-&gt;1，返回true；1-&gt;2-&gt;3，返回false。
要求：如果链表长度为N，时间复杂度达到 O(N)，额外空间复杂度达到 O(1)
分析：三种常见方法
压入栈中，然后遍历同时弹栈，看节点内容是否想等
  

和第一种一样不过只让链表后半部分压栈，然后遍历比对
  

第三种：  step1：先用快慢指针（slow、fast）找到中点（偶数为对称轴前一个，奇数即为中点）
  step2：然后将后面的链表反转：
  ​            1）偶数时：1 -&gt; 2 -&gt; 3 &lt;- 4 &lt;- 5 &lt;- 6  ​            2）奇数时：1 -&gt; 2 -&gt; 3 -&gt; 4 &lt;- 5 &lt;- 6 &lt;- 7  step3：然后分别遍历左右链表比对即可得出结果  step4：别忘了将链表复原
  


法一：链表全部压栈1234567891011121314// 把整个链表压栈，然后遍历链表和弹栈结果是否一致public static boolean isPalindrome1(ListNode head) &#123;    if (head == null || head.next == null) return true;    Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();    ListNode tmp = head;    while (tmp != null) &#123;        stack.push(tmp);        tmp = tmp.next;    &#125;    while (head != null &amp;&amp; stack.pop().val == head.val) &#123;        head = head.next;    &#125;    return head == null ? true : false;&#125;


法二：一半压栈如何找到中点：快慢指针 /slow/fast，条件如何取。有三种常见初始状态（但至少要两个节点）

slow = fast = head：都指向头结点
slow = head; fast = head.next; ：慢指向头结点，快指向第二节点
slow = head.next; fast = head; ：慢指向第二节点，快指向头结点


然后依次讨论判断的条件是 ==fast.next!= null &amp;&amp; fast.next.next != null==

12345678910111213141516171819202122232425slow = fast = head; 时EX1: 1 2	开始都指向第 1明显 fast 一步都不能动指向对称轴前一个EX2: 1 2 3 4	由判断条件得出fast可以走1步，那么slow指向2指向对称轴前一个EX3: 1 2 3 4 5 6fast可走2步，slow指向3对称轴前一个EX4: 1 2 3fast可以走1步，slow指向2指向中点位置 EX5: 1 2 3 4 5fast可以走2步，slow指向3指向中点位置EX6: 1 2 3 4 5 6 7fast可走3步，slow指向4指向中点位置
12345678910111213141516171819202122232425slow = head; fast = head.next; 时EX1:链表：1 2	slow指向1，fast指向2明显 fast 一步都不能动然后此时指向对称轴前一个EX2:链表：1 2 3 4	由判断条件得出fast可以走1步，那么slow指向2也是指向对称轴前一个EX3: 1 2 3 4 5 6fast可走2步，slow指向3对称轴前一个EX4:链表：1 2 3fast可以走0步，slow指向1指向中点前一个位置 EX5:链表：1 2 3 4 5fast可以走1步，slow指向2指向中点前一个位置EX6: 1 2 3 4 5 6 7fast可走2步，slow指向3指向中点位置前一个位置
12345678910111213141516171819202122232425slow = head.next; fast = head; 时 EX1:链表：1 2	slow指向2，fast指向1明显 fast 一步都不能动然后此时指向对称轴后一个EX2:链表：1 2 3 4	由判断条件得出fast可以走1步，那么slow指向3也是指向对称轴后一个EX3: 1 2 3 4 5 6fast可走2步，slow指向3对称轴后一个EX4:链表：1 2 3fast可以走1步，slow指向3指向中点后一个位置 EX5:链表：1 2 3 4 5fast可以走2步，slow指向4指向中点后一个位置EX6: 1 2 3 4 5 6 7fast可走3步，slow指向5指向中点后一个位置

最后得出结论：判断条件是 ==fast.next!= null &amp;&amp; fast.next.next != null==

slow = fast = head;
偶数：对称轴前一个
奇数：中点

slow = head; fast = head.next;
偶数：对称轴前一个
奇数：中点前一个

slow = head.next; fast = head; 
偶数：对称轴后一个
奇数：中点后一个



123456789101112131415161718192021222324// 很容易得出，我们需要后一半压栈所以选择第三种快慢指针方案    public static boolean isPalindrome2(ListNode head) &#123;        if (head == null || head.next == null) return true;        ListNode slow = head.next;        ListNode fast = head;        while (fast.next != null &amp;&amp; fast.next.next != null) &#123;            fast = fast.next.next;            slow = slow.next;        &#125;        // 此时slow指向中点或者对称轴的下一个        Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();        while (slow != null) &#123;            stack.push(slow);            System.out.print(slow.val + &quot;_&quot;);            slow = slow.next;        &#125;        while (!stack.isEmpty()) &#123;            if (head.val != stack.pop().val) &#123;                return false;            &#125;            head = head.next;        &#125;        return true;    &#125;


法三：这里需要用到反转链表的模板，模板如下
123456789101112// 加入 head 为链表的头结点	ListNode pre = head;		// 即指向头结点	ListNode last = head.next;	// 即指向头结点下一个	ListNode tmp = null;	pre.next = null;	while (last != null) &#123;        tmp = last.next;        last.next = pre;        pre = last;        last = tmp;    &#125;// 最后循环完后的结果是 pre 指向反转的首节点，last、tmp 指向 null
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455    // 用偶数个举例，如链表为 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6    public static boolean isPalindrome3(ListNode head) &#123;        if (head == null || head.next == null) return true;        // step1：找到中点位置，偶数为对称轴前一个，奇数为中点        ListNode slow = head;        ListNode fast = head;        while (fast.next != null &amp;&amp; fast.next.next != null) &#123;            fast = fast.next.next;            slow = slow.next;        &#125;        // step2：反转后半部分链表        // 此时 slow 指向中点或者对称轴的前一个，也就是相当于反转部分的头结点        // 即 slow 指向 3，接下来要反转后面部分得到：1 -&gt; 2 -&gt; 3 &lt;- 4 &lt;- 5 &lt;- 6        fast = slow.next;        ListNode tmp = null;        slow.next = null;        while (fast != null) &#123;            tmp = fast.next;            fast.next = slow;            slow = fast;            fast = tmp;        &#125;        tmp = slow; // 指向最后一个节点（或者后部分链表的头结点）这里后面会用到        // step3：将两边链表分别遍历比对        // 此时slow指向反转链表的首节点，也就是原链表的最后一个        // 1 -&gt; 2 -&gt; 3 &lt;- 4 &lt;- 5 &lt;- 6 slow 指向 6        // 然后我们依次遍历两边的链表        fast = head;        boolean ans = true;        while (fast != null &amp;&amp; slow != null) &#123;//            System.out.print(&quot;fast:&quot; + fast.val + &quot;,slow:&quot; + slow.val + &quot;\n&quot;);            if (fast.val != slow.val) &#123;                ans = false;                break;            &#125;            fast = fast.next;            slow = slow.next;        &#125;        // step4：链表复原        // 此时 slow 指向 3，fast 指向 null        // 如果是奇数个 slow、fast 都指向 null，所以要重新赋值        slow = tmp;        fast = slow.next;        while (fast != null) &#123;            tmp = fast.next;            fast.next = slow;            slow = fast;            fast = tmp;        &#125;        return ans;    &#125;




测试 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193package LinkedList;import java.util.Stack;/** * @ Date: 2021/2/10 - 13:19 * @ Description: LinkedList * @ Version: 1.0 */// https://leetcode-cn.com/problems/palindrome-linked-list-lcci/public class isPalindromeLinkedList_回文链表 &#123;    static class ListNode &#123;        int val;        ListNode next;        ListNode(int x) &#123;            val = x;        &#125;    &#125;    static void printLinkedList(ListNode head) &#123;        System.out.print(&quot;Linked List: &quot;);        while (head != null) &#123;            System.out.print(head.val + &quot; &quot;);            head = head.next;        &#125;        System.out.println();    &#125;    // 把整个链表压栈，然后遍历链表和弹栈结果是否一致    public static boolean isPalindrome1(ListNode head) &#123;        if (head == null || head.next == null) return true;        Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();        ListNode tmp = head;        while (tmp != null) &#123;            stack.push(tmp);            tmp = tmp.next;        &#125;        while (head != null &amp;&amp; stack.pop().val == head.val) &#123;            head = head.next;        &#125;        return head == null ? true : false;    &#125;    // 半个链表压栈    public static boolean isPalindrome2(ListNode head) &#123;        if (head == null || head.next == null) return true;        ListNode slow = head.next;        ListNode fast = head;        while (fast.next != null &amp;&amp; fast.next.next != null) &#123;            fast = fast.next.next;            slow = slow.next;        &#125;        // 此时slow指向中点或者对称轴的下一个        Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();        while (slow != null) &#123;            stack.push(slow);//            System.out.print(slow.val + &quot;_&quot;);            slow = slow.next;        &#125;        while (!stack.isEmpty()) &#123;            if (head.val != stack.pop().val) &#123;                return false;            &#125;            head = head.next;        &#125;        return true;    &#125;    // 用偶数个举例，如链表为 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6    public static boolean isPalindrome3(ListNode head) &#123;        if (head == null || head.next == null) return true;        // step1：找到中点位置，偶数为对称轴前一个，奇数为中点        ListNode slow = head;        ListNode fast = head;        while (fast.next != null &amp;&amp; fast.next.next != null) &#123;            fast = fast.next.next;            slow = slow.next;        &#125;        // step2：反转后半部分链表        // 此时 slow 指向中点或者对称轴的前一个，也就是相当于反转部分的头结点        // 即 slow 指向 3，接下来要反转后面部分得到：1 -&gt; 2 -&gt; 3 &lt;- 4 &lt;- 5 &lt;- 6        fast = slow.next;        ListNode tmp = null;        slow.next = null;        while (fast != null) &#123;            tmp = fast.next;            fast.next = slow;            slow = fast;            fast = tmp;        &#125;        tmp = slow; // 指向最后一个节点（或者后部分链表的头结点）这里后面会用到        // step3：将两边链表分别遍历比对        // 此时slow指向反转链表的首节点，也就是原链表的最后一个        // 1 -&gt; 2 -&gt; 3 &lt;- 4 &lt;- 5 &lt;- 6 slow 指向 6        // 然后我们依次遍历两边的链表        fast = head;        boolean ans = true;        while (fast != null &amp;&amp; slow != null) &#123;//            System.out.print(&quot;fast:&quot; + fast.val + &quot;,slow:&quot; + slow.val + &quot;\n&quot;);            if (fast.val != slow.val) &#123;                ans = false;                break;            &#125;            fast = fast.next;            slow = slow.next;        &#125;        // step4：链表复原        // 此时 slow 指向 3，fast 指向 null        // 如果是奇数个 slow、fast 都指向 null，所以要重新赋值        slow = tmp;        fast = slow.next;        while (fast != null) &#123;            tmp = fast.next;            fast.next = slow;            slow = fast;            fast = tmp;        &#125;        return ans;    &#125;    public static void main(String[] args) &#123;        ListNode head = null;        printLinkedList(head);        System.out.print(isPalindrome1(head) + &quot; | &quot;);        System.out.print(isPalindrome2(head) + &quot; | &quot;);        System.out.println(isPalindrome3(head));        head = new ListNode(1);        head.next = new ListNode(2);        printLinkedList(head);        System.out.print(isPalindrome1(head) + &quot; | &quot;);        System.out.print(isPalindrome2(head) + &quot; | &quot;);        System.out.println(isPalindrome3(head));        head = new ListNode(1);        head.next = new ListNode(2);        head.next.next = new ListNode(1);        printLinkedList(head);        System.out.print(isPalindrome1(head) + &quot; | &quot;);        System.out.print(isPalindrome2(head) + &quot; | &quot;);        System.out.println(isPalindrome3(head));        head = new ListNode(1);        head.next = new ListNode(2);        head.next.next = new ListNode(3);        head.next.next.next = new ListNode(4);        printLinkedList(head);        System.out.print(isPalindrome1(head) + &quot; | &quot;);        System.out.print(isPalindrome2(head) + &quot; | &quot;);        System.out.println(isPalindrome3(head));        head = new ListNode(1);        head.next = new ListNode(2);        head.next.next = new ListNode(3);        head.next.next.next = new ListNode(2);        head.next.next.next.next = new ListNode(3);        printLinkedList(head);        System.out.print(isPalindrome1(head) + &quot; | &quot;);        System.out.print(isPalindrome2(head) + &quot; | &quot;);        System.out.println(isPalindrome3(head));        head = new ListNode(1);        head.next = new ListNode(2);        head.next.next = new ListNode(3);        head.next.next.next = new ListNode(4);        head.next.next.next.next = new ListNode(3);        head.next.next.next.next.next = new ListNode(2);        head.next.next.next.next.next.next = new ListNode(1);        printLinkedList(head);        System.out.print(isPalindrome1(head) + &quot; | &quot;);        System.out.print(isPalindrome2(head) + &quot; | &quot;);        System.out.println(isPalindrome3(head));    &#125;&#125;// OutputLinked List: true | true | trueLinked List: 1 2 false | false | falseLinked List: 1 2 1 true | true | trueLinked List: 1 2 3 4 false | false | falseLinked List: 1 2 3 2 3 false | false | falseLinked List: 1 2 3 4 3 2 1 true | true | true
==LeetCode : 86.分隔链表
    ==
Topic-86.分隔链表链接：分隔链表

12345678910/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */


分析
创建4个变量
sH/sT：指向小于给出节点的第一个/指向最后一个bH/bT：指向非小于给出节点的第一个/指向最后一个

code
12345678910111213141516171819202122232425262728293031323334353637383940static ListNode partition(ListNode head, int x) &#123;    if (head == null || head.next == null) return head;    ListNode sH = null;     // 指向小于的头    ListNode sT = null;     // 指向小于的尾    ListNode bH = null;     // 指向等于大于的头    ListNode bT = null;     // 指向等于大于的尾    // 为了每一步的尾指针的next都指向null，为后续方便    ListNode next = null;    while (head != null) &#123;        next = head.next;        head.next = null;        if (head.val &lt; x) &#123;            if (sT == null) &#123;                sH = head;                sT = head;            &#125; else &#123;                sT.next = head;                sT = head;            &#125;        &#125; else &#123;            if (bT == null) &#123;                bH = head;                bT = head;            &#125; else &#123;                bT.next = head;                bT = head;            &#125;        &#125;        head = next;    &#125;    // 此时 sT 和 bT 两者中至少有一个不为空,因此有3种情况    // 10   11   01    if (sT == null) &#123;        return bH;    &#125; else &#123;        sT.next = bH;        return sH;    &#125;&#125;



题目进阶上面的 LeetCode 的题目等于和大于是归为一边的
进阶：将 小于 等于 大于 分别归为三段处理
分析
还是和刚刚一样的思路
创建六个变量
sH/sT：指向小于给出节点的第一个/指向最后一个eH/eT：指向等于给出节点的第一个/指向最后一个bH/bT：指向大于于给出节点的第一个/指向最后一个

code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374    static ListNode partitionAdvanced(ListNode head, int x) &#123;        ListNode sH = null;     // 指向小于的头        ListNode sT = null;     // 指向小于的尾        ListNode eH = null;     // 指向等于的头        ListNode eT = null;     // 指向等于的尾        ListNode bH = null;     // 指向大于的头        ListNode bT = null;     // 指向大于的尾        // 保证每次的sT、eT、bT的next都指向null，为了后续方便        ListNode next = null;        while (head != null) &#123;            next = head.next;            head.next = null;            if (head.val &lt; x) &#123;                if (sH == null) &#123;                    sH = head;                    sT = head;                &#125; else &#123;                    sT.next = head;                    sT = head;                &#125;            &#125; else if (head.val == x) &#123;                if (eH == null) &#123;                    eH = head;                    eT = head;                &#125; else &#123;                    eT.next = head;                    eT = head;                &#125;            &#125; else &#123;                if (bH == null) &#123;                    bH = head;                    bT = head;                &#125; else &#123;                    bT.next = head;                    bT = head;                &#125;            &#125;            head = next;        &#125;        // 一共8种情况        // 000  100        // 001  101        // 010  110        // 011  111        if (sT == null) &#123;            if (eT == null) &#123;                return bH;            &#125; else &#123;                eT.next = bH;                return eH;            &#125;        &#125; else &#123;            if (eT == null) &#123;                sT.next = bH;                return sH;            &#125; else &#123;                sT.next = eH;                eT.next = bH;                return sH;            &#125;        &#125;//        if (sT != null) &#123;   // 小于部分不为空//            sT.next = eH;//            // 如果 eT 为空指向小于头，不为空不处理//            eT = eT == null ? sT : eT;//        &#125;//        if (eT != null) &#123;   // 等于部分不为空//            eT.next = bH;//        &#125;//        return sH != null ? sH : eH != null ? eH : bH;    &#125;


测试 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191package LinkedList;/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */// https://leetcode-cn.com/problems/partition-list/public class partitionList_分隔链表 &#123;    static class ListNode &#123;        int val;        ListNode next;        ListNode() &#123;        &#125;        ListNode(int val) &#123;            this.val = val;        &#125;        ListNode(int val, ListNode next) &#123;            this.val = val;            this.next = next;        &#125;    &#125;    static void printLinkedList(ListNode head) &#123;        System.out.print(&quot;Linked List: &quot;);        while (head != null) &#123;            System.out.print(head.val + &quot; &quot;);            head = head.next;        &#125;        System.out.println();    &#125;    static ListNode partition(ListNode head, int x) &#123;        if (head == null || head.next == null) return head;        ListNode sH = null;     // 指向小于的头        ListNode sT = null;     // 指向小于的尾        ListNode bH = null;     // 指向等于大于的头        ListNode bT = null;     // 指向等于大于的尾        // 为了每一步的尾指针的next都指向null，为后续方便        ListNode next = null;        while (head != null) &#123;            next = head.next;            head.next = null;            if (head.val &lt; x) &#123;                if (sT == null) &#123;                    sH = head;                    sT = head;                &#125; else &#123;                    sT.next = head;                    sT = head;                &#125;            &#125; else &#123;                if (bT == null) &#123;                    bH = head;                    bT = head;                &#125; else &#123;                    bT.next = head;                    bT = head;                &#125;            &#125;            head = next;        &#125;        // 此时 sT 和 bT 两者中至少有一个不为空,因此有3种情况        // 10   11   01        if (sT == null) &#123;            return bH;        &#125; else &#123;            sT.next = bH;            return sH;        &#125;    &#125;    static ListNode partitionAdvanced(ListNode head, int x) &#123;        ListNode sH = null;     // 指向小于的头        ListNode sT = null;     // 指向小于的尾        ListNode eH = null;     // 指向等于的头        ListNode eT = null;     // 指向等于的尾        ListNode bH = null;     // 指向大于的头        ListNode bT = null;     // 指向大于的尾        // 保证每次的sT、eT、bT的next都指向null，为了后续方便        ListNode next = null;        while (head != null) &#123;            next = head.next;            head.next = null;            if (head.val &lt; x) &#123;                if (sH == null) &#123;                    sH = head;                    sT = head;                &#125; else &#123;                    sT.next = head;                    sT = head;                &#125;            &#125; else if (head.val == x) &#123;                if (eH == null) &#123;                    eH = head;                    eT = head;                &#125; else &#123;                    eT.next = head;                    eT = head;                &#125;            &#125; else &#123;                if (bH == null) &#123;                    bH = head;                    bT = head;                &#125; else &#123;                    bT.next = head;                    bT = head;                &#125;            &#125;            head = next;        &#125;        // 一共8种情况        // 000  100        // 001  101        // 010  110        // 011  111        if (sT == null) &#123;            if (eT == null) &#123;                return bH;            &#125; else &#123;                eT.next = bH;                return eH;            &#125;        &#125; else &#123;            if (eT == null) &#123;                sT.next = bH;                return sH;            &#125; else &#123;                sT.next = eH;                eT.next = bH;                return sH;            &#125;        &#125;//        if (sT != null) &#123;   // 小于部分不为空//            sT.next = eH;//            // 如果 eT 为空指向小于头，不为空不处理//            eT = eT == null ? sT : eT;//        &#125;//        if (eT != null) &#123;   // 等于部分不为空//            eT.next = bH;//        &#125;//        return sH != null ? sH : eH != null ? eH : bH;    &#125;    public static void main(String[] args) &#123;        ListNode head = null;        head = new ListNode(4);        head.next = new ListNode(2);        head.next.next = new ListNode(3);        head.next.next.next = new ListNode(1);        printLinkedList(head);        printLinkedList(partition(head, 2));//        printLinkedList(partitionAdvanced(head, 2));        head = new ListNode(3);        head.next = new ListNode(2);        head.next.next = new ListNode(6);        head.next.next.next = new ListNode(1);        head.next.next.next.next = new ListNode(4);        printLinkedList(head);        printLinkedList(partition(head, 3));//        printLinkedList(partitionAdvanced(head, 3));        head = new ListNode(1);        head.next = new ListNode(2);        head.next.next = new ListNode(3);        head.next.next.next = new ListNode(4);        head.next.next.next.next = new ListNode(3);        head.next.next.next.next.next = new ListNode(2);        head.next.next.next.next.next.next = new ListNode(1);        printLinkedList(head);        printLinkedList(partition(head, 3));//        printLinkedList(partitionAdvanced(head, 3));    &#125;&#125;
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/02/18/%E9%93%BE%E8%A1%A8%E4%B8%8E%E6%8C%87%E9%92%88/" title="链表与指针">链表与指针</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-18T11:28:10.000Z" title="发表于 2021-02-18 19:28:10">2021-02-18</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.964Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AF%AD%E6%B3%95/">语法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/java/">java</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/C/">C++</a></span></div><div class="content">
  9c18114bfffb75bea463c3ab069bee10dfdcf4a9d9459329fda899a5ff7d49dbb8026dd1d2250752d0ce92477b48ea1dbbbdaabf01a5d03f3f28b4d408a3386f279eb9d3716e850035c574de331ae89568a5e5dab38c8bd144f6ea29d159cbc83b56614111224c4aef867f260dd98513089a7f97a5c7d0860db906951ae522530aa2e3ec89209ea8fbf2a6b73146284ca26e7412f941e1b96710aca0bc8c4c0548583db677f4acfeb87eda336b8ec242bb70843445e0b5a40aa66ed59861e4288c3d9e546717995cfd05eefdb98c92d8b80a724af2ce89bdca55038cf421640eb5f02137bb590d5f7127f285ef410531619a253d6e3260b4ef8f7f40b5f6bcdd69d364f00d37abc5a6c07091790e8ca5c4df4ec3c4f26f55e66f53e2c85bc9602795f342033f16c87d3e1e2109b11644b57bf38616ee9695fa0a13a8fe4894cc3675b455d882be62455d85ff8d8cccfce01facc79529a5a80fba10f735da551089ab54f0f55222c9fdda5fe76b9d10dc8d88fea7b9fec438098aa0c4f8fefe152c8f00efbfba437708df512e23f9bc12a3cb70db70c497b8f9225beb2dbdbe9efe4bf19555be7db412287fb7f5345d3e469fd44419e8ddaee7944e66b1fd371fe1b36330e023e6ed0ee9d3a16230bdc7b273d20fefd33e93ed1798ab323918c63d05727bbd5fce8efe7ca022bf2cdfe203112906431539728a081d28709505e9e0250ee53c4e3943b8e304543786b1eb4b1bcae60021426e9878187122e76c46605b6eb437a0228bc07bd54cb0157ed09a4bf002444421480a404831d03f4be5c6f97e012f62c40f256bfba6ae2f061f3ba75955b84401d71827977314951042417999e0268e64aad661fda36d6e5cbffb96425be42105bfa38323df8f6c29f45dc453386c3b0053625bf4cde57c69c4c7c99ed10ca78250479d7f780f61928a5a04b57cfbc5c041ba92bab8a2bbbc2dde7e1037ad2d87088fe4543fdae61402d8cc70a5fb5be029f77ca506a2301f63645e9667b836623cca70693ca53b9c86dc61c065c10bae956f7d968df263002b31fed3358146be50cdd9ba75d63de6a60f7ad41bf29cf64cf7f9108b776c368859be86ce1537e635c15a90530d8a24eac5d2770879a9435409ba59cd0fea505a018cb93e62b9fa666e924d69f5c9f64075dae2da39b46cec3ec16ffadf44bc40509c2eef6cc5ea433a937bed1a7eb49bc5b635a58befbb97954fa9eacb97077579c43038a46b8484f4b5e87b308cd39977ce7cfc794444121c810f0f9e5468208efb10457573ca7b8a67977491e622f9a19337da1b69d188ed723567053d8c18bc8fc8c6e3d3180d2bb6a43939000185974e6955cfba5a0ca5a26df3c8655569e0a6f04a8462ed4e81827d0cc0d8057d22570130152cfb88d72d66fb792cf15187dd68ba88ff26c7b7fb00624750fe7bf8de1462dcd331f6cabffa99c83a1a0bf027d4e365afcb34a1f09283afb3934cc77bf437654c16810a7d3b3c1da077e0e22c99d817912c3a6c9d27452904298b7154f43399bf3c9da2c0b09d0e4b8e59055b1911643045fa96601f4cf5944d64224928cb7b5b6781eb43bb6f1f0f289920c5a596c0e063c3f7e766dcf226bff9512dc9777814cbc124e67d103ae91bd41f4905f7b829722187c2f938c2b800fa24d10bf350f67d3e2a367e87a793b9e77406ed8ab0ec7d611045804a94ec36bb6949539a530374553d0b1180e1fb86131936790829c496c6e7d54bb2529be3f8676ac5bae1c079ac193f4fe40230efff7671d7eebe6bc67cb2f5bb7ce2df0445607c3078eeb5b688de50d13f5d61913621167058fee9a1e3bd0a453f51d3e9fcd2e0fd8b5c5944a031702e8e45d1ec001000df867eb7a64deb25de380ce3d1294e7bb864c7c38d67e37f05a8dfa44da0b75392d79b62b29cbbe0f9c91248d5db5cdf991871d434067179624fd4bc90d8e7d7b396de26029e627b88133e390f49ed5b9517933828263a1dd9dbcf1aca4161d335ef26d65757c00a0b47fce2e026da70054df70352acd88e94b6f10bed250f8189eebdc72fe90606e8c61830f164d18b2b0b4e4b9e0a1b4342a3d56e680782130d0066e6e93bd3cf1b5614b83c53470a6d511ea1c0557fe9017bb5244952024eb84f333d7ba352c23e4b15168de13ad381b74501404c33ac38a11b70ac034285f757115b3eb4a5dcdf14925790d0adbabe20eb69f028e44d60485c15a15777dcc6158e3354955f00ce790769d02e39e902a1012ec40e11658e22070966c8127a90e02e8a1672afe629acbaa4a7a833a1e2afc81acbbf86f36f1edbfa55d492c7c38a4f7c1c9dda110dbf615d8eac97c613f6ba6c48e5f1473edb8ab5e980ba23303ebfe2702c6976f44d499e716584c9e4073604471cace163ed994f6915460eb9482092abde2aa27ba11820d4ad0d749ddf688f51ec86811d0f2c43e15901de5c921e1eca5de80e81f608eb77596329dccdd4ff5e0b1581dede330a88b9853138a2165e59e8b034991b6c66c3bb786c6d186771dcd17eea83576f09f8b8122ea84ef80490ee705ae10b361ace1cad6460f7e5ad624d421cf88c17c2b6628a90d8d175e6a7a00caefa0a41c38d72601b8bd08b27c912ea759567923e4339a6f1103cfef9f7b5a1fb99ced3ea44f5f27cd7c7502815234a0533822d930efb79b89f4a963568778277779e3d6b5a297c821ef28348693b0c8cf4436293c7a335c8b3c1ec170a48545a204b746cae45f417a27a15f24bd3ce266fd2e6418704b9a9cc9c33656e4ccda214a1e6e606312f73a3ddc7c67bd9374503cc21dd1286a8e5892d9eaaa64b50b32c2eeb4cdff710b8172324f30c47a3c7a4fa61107549d7760764a0a3961005c402de2fd87879991a05eab56fcaa0e1823a0c20231185ef61c3556ea210d522831b39dde567e98e3a2456e12b8827ae0f35b5aad6ff2922e4c812ce8da3362552f64d57f63193fc2a79b73f5ef40f6b863f8efa59f3fd39219c8390aee5bf68179321555479f602760d23673eaff482dc0a6cd2be4cc5adeb56ca8580249e859d26774ea3af1d0fe7659ebc1154c2ce7824b8dfe9e6b3b8c6b4ced95890771f546a7c62caeb2b1c0a6912aa6092c51bc284ed3280eeb241429dabd889e00f2f935d9e603b924d81ca46dee1ef0bdcc44772f9e1496d26e5abdc997bc46911386decbfa0d4d4595e365699e3778aa6db5a8b07be234baf0592b7647d4e68834b23119160a378dc3c83608b081b4a42b56ec7c2e368e4584f547eee000992271ec3f731022447abab569e8aebe8e5151b942c0b99ef6953ccba7c5b99b666ed0be0a796b885db3dfb45290ba11eaf8a544a6743d95690507f2f993a29fd79281def0a9dc3c271c8dea22900359f05c74ea8442855f9f7092ab32f364d9a4bf7e1f72f7e4fc3e95dd562e478be02b1267e51bcb66b146fa556c32eb3b16a79f45ee973f3f345f465dcfc514edf2b00ee626da9e5ede3b7452589e981ea47017524bb394027cd39d2682515b3eab892ec12007c56e08b3ddbf55472b912b42a7bc70a962158d4c0922adcf1e07dd0f3c76ae23b8da51fa5d49f8644c3aae798860307fd7b0cbe49f43148c79aaa384801dab2bb398566f76d5231bea1b0e384271744cc23193e03dcd92762e121d1d5fddefa26dfdc34f01e58ecf2d5902f1cd980a440fb8f760c7b812fcb8579ff338ae7bc6c5613fae977e35fad84c28d87e7f9ae4d1786e2533b888f8a6f52abdbc9eec02e0b7fca7fe38d810f4081ad816ab7cfa5ab9e2f51a9f434230717fd294e605efdbd1095ef1d36965e030a3a7e4936617da033f0ba559bc9d399b58e009fc43c9d92642280f42cb8048741b327a274bffac62911e54be5ddffbfac1ab4ba7dd758fc702e007e21d248e94a6a6e2c7cd58b8eea3ad3febf14bd0f60bc02ec8a11e6708ed0dfce98f3e41698f1256153f4e58b769f9a4724c5fa7f05deb544ff2fd0aaff9ac776ba7fc495de3be05bdb5d8ae5fb5827baeed9d901d7879befd751ef3fb0077bcd298dc23851e5dc1e8914bf362265eb510aec4c69d93601d7701c7e9108b3d59c609d3158ed68279d21d4fb7b4b8c7ea1867f3aa0a94e878e417e31aaa363cf75bc8f97f05dcc142437553d723c11d9c71d2f083220ee2d9e38753351a65a954998f70bda801dee9749c09a29ce6b737a9a9583de9f930549223516c15936c4eb760472e6f9ff4542cfe8ba3b0e60f9da631f4f406c297055733ba87fa8196258768d3d56235fdda27cf063d73435acef9650ede15b51b78476f5774d833f0fa5052dfff8be3b2d6536341756772f158624a011baf15223ce339e9d5542b58356d1b6fef2150d92aea2dd79cf054afc8b529852d4224f9a18da26b43cb2e76788bc7f696bcb3f07dcd2dcce7d686375900f3764301857099f21de023fe60c5444085253c7123479089f74494ea2afcb825bb56ae0ddc07532e78526317d454d83bcfc1917f53a2984e61fa1b22cd0059eec5d6dc228f0d2909f5811e241e6e3274fd56a165a1afe57d1ca5078bd719f5cccd57d9badfeef0228097499c64a78ace506deb5d407c16ab3bf12afc926d20d0b895b2734faf3b5bccab9a5caca7b98a29c98e351b5a5557160557a46c27493f3f72a9eacb077451609e2e2a11bbea3e7f67fdb447b7b120a35e301b0e890d05d96067e74b52fe758ae65cf3016cdef08c5ef0f0e1107a28454605eb242e388f9837026697a9495080315779d1a05546c639e8a0c4d0fef3fbedbc2522e3554fe37d012804f8bef49211059ac6c908b8e2b6a84ffb66e9e23ec6ab939d93457db885ac5b485f1851d7fd9e8efebcbe8e4073688e163d364397622a8bbf86cf89ea304749afb4076ea14ba13434cabd4c2bc5f43be0249e21c494a7e4651b5fef1d34ad347ddb15a5cf4612d04218703f8b5fcbfe591ca7468dec3e00388822da75027ab2a4945d61c6d80212e4a1958f0388f7aa6d76adad80eabca697b5fd3e59f92d1c6fb3d7ccad94c5a17c87a21f6e37de1feac040bcadd28b493fefb1fd5c80c69f3db11847fa54e41ae58b4cd51138b54087eb242196ff844c4d3726bd95667864108d270f88aa61aa31fe1b553c6af25238ffd1fb888b2550c9f73c55e8d6c4256719dfe4e63cb0539fa8183e058052e984d5792624eb971fba12bcaa13bd60509a60350189a2c8b26055962e0cdbaf45dd742c6f708dbbc64d3df3a5cf1f4fc2a5b0916956742b394eafd1906cc70c76ebed38e7bd001f0cfb74950a4c7481a17fb9369a3badc27eb0011716e79ab1819f26a3eef42b7ee8f0ff703ccc29af9cc416b8fc9eeaf8c890a3c7e3d548b07318c2aa89f638af70ed4022be5dc9e00b93f22c4b506d45ced48fa61288be3b1f8ac8bd6e8bbc27f99dd7c2d8b8f87561520edf7e349ca2a368100623e902de6279d57f34ac022d3f98643f0646bed88fce2055b03d670ce6cd483a0aa9c8e5df9965f88b859350f8a071bb6f41c09478fe200fd748e2bbb947cf2deb634b76b5a41528ede42506f17e0c1d16802d7790840f9cf7e95d0f33dea1984fb87c2a1269385f99ad6b600b2cb6b74c392e20a5e506b6286fb0a0bae5bef16c6a0efd9b259f4551536d994bed8923316e7b1ae6241fdc07baa243e1485d5a20ba3fdc38acd89ec63ec118e90e6fe6fbc6ca7993af18fecdf87342d901a319fd08220ed0d84408b398841ecb5a28f75a8ee5f934e82f4f6c65121e2369fec1b906718a44ba64ffae36301243f50d9171e76a9ee5e1f11b86c3d842c7dbd4b5a9ade56bed53dc50a57647f0c35e3f468b61230228ce94a183780dea1b8db326e5d53d3612acac59d1156023b57df2bb021239639f78c1343121e77eb29d68f4051cfb38bcdf22beb92338804d6b601197c6ee1e18240b356ea6b18d32bb99ff1f9fd2454d4f58602396b8033bcfeef880a7021043765af1407397843aedad8b4dd7377c045f3c8fdae51fdc1be350fccf33c41516ed1c76fcc828153e4a9a93c149637d0e7e74977db574defacda640323778c8de8838d7f72c34cc6ad8f7031ea3387c97534b9af649a90300bdb056585bee6b64be4dee565523f5473b89c44de942578242f15a5702e67562c39db1900c7d71e36536472d51a03a3cea6ec757fad5e31ca69fbce5ca3b198c28b15c20ae8d96555718dd16200c0adde14c8df9e49b5be6aad4ca4fc45e099f9e54fc952d4e1e5962ece4703772e619114184a72d97a8ce8d47c54de5987443dc4208e38e467389872d390e3d54189934c7a2902ff2e8d439ffc2e7889aa9a036ffbb70d9abb5c500882186e79bdfb77276f6b3e7df6050a89df629d12f80fcaa7219c79ca7987ba8a33ffc613f58199a6016d79af46d65876a7df10b20b282118287508f39a1ba1479397a57b1b6994851a262775be934990a5ce3318769ab0dd8cd825d3a5aa398e9d4d04e4db253eba57621282d507cdcccc95b9df165638ba6cacf0b4130629df23f659e16ba85ddaa4127d4a4218585cfd8ff00d7a2238b6894afed2ea09a54200011287e413b0ddcb33687761ce351cfd40652baddca51b547106e7e59560e513cfd69137dbf3f2a667fb9582551f35f0b83c103097463d863415791172ec0fd518a968aba1e8d04109fec2e97d0ee0b5fbed8c6b87f256d50ae5bc3db546203b097ceac31b39f96bace8cd2207f3a7dafad8f7ee32694a76afecfef6c23082272949f83ab8f332ab76f8dbdd957760e5d776c984f4ef91eb04a85497082d80fd35d91ffa03a725ee06c7e92292f3363320c6f82278fac1a0a3000b1028c495be3d0ed371ad7bcfde711a9c82bb907e994aa7116dbb214262adb08220f797d97330f11a63bc67c794860a1f6723e05375b2d1f732fd2e9eabf782d4af9c53292999dd1bf650d0a485c743bd4878c91223a31ca2b4b2eaba27aa7c28f4dfc849d020eff5ca500bd348db08b406d2199aa5f0e89a4bc12d0b81127ae1b647b322480e30ec0a1411e3e747395405c7d5a42fc3aa305746192c28cec76555f8f559c2d0111557d2ca01253d95f1e9baa9d0fe8a1c4a13d4b03128ca8c6d5b624583a07b70df674cd30327762ff54b757ac3d18dea1775c690c35190cc41baea4e91f48af10a54d1f2cf3224bca6d7d30d0d8c0afa332e91c57b9de1b80894d1d776cadafc50b132c8261e820f3fbe3161d9ae7a237d2208d8a268d08e5959808319f4c84d284fffa43b9f9015e58fbff50f33e8fb2dad1f28d0cf5cf21e95dafdc34d117362d0545aeec3ee74d2f48dd48c93916e4df1d1ba59eb62b843b5be93adc8be8c0a57a05a8f23e90f2546598f535767a56550b24ccd1c081c765280049bddd693189da64691030c0bf2d7a6ccceed63e54b674caa56f7a2714ad1eec89f6a61877cda4f9e15b41175584067559996f2dfeedaf9c9bb72c3751a5b0e369ffb36292365977d2c4156fb3650c52bf40e4be5b49adee09050ca8dbc0422ba22e058f59f32623a31f282548c7ddc32c6c0f9742fbbf620424b73a41f703de72079dc97821c5c0ca807b6037e88d3545bbd0d6ed18b829c0d5cc055195970bb206c634e15d21f1e0b339bc739d855979dcb410be3994f79e2613c1c5271a555ecb0a152020689ddf419cdc4d3c5988ed94f65a1887feb4fee873a4d028aea99f92f23e60bc75cee03dde696d8512bf7863a58c385dfbfef23f09228cd6df603537a5c0d76577e0ada2bb1a9019ce9a418c9da40a66f9e3a704f13beeeca42b35c7d5fbf29e09a499911ab949b197707e0facc5e9be4704fc625b378580ce36b4f91a71a7d04fbe916c7e4e9bdd71dc445d17d46e954a625c363ab9a186c62a2d229aaa07c53b4cb8ca68319f1cdbcc7a82b57b4741e5786ce4ce61131368a1a534a9b02bf137603eb106fcc39a6174cbc3cc7776bce748e735e95579ad55390345c22577ebe18b56207817b7d3ecbd6899b8732553301f5c709e260baadd76ca0a1a22a29ca3fd9e638030a9efd085c801c97d01ed2cdd8803f0280636b83b2bc354bdd530a258ba8418f2ee17fe69dad20bf995207b298af98020d2b19b9fbc03e46fb0ab350c1109e46d2c914764c36d1f607cf021b883a0a199249d341b40497a9f6460178c0e0513c425a67928b307e0cb4deb1253c5ae984fee9a80079bc47f67d458560bc526b0899b282cbd92b7c5de7320a5e1790f2dfc4f0df6c2daf630349db4db1e16b0e95a7507bd074534e358e91dfed43fe173bc88b23e9a9ebaddc578b849ff01a29d2d70f890111f8b584212ddc2698cb26115f56663f71db70bec8a22fe67c3b668582b8e9044b221a3857124bb19a9915f6f2d50ed795e4c8fdab4638d8e81712b92ea2b1fd773dc2f60b5de39235ef38d457a98b0f0ae049f4486e78cc6402356945757005bbbed5e6595ea3a936151e1ef0241be08b2ea720d24856fbddc49d48d478845919acccd59cd6fa55202385334518d8aaec9b7a49943580a8905c15ee2db2167a8bde2b5666240e245bdc9698f1035100aeae2eb25f2eb6e48d1b845f72e3d404ac18d6f660da224bd7ca8bf9319db5cb4505dd10a5b93cbee20ca257e867de693d969979f0402564f8c5d2473cfcc8699d3b3fd531d496ebefdf8ae68616ddac6f82bdd2a024f4d72df309d2b728f6494b8e4e1a9c59b6b7cabbf2a1ca965a5af74c81f49bf37e7786295c9cca884c779022aaf2b7566a826d8023e32b51ae9f1b1d217465c7b85b7648dd137115bc31c58371b4d891d39317d0f95080300b54c7eaa261b2bd85a49585b8505ada92a21f432ab4ff32b13a398d1a28e2ead25fe71e528ee1d501675f3d880c0d71c5defee2a8ab074d5a2599fcd838e5f959b4d432a05f82a2773556f15c4e2d2f22e8aafd33fafd822b08d731d8b713629114560b49c826f9b7fb18599453279f80e53a591ad491701a2821cca4ecaf17a5f2168fd73ccfee9614e78d78a5de328ae4a14b9d9647569e42f50ac12adf641ea82723754210939d7bfe635f6e6bdee1106493833da18cddd0c6dfbd242de3d7bd31a438399cbc45f15e00f56d8f7eb1adc244de90eaeffa1b48a62f0aa54a17f9838875d97afa48d3f47991c7882b3c745d03166e35793b5dda4dbaf54bf2f45130037d6bb90d74e505b0feaec76a1323bf9962608885a0ef9c6f02d8f558bccdbe6c10dec611a99f4c6faeffa50aa685516f23673fafcbc1ed853b3f51499492d87f5aa0373b9522aeb73080dd89b5b188ac6ca131b22c509669f247fde163fa044e9ef71d83e62f572135feba7d392fed58cc40a19b766220236574e79613de9ab8c41bf311ae83ec5b757486ff05eeb5af793177eb8f934fcf44a66727bd772574c35744bafbcfb720d96f7d98f91a0e2693cb3ee61285c87111de127dbfdf3b13a45cb522f1222204aef2c0cf0250e0c86fdf96d70646fc007cdb048c2eaa4de037835ffba3ecb2fe6980e4781762843900fb3473d79fc668faf354c6cbc78bb79148802e679100b50df5ec1a9a21c00db7ee7e122dade7abfb1fd1794281237657604a24ac81300c4ecb676ffba11bad4cbcf6203bf1dfdc3d6e4b6ef907aa8cb842455a559a1304c4f109f77fbd4ff310b9ed81f09e6693c1be1fac3f4b78d88900a6757eb7c93be14ef4d6566d95a76396923abd01f66cdbe331c4d0b0dfe4028c15305e5ccb541ee387c0bc091b15b10149408c97c3808cdbf661df7a99c8f247b9a0157d40f9efbda9af694df3dc8eef09d43c46cc482b8181697f0c94303c92bf487323729f4a06e885fb6d0ad9a87d555ef6724b26fdca77d2f5975c355bae500c98d788e7682db9b1194f4af528953d62b86046762bef9e0138a85695ad8954226c23e64462fe0241c40f7a21f6678bb80208a52d3c5a1d1b8bbdafcdd88c8a7ff9472c8b3a5568f21320899f964c5a009d56adb5af2e0af6c22c6f18122977ba815b4cf9311110d09e4047d8a1175dd050e3d41e3e5e8d7df43b5a0106cfac724f5353a6299ed1a8cdb6bfc109a4032e9c8635cbee1757c305b952fdea0252b5c0c29c701e3fcaa734a2efcc6752010a5b4e99dee63f40c46d7dc8bc1b785c679f46db147d01f6597b59f6e7ce4c150d868ff4b4c4c0a252798c44add11b025fad871582ffe651ec19d59e2a815bb36391871d3146b57ce3216b9e064b63dee91227f41b5b8a28181dcf02a5f1078987e4d9250ab3194ac9612c1458d0b08ff972022df96ec4c4d96e044994079df237ae04a745b66fd62102fb1165afe4568396b2866fcc77f047318df370f71d4d1ef7800874c6442a162a79d02fb98cbd2f210c94796369c61d74cdaad9e34b01abab8a88d8453281fb5576e372ac924cf668ba64dfa039eb5aff1b1d1841964ace090b90f2d94c0c647e62c7d9d5b9570b7d05442bacd98f55f92b6c84eca6202605c029e63e4d01cc9c4b32286b8a390ebcdcbd978830563f66ae7d435913f154bfc03672fa46dbf64a7b32fa537be6b07273d4c40ae4a19c4e56c4e2ea99167f0c5e2e8bcdc736485db03fc2984e36c518fe1622b995ae08872e6ed8cfc0a1098c122a1259227a3660f0e5c17e068e37e41759dcc84fac1b6b2604007d613af0a19110aae3063ea3380aa5c0a526182ff8d1e370187e8303797966380846acc1ea15303c302cd96097ebe5141f99817fa7f8c4988362b515e98c8d2b0124272dcd7e32f43b3bd2c83c9692f4a15bec4a995574ec62377e3833881c44ef26b57e09cca617596faaad4e40e62a2d523bfa4150195327efb567ee1b99d71a3ec325d74745cb3b258d7a1e1f737fc6296117399255d312b7e0ab126bc50114a6d94859842089f2c4c22a357e79d1a3acca76020750251ec4e10f34c7dc365f4c2c031200d8812982568da8bbf95373eba162114cffe4bc9330989d4cc588ba79f6fee92f085df60ccd31e96ba78ab92c5b7f73a670ca95043155aabd24ec4c150aa5b439939e2935f10fb03cab174801578f8ab6c2ce0c085b61fae13f67b5ceafd7aba5832a1b4784220bf9e796b9bb6f39749e375cc725916fc9c54695b0857c7603d89c9c1a4c413a25b201dddf3f2bbfd4d71941b4878788a96c30e10605e5c551626c4833ae953eaf28869a58d4788703245495760bddf54e843f31bc889829e5675f67ee3d915a5a04efb4553ed6f31ee4cfe32cf9f85533bf5792507e046c9354b53dbd8061957ecc2e3b472e2f564ad262a475417fcc158c9dc7c300b9e9b823cfa286a9040efe51151d9800b80b96cdc40844110d64021c37f630111dba0643ebb3c69b21567ff128cd3d05a9948d639cc0e720b3f8a9b5a924f09354f6a8dff8729d83cfd845eb0a439076f66a08b9bef9349cab0b8297ce370a9840c806e0cc3354259c425bd50d54cac97bc0a756d9d08504723232c0ea9bbf864f068ba03f6964c5e7e9342d94d3a7b1431753b887ec8cbb40c51e6a68ba33e66c77aa90ad429f77ec6992e98a2026d07f0afedeea648ad9009f25e3002de279561506aa18bea527e60e367a76213586570514314c3d7031105b08dc5f003e526ba0fc7fe57ad4e38af3d252d38dda197d9972690078bc531d3685b301594761ff963c7aa2c38a6c2219807a8f50e1599ace9d7a5e92537c892b004eadeb11780ae30809b39e9ed1091e31898e574009462208ac6a31bd0edf90c5e691db41ca84785b5d80619092405a0abd8ade513e01a5bbd81e5862cb78ba5908d4a48595566aa8be7b2dbfdde4c59b3bab49bf46abe5674da66781ce56dd8a9c0413682c92f0e4502c4266594f592fe476bc4dd110a9eb439b7f8106c4e2fa5f65bc0b2ae576b1906266f0ccdfc0574bbcd211301f0e81a049614f29c64abc9b64532c451762f04a5eef2a9493e832b5b4fc0b785907827f8057f86049396b55d00ac172f07fe3f2b8b69b10f6d039d1c0955fa342fc53f65b4c64ed3ed376ec7d42cf800075ca7f82527bb8587440cf37a88ae5e70a391f1e4fd1864a3717f862b52a7f45d2dfcafd364c42619a117e301748fa2246aa8326c67698ccc9adb67a649d11851019e1c9ea47f9e4a05019587153caea6576b3d06af6378fdd350a153a21673c56993b17bab9b75752083f7b4594e562e3d10944a6985fec7566d65f75f600165acc8230b65bb693b35a835678faf6bce566bc9154c13451f7c10869497fa0f77efba1eec3a15fa984ea97356f11398d85f663820e1db41028662f8316dbbb6032b6b1895049b9ea1ebd55c835cea924506fe311a2c50048828bad979e5b8a4be71c718057fc8044743f1915cff958238f9373d13c81eec96769f69a150aa1aeb31deec1c661e9f09d6278499529b8bc802f283e65c491e506549e4372d0801d25c25996ecd483bd5e0936f1ebce397b1a998ca14452235bb601136e178a9c85927ade13b862bfe0428a677c9f38c6cb97a1a097b79a8854acf38ad81c565edf044b3d6b4fa34b85ebcf85b460b0eae0eefc1993087b5cdfb79f8d6842fad4645ead01ebbb6eafece17f93b4e3dca04408e63d890433a1d71334890b70769071a8a24409b9072cf003172c2afbae403ad4e56473822f9660359edd711016a0c02a35c21c1536f1f46586762500f64dd7027af47516c24931d3b09a07320eb942a2ec6a7e0b3503eea4ca1220605cc0e77b271c92ea8156e5aeb2065c910f032213cfacbf7aaafb993da839237c6f5df73a49e9d8398d8d53fc01a1dace00077bcc44701cbd08b5559c64230f70fc90f1bb1dc89c486b63d8bc1391c6ae4edf073c6fe631cfb93112d9ce63701efdf94540efb3da4dbe313782b6e1e6297baa67182d26f3c522e930cc4e9b3ecab86d62de6ac5ded94a18b378bbf546fe795c3b05e45c3920be9c2e66601ef7f1bfaee3335808695b33f2c019385f3b9c217f901e729900e615a6bb43676e4b1868233da64036cda9606c11def8e5679e3b7d6f6037eb150d34232dcb06585046d3a1e7260ee22bbbbac5bef5dcc73cd9ead6a9f723b351b1c46b964dae04cc1112e276c7520d5506c590e0d9709fc4099ae8a933b0fd92e4b8df9bc58606c706bfa8daea511d82a9cb1105287bf0ddc1f3f87a7ef26d60e6b2e14afa1f179e84d4040f03117417836a1c1f2cd1b2bebe9b4cb7635113d4c95fc4626a6841128c79817d38ec8a9cc49d51b7b8a7c931229294365012f281c7797ba143e14062f9ab7f222e72595f3aa43192042a046a9dbef5a4ac17378072c80622f339c7fa703d2cd29748be163db955ca92f8bc7727477a0744f4fb63f8c8eadc1c205d6599cff9e094588880409d22b41f4dae0a6d94ccb0b3b8dc6a7db87a99e4786ba0443e9c7191bf5e51894c4cac2a5ea136faf7c4159e1c2170e0629ac5200eb63b8ef0d4f6a0a31995e9a3457bba3df27a32ccb413383a795e43eaf92078c718279315eadac25877f748ec0887375bcc252c9bee02e324f3ec5bbf6baa864ea53d5ca011f62c9641407ac9d8acd54f2fac1f955b148b2a96353af51d34ba529ed9298e95f454784448391103c1a8e71e72aa9ca5903c312851e25cf81d3f18ec27e2ed8b0e4fe0275c9bbf0a03e4fa2f2ee55666d5ab0c2d6a31b3e989f275ba14fca1a475c0eea9f357aaf0e73d5d1d59ecf616098256b196046b8571fb3a889f20684eef8f9aea1fd1f2749dbdf89d1080e69477b0a021528d1ce219979e162108db844727ec81265d70a626087b15dca999263aaab1c689fc72f37e8b4f9f90a8424c7d959d051251668088d5fb1d3caae14b90415c2ac34236abbf4958da52d2e517cefcda03c90d73ff0907c39424679c0ebcfd61cea7240d6266a58ae6005272026aaadfc41c87e6e8c270053649a95b37d3ff2ccd41b09390fdb177bb89526b82c0d04c606a5d417832a5a804bf12824b909de1e0c5578d2cd808b9f0c7a4262703d8576c90c61c63545292896b48b3e85e308f83e4df8ebef8f6f579142700dbee7ba70051ae8e0a560de5f58fa2c5df39c483fbdec6c9020985921a64374ad60e4d83e02709f6b99871f0709ed817f2c6a831dbe9c790080c229db6f2e85f62991de4d40cfe0c16fcc0c2d2b62f5a3b3cd337a8a89373e38af71f40cc88ee090bfcf91da8ced7ef8e6b1f3b8f4f1c39f33eee74cd7d1a9b79567e0f87cc56eae59b4620635a45658f20765d4a5fc446e51aed45e40f3f8f974af548177af323875a5fad63b273072527a786435591b1e5ad834d10a0d8e41107d8585710700a267e6079b64259a68c49f46ca26c14010c2b22df172dde2f9ef891064a39988fcd1ad98705ed6c983c4fda1db2f269a7bda9e5586a211ae90fecec2ce915c6c9955fb473a9b20843a24bfafa75a4a3df50513461a774e505d22ef28b402b84ae469fb272612cca94bd3d6bf1a7d2bde9262a05fd52b4fb8b81c7dbe847c407846d8818083d69e626257565b4422a27aad22e225f849b6b316dfd00732e58c175a3fc96cf90da14b5b22a932a55b742645dda2e5f9e8348f5aae538b2c62ff7099a2b73c7676f9444c72374fce851c9f189d5e73b23d0564bc88452d71b47fc6aa29bdaf30f170ebb21f18d15230a8746af85aabf0cd6310e5b32350db35e4ca3d152785350685d69cdcc36b29ef0c54b828edf0492b588ed00bdef98f1a3b4ef8f20f9aa89e1128fbec66854b56b8f7d7b189ca093e42ee8f47b41423b2882244aa1de7ca9f2d84d9d28f2d2a6ab29c06f608e10e58c8f62c4d5d95bf7fcc1088e1751bf85af225e3a80909342667e00ef58034a7ee647f88fa5d4185bb448724d02d9430ce5b7bf082575006d02a2b7c1d1cf9fc03ac6215653a021333c505632e5c0b4d0253561fb79345a8cbae550f88794ba0ccebb9c7208fdb5dd2d484588b6a77a3289471b28c7cfa1847509ff0215907260e1703933d1d5e086cd9eb5472f2f7bfa27baa063713d856e223e667a395cf538673d460221ab340d7132a2cf51c99cc4c88440d532fc0d5228b365be799c86702534696ff54a1775b348cd302127a8107d8b64cee8d73e09684a50941987325ecfc8b83cb2c2283b63c0ae60dd7f8eef7c1bafc3c7e0967eeaac03d2223d9aa1effca8ac03bd9fe7c60a36ba86ca42b1e5adebd0b19c904b9a7aeb74a817e2a61f3971e7fd85847588c0cda3787d7b804915db29cff8647690e2eaa09fbeace8d00bc42c709df65bcb05bb2c0d57cd869283cf5e01f4f27c5cc41f759d7902ef7451ac58e7910202ae30b53a888af272daea108ab0481d6d238b76ed4921c7a4e709026628fdaec747d42dce567b6fd23126e54dccd9281d32308766669ca55df048487a7bfc51c86f33876ab45467395bbcc1357a2fae8a411148ef40d63a313451a55e2347b37fe360a878fa4660be683166c9f9f77a5d251dc8de3761257845520556e4417888b219877fa6193970cafb28ead7cd8265e7eefde675f5e1ee8cdde59d9ecf74f0aa29e6a8df5dfb91eea65271ee97e7b7a7342c562bbad488222c6ef0134253f725fc0d59230f3102887f6f6853733ace1c27678a756618651d247d138357271682b26764dadd3fbfcaf297962f8ab6bad93e966dcf333145fcf292a502dcc7894f1dfc8d42a75f04ed7a4043a217a5d02b37b46d5e35263b6df2ad8337a9a0d97193a3ff8cf76a74279667b6ce4292fc178dcdece1fbc2ea8849e9f9625ba9c632d843e4ec9c37a7edd5029d612f5cb987f892ac338388f0952c459aa8186905e02c1b03fc0d51639264c06ccaa22148d416a04c40f7298ee6020df35dd6b39799090ff79569c10e05a3a06ed253a8f2f04ac03cf995acee0bcdfb0107f69e678a38e6cdd7b293f4c838668c88f8cf6c77b8352e1eaa6353b340c75928202809b66f6232b702f9e4995b9ebe8c509d6cefc5ae73d28b0093b66aa32fd4ff8f0e93d53e22198518db1ee58afa4226ff82758932c4a6a8c222ef390caeff4f614027c64f39af826e08fd1b625c80f792d29bd1adde0781004e4a6dde042da057d06709d34777e06557deb1b511e26625879548d89d8e1a666866fd00794055c95f72d1bce8683ccb6ee3c0c715dc0a8bcc5a6cb0fdc2783684a1ac8e84a51631ca55b5c4b2fe73940b801daa0f1650f1d4da056e0448211390ae6a9062454ad281f3fb269da7ff25461a72d5e2cb7266b820c2fecb563132c0358d38fae953f6d60177230f0834f5245d62e14f0df30c13182b0985e3714dfdb146dea516cc900e0e61ab22df8b1c73289a24dc40cc39fd5f6a39302e030fd3227d2620622b3c695c9cd6d27cd4c2dd1b275c5963e369d1d10147543dd4951bad480ff7930c6997aabc7d59abee70094e7c265577fa6d8ef986f987eb3b839225c8ff9b17a36824e4407cc6b379047dc92489595021ddd277e7bffbf8d89327660f4bc85b76dca185ff7c96883ee1302b38f06d4eaef1486642fd891c021869f47de8ad25644160efa66e98d27e9fadc069b386d16ad33010f852928bcae96f32f7b8e50751b2facdcc45b0cb050330bae3b042af5ebf7be8f1242411cf16a9afc45dba7f45cc4d4822e8d45bbc3f2929b89923f51ab7d6075911ef9edbd4655a188eaf8c9b5a6799844b71e8952c9f4d438330330a900e2f0af0335869eb3c8c5a6b7d405b8a97b307895b5fcb6668ee67998838488b0236d9c76e82056a917c728e8393549bc8dff4084fa2f5826f1845e91bcbc40c0e2eacff1f448e35a99597dccd1c1c613fefae908789edd9a43cb08c30b4d5c217b5eae165150448c7c58cc3bc8982d9d128767094dae0a606364f0d1142ac7007c877b7d660d416cc4473368440ea9b4049c0cabf2532e61d5cfbca09549f46033acc0da799af670597e0ae97e722b3e23af0064fa150eb05910f3c3b05f5aade8ffecc636375225275f4b9beb14cac48873d1984d7f037eb64558268439575b5167fb49b561fdac7402231d68ee2a17628ae229c37f7dcbffc7e5a2c18ab321be33d5941fc4b7130b48729dd94ed249f72fc78964cb110be1ed784169142de74274b09c81233bdd32dd056fee76054b42d2279e250774bde5a5dcb7900b7890b64390347905dd6e9c163be7c138c3a3c593348edbbe1ae72220631e962afb8182e468ed067250d45ff8904495e9d9a80a98846e4e96a41dbffac143442a2c6642e8ca99acc7d1041e7bd5451ebf35a431cc6441ccc7ebfc0f1e4b2ce848f38a7e84b9b1c4cc877f6f612b82e10180fc4115de19d41c69d7ad9f7c59e2add9ac0d5544d76d13984aa514ac18ada0f93cd268f264dfc0134e6e05cc33c3f80042fedeb19baa4e950df3562c03dd870202efab62eb2c644bd3739aa36d1a8fd2265c1d1b851f08a423fbb716ad8814e0f192a99a57005653c493416218f9ad3d04a38a1cc7d692add61c725282110b3332219b01b97a8cd5a71d45a5da833f36c79010aad3556502936ac2829f661383d1f839d3eb0131b11f360341552e12e46658ff2ea55118847b5dce803ea186dac287211df6ed7981c8ab3af0ee8575ccfa67ff666f9023dc55b1c6c636ce41ba13a2e7e4266f253ad9d8388d7c228029a73573f5b079155bb45150f1cfeff1d3379e23dc7f5d1ce821e0eb128da732c8e05a8dd0f7ee222ec3dc0809d4626a5c9473b47835df55c7078f7e948fd5f992ee959f3d46532adc7c6526bc8d378f21fc54aec7dd6f885fc6bfb26e95854aafdd7149faaa460bd2a4ffac2bed4c8efb42628028884abe4c71ab91a339148441c846231ad918d0a95214deec00e89fd41589977db48abb61d0067be5db592bea96faea9532f0c2532bb296b4920a101955df2d6b0d41bbde1e976409ec2d79672c3ab5ab8dd2159746df283af25f16212c84a91e422857f27eafa2434c0567dd88299e5459afb115c26fdfd3edba33a44affe15791329119f6e50c50f8c421484c4126ee28939914774e27f06b73b28c45702800f500a8891c8162009aab2b9894597c920c38248d227d8b1abd7c07baa5ecd7bae438ced2d3256b80ad19ed01fa50d4a319b0034abd10d2c6e9cf5da258d3441ccc582fef37d0d7bd47d0468bf79aa70591c3f1346f8319a997a299feb4742c08731026e52a0f9f7b98c269446ec28c959cd9ddbb20ac325b6ccf21eebec8087cb50b7d8067271e9b8f7d19aa71ad2e713a484bb641d4ff16583b445298072f5983b2b2053826e1695fd9860d0904e2792cd43caf0e62a0675399a4b3d43a179739b2916b9256eea82fb09c13957bd38a9182273451e1d4926401d82577a448060fd456685809ebfdf713060c2d1895dc7c9df9c8d5548604a584c96e883e44b4ceb0dd085abc2ec932f3d28d5abe588cf55c6715cf60ad4d76632f83f8a02191d36b9abdab9e137ff157c60f8ba66f8fb17a4f160ec274dd2c7da6b62416f160860f412d3c94d3a62ade7cea1c003c54201e39969c1fbee8ffb2a745c6007fb38a10e8ac9c49a5deceaf71a1e69b8b56cc91f6b283d2221cc628723d43b4cc585eab806f2c39e280f3d361ea6c853dc729d0921f5bd6f94ea89d15e2fcc71ac36b6126b3abdfa7f0e26a17035d75a72be6a7ddde0fd809dba061ffe929bf6c5d016edcd63b100d6ae35527232c338cecbfae58094880b8f6969aea8667322663cdc9b9b065895e239d9d07371ae58948520b03aad54e86821ee3e28379ef5bd99a4df27749e507c8fd1293e7f87e4f9e2c1d97efc98b0479b90f2b6d13cbed89c1b723b9afab2c254b1bbfa9acf2bf7f384351e32262872a074c581c6afe4aaa39f732115efd78a50dc40dd7986072a8c3639b9078bf4dc551ae6e0703404f54d5f6efde273c35df1b4deb713b8372b8a61bf462607d927b9dd01fb0167572a8f45aeb0b7e2c957163ea302cc0c3ce77cf24e95991b384b3d6000195ab5b3de481c9eb70c8aeb0cd898db4bd653087764c0e727f50e0503f8fd2a456e363f3bdca76200cc8fd6033d2e1aceca5acfa50f080fd8355061c47412763d96e98aeaabbb4e1fabfd6534f9a4106f245a0cd0b5d1371f85658cf4fbc8339a3d33b65a37d840f36c56b739c8d9103e2be5d53b77d07041cf42e4706df846e89c2ef6f5091c190939ca0480adb660a9ca1e09a82abdd713f67d8b36999935a15e77d30095c87ba29bc2d3bfdd75f15bee327e907196dc7bb2513781e6212454adc8e3dec1c34f8ae51935a3003cbf1c4fce67025816eef006c4a2f85f7a3626447491dda7811ebaf60b64a4ca2fbb37da53cb4ed220ebd3b0d03c72e354e1ad0a5939597c87cff914870863833a40c4954339726c47a1834b5b0b051418c9b06e8e59ab883fea9cc73a739a9922fb208e41c4680d7a472f1d5e19a6ec8a60f3f2c9d59036bfc33ac90a7539df63cfcb8e1764d8f4cf5b11a2e3eca3d771bbf20189dbea7b3b0616de11ad540b30e9d683fbb2bc9c142f9c641fc113c1027ec076716d8c60fb9c263a96835a59f506a8dfc7aaa6d6b6552eaea672c38656345fb9370fea6d8be96aed230e7dee73db5fead72afb5c7d0f852c3502bc3a89690955798ddc471f383e7c68c4a3039d91e9b580c287b644ab6584eaa25319a3d636715f0c39b6e27fc58aca94e877a72b5e79fa082fef7be40f7241e30290437cf33b35e3365e5da6acde7f669aff9bcc3458ec3ee14c4deb77d9cbb729c86f6391154bb97f608c85b74c4a7cf628def2c30fd4bd47c736fc82864a9af9e4b283c2642486b0a8bda940c3ab759833cab1cc7a6d75cb199f4434c1b980c83c6bba1fca15414ba7bfe8f32a4d1775d1fb009a8497f114cd6be89e25f7778571059542b51b3f88de50d09f275ee4df1f2d4158f1eae4ce68ef71af1e3e82428c93a0c03baaa212eda98d61e1ed7887d66dc439276daaf61a9661b8034498944e4dc91122ba982509d97aa254a6bc4c487cfb95e9bc8c3396ee4882abc452b12a81a3b53fa467188f6f839c24c7ffd7786976f4247b42794beb441ca93e60e4e133ac2bc898d256d301898e84311554f0bbfcfb55963fc005a64c7054cf6df86deb974cb888a0fb3ec85ef71a8eacef6c996220900d72839798fb147217691edea2dc258f011a511107df058ef88355c6427e239929e4416dec048d939688b1fd6015212e974e2cce35e8cf41b86dc4433c9bdd07230d52be3f8ab7d527dfbe32331378e6d7112fc43edd801335db29bf39387509aab3180250d95b1eadc70670bfb077a5d166f5ab169fe62db1d90ce220f7657fc96930c8e733092a1c732e55bf2a630e5e114e3bcdb5f50d42d2eafa3dc13df7b7dd7caf658c0bd237911a1153ceb579d9910380353e41847ec0695e6ab0a145ce1c8239055ee6d9401060fd3040e63baec95121443d031553523131e06ed0588c02e72c1556f4de6d2c26453aad451a8096b5bb82ff13d78dc6b8746b6b7c3fe847f366c89e4a9080b5c3ef19c7e224702cfb8d52e824ae62153d8cd2629e534d9317122c73e7f762462d2236f40bef33a3cd00edb6550c8a7f0334bf5a8adaf2440a33ac9d93503d418e1ce76854bd569e9bff944eb71b29bcaf6dee14b0469b36ff668cbd2a6ada7aa9f73b50ebe193f9c497730d50e77f22c8bc262abe90dacc64e5c0744b6dee5d5b754b3afbfcb94effc5becb5e1062f81cc349516f8f14df7f3d739033e96b9a5dccf1ecfd06e95659fcfa4e02297036edcaf601df72b5f5792b371e167e6204ac01e72ff16970e46573becc9d2d2e88f406d5bdbc9a50598907c8d4374d05b1a1111ff3f3067c012109f811eaebad7a1b5682ea7d98e3b6db8ed86f6d4747827ef9347b671e9c6bae81a48d04c78c5e7b1e480d6bd933594b840cd220b9417d6e5e09220afbe013bc2b2d5d096405b47dcd7dcae5883118db7e2239bba1a8d5c8bd8eb4c4788267712f024e1486c05ec2f192afc954c06631b57cf7215ec0480e636b2423de84a0330a36c21dc967cac6b089722eb48923f0da4374793628b99ef4264b426b1c67e4383c8a26e1fdd75f20b1e7ca9aa601c66b2150cce06f0a4bce7a8c9fbfe5fcef54aa7230a61bad31882cba1669d996daa74535be789ef7c80ca3d79ae61c9aad266cf917c8797f086f6fa7e022c7979b6500f7e5a52c6ccd7b7cb238cd1a1fd39d5e29ffd1d57ce9bb1c01a649ed78f094fa4614b7ac6bdee6a0a09abe7d6a67189b64d5560861c15ccd36a05e3762521fedf4df749ceeca401596c8d438bb6abbd2df0d2984d617734ba3037fcb63b16b49cfc44c33bd04cf49d8b21f60c8a2ff6c271313a26b6720346fd61cdfcecd6561cd52de0b53fd196260039a3dc160bb475f7819c98ad6546f855f95d20dfe126ddd7ad84f33ff112bd6b57fb08a1557fa25d9226fd0d3c1e062857a5aa8860f56dfc3aefe42a1b6073aeff6beaafd594f1d1d13d56c192669c0646332b545a5c4576590454730525be30403f4e31c0cf6e5caf8954067380c351ba59065456c290443164cf20bae9b625a4df503fa3c179c4ae1644f6e201915ecb51bcca46c64466b83563434f5595a83e94bd21ec52a52b96795092cb40af9a7c76784a4daf4b3a4757269120d7f37d65b291ae3124edee3a20d1b9b5eaad62db73557aad51018464afb8feaedb0143238b803ceba1982e1cfd19ae17a6ea4edf5a57a430132e8d7ff8932392d3ac866762738028af2510ff6e058d9c7b75dfd0c86f37252f76b732a4930f6128c3e6a7f36763ec612442c47f6746e2cb2ddf7cd1e52e42a5504527677548a7eabbf8323b15ae687540b93618bd0c414b77a8a430ae03570686a2bf1cef2212c5cde7db5fca89e66f06cacfe852b18443ca7fe0de868b278b205745fa8ca7e17283ec7143b4df58d268e91215295a0de37f7965f415d28bf6f7ef6682bbbfbda7f7a02dd1bc602571fc9f512aad45b057616d6c2b3fc85ff99b6069fbfa56e907b0681fe1ab9d1cfc77967f398544e49c067d0da6ba6a4d39186af4b3cd45c2c32daf6e8fe181538f106427110a3680b715d72a77f95dee0d31d12b7c484111f54af6bfd9833ad9cf6a718b0d22d7e4672a6570e31b33a3deafa08a073207927a2d41efb3bdddc5da708f9ff9813bac90665bb01e658b59c84c8f2056cb3e67b33f36d446e709f371ceab37b079a827d904830b3d654d0f8fc787a06e3d5d6b6ca3ae476f4e10e29ffaced05655b882d4b4466da4d828d7d521d74598feffa4d7833f8dfc421ad44941ad60efa1e2760c6e8a1e0ed9fbfec432ce9d08990093adf2b85257178d623043877596f33eb69afe30c06c983161b921eb8034f6901edba12a344f8fcbe690f003d8a7d007943d302b12a6385aa63891fd9df404dbf0579c525aa22822766a6c2278526f4c92e1b35a79ecab1c30278f2f186265df23025fd13f633bae2041cbc7a774f04b6b420401060d4f51e3e115294b9fe7078d434b2f58ff4cdb304569d45106d09a2036e8fe0f4a75f6ea46c91579da1c72695829481c3dc66569602c8ffa05ebb52ea99795e7c3ba0793160cd949a676aa2d7693e8b9eb0b56cafbb5e4d886a53ce8cfce38c7404f9321a7b54cedcf5a1a747dc3af8bcbd0f0a63d2e21419c0e5f733bad3dae791c74abd5e64b5c1023dbd665140257bea946329f5cdc370f299bd3d9320bacd9bec01d2fd0b4cbd9fbb3cc8fbac9a0c00161ea09b468c6fee5ee4e07c9d0f93c48a70c6e926a04cde3c0f962ea8168c9eac2247dd6ba53fda2caba43f8d61b62de0151255db013de04d08eb50a5496511730e6a63fed68f76c9628beb455055de44a851470f3654a1bbe5774d9ea0cc65f241f53038ccc4baa016bbc3817df5183cb22d41994a41cb19f5d5511f07108c7121b72a70a5e74c3cd78a00e812958ca63d7adec9ed3433c5681a603859f7e2c0b09d562c427d0751b8531513400f3d571e65b4e3de5e532555b14c0fe757d5ca19d5811efc8819ff2cee5cc1cb8f7bb095312fea9b9781dbcfdf5e7e9b7b42f69f3bb3fcd68d85b5060884f09a6841b14e50a94be9d37e041ee953f971ca421f880b624b16b64de5c9860616d771968eb0750748735a8fb6f040458784ff545b66857fd7b3053e9579c9d428194693476aa34e7f9d77d607079ed14d9c1bfcd556a12636652f3aef7b4397eeaae96264c0c12f2afe33dcef916471debc65e9a682dd99a1c1ad0014402116fdc637ac312f325a5c7415fa11fe1f8a5c232bcdaca94fedc6a2a28e72f3754a9a3582dd2bedf8822e70dd1f930c94ee715c5b3a04222b426f28345563c4a2cbbcf7c5dc79936c8e18929f697a4173e000ec0f0819d44cc88432aceac4c2fc1386ee42d6d6cadd1ccae6970e834b11f44deef049d160923ba41b5fcd8ea85923a32d2a77d723977163ef07bdcbd82a881364891b4843ffdac7f824011c6dc298c7179d432a330259ff8f01e45f1ab9e2bc057451cc91e2c613eab3c3e2bc0a5c4523c2e97f19636cae481f8e25104daeeac5ec1e757ecd3c63435dbd9febc6ecc84deb772b6ac82aa6f8760b8a8cea678bf7815e8dcef624fbb4b25bb5cd7ec34d98f05197841bdde44c3fd6c0e49d1e5362f676fca36729e75b61a845075a30334ce616e81d08d6f2586d019fdd40a271178265783be636d18af76c8f07f0e9a7d8b53bbc3a2a8773aa4f9ddb59ba77531416f5d96ec710f1fbc74dfc0ab02fdf904d2a40a50b6452ee0c3fb93de88c0e882f82cb39fc1f30d1f357d0ca7877692cf4244d82e1ad8c74107c6f3d32aa4a7e3d55d4504c3978c8a52eff3163c7a57bbde7933f968bda1fb42b65a24218e8007c4c4b2b83ca52fb371e234183dc67ee057cb086256f8ba1718570a5524feb964ae856e305952bba68a5d8356a55e6579359cb6e8f4d8b2e9f398c1fba459134cc8cf8777098f547890248efe63aed6b9057cc46637626f73ba17cdfa38ffcefdd334f22b0c4639976134e7f4a01c0d88bd03db4304d33b717ff3ab45f348b4e3b6eab4771b7789b91007c98c5e4176e000a6d7fd89b5a7fbd6d5dbfe72287d3fdcf79beaaacb0abbed5af8270460c5c8615829fef55a1d01dee857ca8dc0fb47208a6e02eaabaacac68daa4e12c82eb5047c95a835ccc1b6747c577d769fae528077cf0a590cf2c76f9af37f2c41603a9e51a3c432de739ca48538e0dd400d960382e1c6ab20270250c8d22c9dc84583d2bb8419ba6858c7044178248a601bf6dd0a0d4765cdaa93472c3a31d90c6df5eba8e768af4ef1a4e1a5c7c58efdc2f4cc0faa0b791ed14443b541ffb041c04919aa822f9805a0abe67ea6e7d7c55aed22754476a096e9f9d3dd11c5674a2fddfd55df1188af72df88f6cc1568c6d6a99afeae80c56f978964bd75e97aeba6703b62d443c35512188f77729459cb6b0a15a9e1e83d79a8b6581812ba6afcb8e28b4cfe561e4cebf68268e20994efa8a3f0fcb8428a8974dce39bf62c52a88b69a17c5a50615bf943051af9d7ba28a7b14554f4390a74951fff82b264046357e62fc5789badfe83b9def576e3a1f3b53ef7e3a34d75db494d9f23ff58d8a57b8f9beb3771b36fdd52d3991ceea969f6eccf5dd7f155e03d19a9b23cca9be11c3189d9afb5bf6eac738477c9631a6efd37cecf4359bd6e67ba1f0cc9977e82858cba31abb1b48f03bc8dc934bd4d0963a7d7bb5853fd46512ccc72f0fef591752234d7501beaa9858443c55f0df2bb8e53bae80ad7a9a7332e188b47a4f7c49cb17284d700dca15722997014a65b78042b882a51f8e8395296da33d79c3942afba38006b5382013985a46b445d1ec5b353b4c133dbf1feaacf107a2a75ede934999c1d279751be96bf42e67336497e5b5ad8b1da668e03daf214a384a92c3dd0932326942186962bf46cdc88df2889a6b8f09272fbee2605c80fbfe927ec6b721908990deaca008feacbf3e2bd83dac30f4d179db7c1e8ff483c7f6c45e5950fddad4c9bf7a275dc03c0721527435a6cfbdf9d5e1dbf1b9aee42fb6d195ab37c312dd8d698017251478c725a2cf0c00e9f0854fb03ae3409a917167085b8711a536a2fde70ab20841434482277b19fd38548250457e00e055667d9b26b7c293155d5daf5fc0dd9b9485ad6f37956d194cf1c8b723cf4d64e446195c8f3d786d85eb38433ef353fd96056a1c38fe1523808e51e1e628ff383981448fba8f403437ff43ea2cc1946c8055e5d250c9a1b312b3a1e3264b5e47053b19a83257009bc9e6ec3f6dc4f66c5f55bed4380e2498ba1d6a703a8147e2cf631a17017dd403fe1404e9128226693ca57b5b14f54b47dc926f4b0de653c3125b66bec67b1c3bee378a714c4c8bc38af9cdc438ae2ee8764953728db62485e81a4bc3d6452061328dd1928406874dcff3bcda370c675f14ebbbe431a2052a554116520785f5e03a3eda080e1a3f4e2985af96c5dbe54bf462a27e1939a7bada39df63088c45b73e9a7277fdf120b2ede8add91f90fc3bfd820c9ae17cef6e694e3b1f1d254d88b57147cce8c3a5a6818b76e65378336e8bad1b1a0c30ba61d5ab030c603ed68cc142325cf90fbab7cbc0bb8eaac2e453490e9a89b61410dc4dd51966e532aa141a4179ecbe54bfe9fd96f683b9f1b225d3bd87ad1ef2f58fbd2de71dde42c58501602a3228b7589152c84f1ee6ed7af41c49f75c8149ccc00ed3a5893459e797f5b062b133c3fb6ed1960877b1e538cefd44258db9ab2927ada55fe13a5c3022b9da654b30f6cc737380ed469ca7dd58e1e532ede6e109c4288fe8a394e41893f28ca2dbc84b79553f7441a04443142c5df4773183de2aef4ea3386661a7f69912235660e35af4393f4d7dc18f2b4212d8785048633e8809edd13e4d70b9218f84d88d1e7959f7d35ae8a6ca79e5e5a3f4f109d961d84ca6c52df9d4f1fc7d6514dd7d9aeadf03c658d3e89caed6355dabb259d7b6c93e8d9ce097bd8c10183511bc39006213cfffe2449a12baf0f45ba89ed8d4101a676af37db6e51d86786aefda1a46b4ed2493143408d0cd439d8a5a156a98f8b4b6e2c74ed84eb5f6d9e37b06af9be3a4019f566dc4a8b1f7f15ab1aabe27d9bdf9886a7381531980a6ef1022dd75891cccb8f41a72215cda215b009d1636add119ec9de1b7e08a07cd27b4371a674d3dd6764e965770b79a5936cbaf25040b8884802818806fa647c97601f68476e7e77b58cc3b6773cf155b3784ff6738d3167fed1922458a0f9d757075fac129a72be7eac3bbbac3e128f402b1a61aeab3c0a9c9962e9225f2c89b8773a5a3e1295a84d926cf415f615e118cbabad68d31bd70463c0b36ceed954d58f80960fcaa5b49de752150b442339277638cb223e5ffab2254b66029ea242d23633fcd3d5d5d162772972cf7fa16a4498e8e710414a10cf47c451e96d9900a78e1f798b996e55ab8eca714453631bb1ef2ef31e6ff928c73bbd187b044afa6468c549c7252f11e1536d37ab4457c63475c31e01e4f481dbcc4aa77d6365256a9f1f65fa5f1777026757663713faca34cbcfcd8c1e4bd61f51d5a2e627a98483dc36acabf63ffbfeffd24364be09a91e0a80f1bc97b8c966d982d1522ec6e14dd24627bf93859c23eeb15416bab4ec55c9659e08e887cbf83c12a1d3cec0aa0f54cbb1e22c9247db64fb6a0ad4b300ca90445c0620844a7a1414eb9919d99b234a26f8f15435fcb29c6f2a4ba39ad5e2b17a59c96fb155655eb4403d6ed555d217a842e9b77f8b709b583625aea96ad9139f582f7dd0680da245ebb1de6170a9f32881f55ac6c9636bf7f06ec7bfb6a5deefc29e04f5e0b807777e44b222b669f6e656e4eda9c64bec749dec9f0afe52e8fab091f1811c558256c3e9b9e24ddd03d84892f8aa24aa6ce62b8b477ae730c1bf2cd48e63522f785465fec2ee103a55a8057740907922f002cdec7876edaef8371c4e6b23fd77c9570dec62db1e5eb243e71e1cb7ac73875707c98fcd2b0d3d5f8912c897cff94febc87da980a764a458bfa399eca54ef87e58e32e500c936f455fd6407158962bb63ae448d79f9c7cfcc4a2c960b9f3b8adeac8a4c2664ce646f99f263b1cc9e05ad857e583c860f6fd04727c8c111da8e2ebb7d18bca30eb8e6605e86bce118d75387f7a41f27666068c5fbd89a4edccbea52ba0c8ba485c6162fa5f6d352b1ea9bce966fe508190948edc3daa2fddb02939bcaa361c420ac94e8b127e4fff46e5c6304bece68891c37b89d0b0cffa58a4337ee6feda2e8029d032902ea5563fce35f39e1a441f394c2590e0b10a2592f95887b5e634a8c2f925f5cd0d690677a4aa0a5f6faef1d812428a108ddc3ea10e13d8186cfc7d397cba996861ba9d33ba7c76d7a691c50a0c848f0a5d559b43fd3331bc43c802901034b0f26770209c388d5ac49240781c588388ce4a5c76a5dadce37c25616073ea460107876709079fc33391042f78b6ea1a35f56a3b7125b960ae7a3d5f572fd780611703d6f6e6331038531f974781cbc92a33a2e8248723c0a6dec3f49674e000d76426e0bb057c0dd26b8e7f633f27a6d654128ee1c8229b6d0c26a890ab245e5c8daf4c07de6f736a25309782cc648d052c093997741644e16aa59518235ec3b2a92858100e2651c33aa57c6207f5895b0fb48d7059f5b6a77419267a7bf6cd9581f1179e2766981f6b48ba1814bee6081b22a175b1a24a24c65609c21c84b941c0dae77fafd20397ec323b921604c5c01dffa60019f6c31f0d104dcde195f3752632eb1080d75180f7ea1c1e71b4087ba48fa8b88d10c269f6d465588e1453a14ac6f92cb7c56f8d46a1803006e979591c93de0d65b966bf0b3e08436c2cc0fc7c7312085f0eb5c830f32858ec8f32d43be603bb82433978aeb23ae29687d9de4ce548df19d0e3c6f2854b1655b971704304804c4e09292b2b5494a53de2b2b446dbd050c108d8a9640b35c37b232951969ce0f4e75ab2e6a9d1687c28a7fb0da79a7aceccfd0dccf98c70fb1f0bf0d366b92d2c2688492d30782057945c07d3c460693b696e237413cdfa93aa00f3ff9a8b07405019a7758b9925fabd411431ce4f616eaa6036ceed227e73ea67e5831e9c5d84afe1ba525fa5dd2f6a9b38f679b026479fda87bc8ddb062ec9f04466735110975bf47599145ff52385e53cc1318a19ff1560b48dc40f0c9b72ad7d6ff3b9cc2aec888e8ac0e71a3660c1e2997ad15063acb3144537470ace0d97214d57ab704a96c380030ab47c03f23887e6cb92c0123c346e3a3e0a45b4e57f622b44076f3639a227ccfd1e727afd9d0820200e636e767d865023098b122f40c186e4879b53a1a65323bcc8070a6a3065c0ae1e6f2089826b1f8332925345c742df67074e19d4cce9d0a52b09ee6a8e659480d343865b3f44978ebc0a4f803b0ad1026355e23af6a83920ec93d3b0b5a1c6ae83272d1a170585e456a2ebd7060e5e5e037340a7b6fa0a938cd2a9a14e6d34c0c86179c07c4b4c5c00c2e3e4e91f87d0608fa35f1875aecbf3ffb3961dec9061f2cf0169a980ad7ab75b2e49e93c8695d85f1fe26bf0bec1fe00988f4eda9529facc415572cbf6fe50e9558feb785e3f84cfabec9d2f8373c73d1f86fc59ba444066340586b031079f825f49031526c7ea18b2e3ff0097b0eacc00b34c49cbf1b2018f2f74443f80f9314541d7735518742c8f7c59ce3a2505da6b07ef17294a62bed889402f4e0e20a0ffbac2b31ff66b30784df26c80e927f8af92db120b15b4d31202e413a8da5d007acd76cd3ae0eb278bbcc934f42b2ac799f79411e146d6631e381cbd110fc0a84b1ae30d1a58d33c377d56a56ebddba53b9551a902676207168dd6d07655f238a8f9cfb08ed8167969d60b788930a2d95994421577f38271257c56b17ddcab47d53f6b30ceb90ce9541377076612f3ffdfab5ad5ea6dbc8f852cb5cad02e617968e3af8b6a07a92d2b53f44fab8a10b32ddcc1a2e05e49796ce28e8cdfc15bc3d59a1e7a0ef286044ff425f4f1c6effa6ed937cecfe43d274b12851ec37a27c2c6da2a98c42b9be9ee5573ae9fe9ca247790a692424e95e746616f7771802efd625907e8bfc5aca1c5e5e513946ed5d923db6d6cd394d73b73154ab73280a56d776163167429313b52673def1510312cefe38ed8ef034428ce5a48a33deb5a813cb5b9ae695de422f4b51afc939ddf16ad47e80cef5889fc5572440771b5567af4a1c1c8bb205c6d757ed9745583ed50ed02e45bba7cec7eb8c91b9d691945726816dc3bb9a4257e13c7be3e112f97169b8f93c080a4b32a0983d3ed1f1f9db11d2946a9a28d57797df393ba5da4a5e3c289183fe7bc101d97e83a80ca446b1a8b33cebbfc063226b79e227e78d5e31a944f90b2cee4d8fa27f9a8674d1f0b10e7e95575bde8b6dd16f3b65a01e80f009f1a5a15f0997a8d702a4511b17d39e479228c7c8363ca93e6c82b554dc114cb4a16726f5cc0181c7d3963f219a411ed91624b44760344b74109362b580c54f6a56142688ca21ab88fed4383493388565cda0df8f4b4ea9b494f49967537dcd6f59e28e3a7d00a1f9375bc66201d1db1c3904156b8ad27d5c4e892a8ed874903b48169062456d2ff880c903c3f78fdec566c4aa735e001c5901bcf8b270e79bfc1ccc3aeca494e94af1a5a979f6ab81aabe4b8307abc0f5ccd0ca05e07798c02719e6140ba1bf42007dd51d885ac4b1f1306bbaca8fca52834279b402697b8bb7b61ce650f17765b66b0f396c48a62f818b67bf2273f42a64030c23414107d93f71fbb2180cd2593d54a4df9fd03842a7be839935a86fbf8a6bb280c60c5c98fc7bc99b30082e638b4c1fee5c85a6ac06ea533a71f55e29ab0feada653f5aa7dfacb8857f0735ce0a8d070e7bbd5bf0b4e945855ef9f8b39aa96daf72fa9a3969a03ca87ba983bb61f4e2946be911c6f76970aa65f15a7551856044ed74788f70d3eab94d5b6346e4620a979718fb78cd3b26421898664ce789379bd118e86f28b526996eb0c7ef09aaec5ce7b2b5c30b6d6c111556e3ef7ebe98aaecc565abc3d2765a197abaff96d9e35b4c745bb34492debc64939a56f885ac20d9db1bb99969c1e4ee0755cd4d936cdef28e61770cc1d917a9625f5907e5110ea1bef6a455289e73d01299fc5ee0bf60e5f3efd3907ff61741a1a34b6cfe53376422cfa061592a022dc1640fb42dafad584d13d3ec03efea470d18955c874e315753ea5d1ba7b0fbb74c3ece745b7ff415823d366cf71007ab7b155c5bd9e2761ba11c70d91990a773c23967e12a9747b8f584dd5aeb13491df2b100e98a243660c472e4ddf3ef41e09941f152cb379a326492d8b61ba5b4c6f61f44cdaf2ed23896257f917eeffd0fe993c93b9289adbae970c9eee8a895b6b0ba559c521792e53cab7697a89ee13aa0debb4556effff2c838d9eead61cdb9e168414aafe0c2f6407e3ccc76334a7bc60f29877c5265b7db2957c1b125bc67789ef54d586f12399ae5e26007ead1eb7083d4c1cfea68d4e23fd31584eb480dd71c00a134d71c7a5e4cee198eee2676f376f91aedafb67956ae84dfb4795178cef36ca859fa8d22acee2f076fd816be4e1acf4c0b5e2db2cdd2d13b9d1b5a447e84a9c74478b20d981159dbc5bc6516e072ef1c3172faa10bbb039182f63eafdfce2bfa834c73ac8ba3b864c82882cfec9c334cb6c6d21f12be36a942f28e41600c515c727eb147aba640ca3cbd6b5a8eccef9aa50b9fb850527b7ed610194fe0ddb2ecff206c7848240ffa6620ec3fdec3f8d35d4dbbb9c2fdf6e801e6c1b9283c592e5adcb31d633efa6e8d5db831113234e1ee9119569e309c80973fb8be151077946f9000fafd5f0c4e3275fac35d36710569452565c41ec2b0a007da66d30c527ac06ab8954645176e58c5f8dec2697438823b7384f978273bdb5d1b980de23301f5dcf2eebc45d20b0e5fdfbb7630b3e27d390cbd4b6eff74bc7dfbec6097076a8d1dc03d16681b44793f55413db632af11f767e0ebd56cb2c9d486c76eee2a34a8e99f75beac7d672399ed792da036db26ec48db4d3d1dde762aed4ccbb408bb39430e42fe770bc22b96ee7c0a809b79476031374399c33ac1ec5a0ef4e715b95321687514debc35ae6962b5ec6c43018452c67e2b6fa2d25dd74b5f0b4d6b4c8a441d12bc679a1696d74a6c56d283b444e6053dd4fe4ecf8579358c3fb0611bb859c6c131c2c377733d11fcbd81bbc40f59e753e37561cdc0bf2b50927a5b437523ed03de501a6478762dd3eade02a53cd18c8d5657b8b7c17575452099b701bc31f413a9be6ea2340d6e5b7f101f7eb65787899b588afc94cca53af779d2225705ca2510ecc5e913ff6465e03644465c86e66833b83125363c443e45f2d6b4d2b0fef0963f27eed9ec5515fa739463092a1dc36763e0e637d068cf5bb9a0ffd21f786d6fdd81c6417f0f812892b3554e3c248c12b380fab92a2e3fa37ffefb248cf14734449d4c885c3a4b79e733f47cd33cbebd422d24067e32954cf6ac1b0c72edc950462837753462bb1fc1e3996ef7279d9665bef72b8238c1adfa1abdb9cb36ed35e7de76a42f934c9a213b522c624b11e8f0dc5ef988beadf599abed5a3c9bca498d916644dc780b8b436079c27c8f87a23bf04aab9ed8e44d88b9e3c73eefe14f05df8f25058aea155654befa83f869a8cc7d5fcc0b0423f5210e3c68bac0c7dc4997c7f5eaa6a49014d198601e21ab7d86cce66cd0c2d06ba238962038b91630ca088913ae11953b2fe4f073fb321938302370fe0e54c470d1798f97c1abecf6fe1902658d19ffcc66baf125ef0f31490c809855f4987b4b993e2d68f26930fc50804abcd44eaa36b74b61bc43ac6387e89d882b27d681f89212e0494e16b69375074b391457353a7c61db926c08531db50fa3d14477231d44cb9fd8a56c8c975fe76a0f05fb2c25813b52d703d5a0aec986edc2434f95a0f2a416cca88d19ab2d6144b69f8155a9a859f2a860b242c0703bacd43ccd62cf8792d3f88d158b627cbf9af84352332735aa4bb89a9563b5dae952257a104e7cf4ff6a62829ffcff3ce10123a86b7a2111c25ef47e42075dccaa2e018b25cadd17619cba3252ef42c919ac0c477798072298262459a17d440ea787467b679d9cc4c3d7535fd1df6a3da589f754359e75a4af11bb8b7e7dfa12ce925929a482fb1100e4d18de5abd077b4d2aa544024b936dc2c9f81c0cf0d5dfe1734c468bd68a54af7da8ce38a1a8a8ccea901efad9444182a6be860dbbf37087a3eab365918c893ddd57266fc86dd3d21345efbfeeaec5234ef58193f71143267baa075a1c62e9ebe9a04b27fdf11ce33a2f796ccb5c5cbe570451c6cfe6d95c74db6f90806291883c7b043c51724f5310957fe4bbd0b1496e278e6ad15ae9c9f71365a61170af73a5ffe821b076f083f1363972a748720b20784d13e7977ded666d59d1440af1dfa336a16d6bb9196f292352ddc26caae5a4ce0e58db4bdf3c1a8fe953dd8d1a723f606f1e0552d0e96f3771ac9308aba00934a72194dc7b66f4001e1ec70b746a4dde65b2ccb7f99200ab030d164d98562d0df4dbd5191563eba3513f9df66363ab196945bf55f75ac3705a8d079dc5a1e02904aace56dbeff26873bc2baa2e937f75fbbfb79a0cab0533ff9a2f87fc375f1c9cfa3cb2f0410cc0a503651122a922475fc5ed87497501f345e19ef58a793735dd60ca1ec5a99b706614f3642da0cf22e350f597589581b9a6bf138e727e112f632916dbce3e92b49045bba57e0652ab7ed9ca6838e2edce8630779abd5bae38a800b661b938fc517060a03bfdfae44a45d1022fe558966c8352a53d1226ceb880c52481f30b24101f29cb5ee3811af821575f4c5a798ad514515fcc76caa7625aa0c635578a12d6597420c2ee38dcc0d0864882562766be00c5e32e698cb9494c098ebebd066dd14a13e67865ac0bdddd07c8fa86c185e377302a0115a95d1966c931572bea4d24559aee3ca7328372880ad6616cdb586d202b50d779e1a2f8dda7dad946e21caee1edf7ca9dab97cc40081da5ef0e6921a46a2ae61c45c3466664e83a13780329e6ccbfe53b2ff6cd928aa442769fd350ca89ed261f30e20ddd5d3abd8e31fd082b203c2a2f2aa54ada9e7d2f20fced0ee91ccd66192e214aaa22e452b43f7a086ca9ba6b6d5dc576eac5504bd825ecb0038c5ce1ad83aadec6c1de6938b209d1833267ddb1a40b9363c57f6e3419b54d668e6c4f157ad3410aa5066c1140be4c201ba712021e50994a097266b0962372c3fa17e21d841244c95372e515b5d2ad28c39c4b23caf6bc137d4a6a0cbc5dd0372681e3f042a474431e54f635b103166abce489d7c7198fbeb48a32391936b5ca6f9695e7c611de72f9a322a02cf15e9f56857b89c69c477cd079672fcfe32b7824803dc3ba437ece346d1ac3ad4a08d1c35c24eacff6e5bd2b9e5018308ab2be349e6985b43abce2c9e29fa40b27c496c3b418894a07499a5148625fb1524e5d8cad5dce848c9116c3ae544c6265405db1de37c106391bd5d9aef17ab9f9030ae5f2b58a8e7a8589a8ae08ec0e4c0b71755d7b03d09fdf5539bafbdb4786fc876403e03731fee5cd5dd11952235b02e135b8a5c11a562bb166a4cc524dccecd135cc855af36b884f6ed2b5a478f60a528794b3ca344d90cfde85f6fd233fa4b3f14b7ecc5b7b3e13776202faefa060d419c09fe5118a49dd61a2a25a2b7116ae24981a611dfb51b3a03a6316e7db24e50ca5a017f353e8d48d42e277a21c5f363729f1a2d2413adea87bfad95ac89b487aac50733d70b0c51710eec8fea01ce3563df2ac2d8220eeeefac2284fb452438bd182050626d1ab5263f62c1e126b6121c56d0bf7ee06e6b36d42437052fe2e989689f49060ca0b920ccd59540410e932975e1f15ec2cae86564f7bcd939db91f9ed79af7a287a207cf090f5ac7ae1d890662696d2e6c44e02494e3fb0c31bf7e5755ff01fca26361e0165f9db8781a297fd9dfb9141eabb4369f7fd00dd26fa0aa3d40244c061e1598bebf92d696ade390b6a593b707fc04d0286a0ba9b115f36fdf22ab45a0a3df41ff3dbbde815eba0383d86c59b0e4ac38611fc48ea8c38a49a44aa31f937eef7a81c021ae7d0d2cd02ae18f70c2e21434a04d271549ebef7618202b32dcf117ba278c1cb252411a6d9895471fc294c0b1bfc4ce1445df1ca492cb79d7a669451e9ee2eed6b5d7406ba7c0c0b42929f7c00f476b87506cf7caec1f7a13ddf8974e7123d8dd8bc2cdb0816ff570f4a4508b38652ab874d188595a281be6e7f42e19efe4f4c7ce4d3ddb0e2ba0a2f1d71f4e26bc641ed92cf8978116bd355ab04dae78779017af72ed27e7f341ab9915ff6805e59c047f11c42b32c31cff974cd1ca2cc9d750f7aa6ddea205b2d43711092152a78c4112e0ad851259c1497ae8f861ef4d14af359dd9e1b6a58660d26fc3110d973ee174248dd5df76f8d0749f0b11d77ce84d1189749b85445eb3d57fbf450cc6ce024516b51cce7bb4896bb798ca056b870e6c211e7b02b0ed0003c842ec183cc8c0fa2e9df32734b1ba66d42357ed072cebe59f80bcb234c0b37c50cb92c39522c3c2ed54a8554e6547f8ece6cb1cb5b15d041cdc23ba294fca43bb83d74300b3ff5610f52a50af0c63cdd0511d45683664c59fa62b572e68b27c20fdb9d5c4f589a01d7ae865adfda56cf80e8bb8d15425a2489ea14ce673e57c69f198cb609bd31aa595c8f092591de7de62bebc76477078cd941e0fce697df0114ad8296704832e73321e8a074a07d50eec3d51e1408adfd21a8a64ca54d2cbd87d60ff69f413b04be6810ffb8dc7d01598f95e325896cb613a475a54f0dc34e72c0ad32c7ca8f20c8f9b5a36ea583062a282ec944b42253fb50faab6a00342afaed1ea714e3476230728a828e61f23882225841be6ef2ad29797f1054778e9afbf2a93b0314a732e9297b948585e9bb43613f0b47ce0fb702820d05330878c2da4b4ef0b77756ab9882dc1c8ef991364d8365cb5f1241c3391e38e5076e1142b19374ca93610ffcbc35ce2dd47c27763e19237a8a7176a3dfa5056a29d55dccc0631687465329b30cfd222571c7268c5b5612e1ce21b8b6c9cd08c40d2e9a10efa523573c1d37e0207652cf8d6c34e46200a46a2a285ac29985d38f0e73a213f6db1306601063597a702578c1d0066e8a18ee47c50ae7e7d5088a3a961b2185b106b37ac4820c2126eaac10769e9750f30e1e18d3372508fd9e29e1e7aa2d9ff46c9796648bf4b742f33b627af1e3c7583e6ad9b8ecf4fc70cfccf64843ac685d898e6b337c5ae48b95004186f814fd175c053fd090b54278f31c1ecbfd32902374d9cc8dca67e940e576f6f69eb3271892f4c454dd006b880beca5c66e58c553033d83433a26f2cfa6339a8893ec7168d0bbe8cff549ec5b6d19720202e331d163c2a825818263e6445573aee326f15b62bdf37c181544175aee0fe54482db83394055b30269939d2e13e1d67a8826e326e1baea47c4cd1461c41e27aed1d0d4ea2c728c5662565bae03ba19163909efeaa9c2ad1edcb46e6fe6a87b2a335fe32336e76e41d9dae86a6d87a6ee611e82dd23f2ba9ecf553412c5b61a2f08f25cf94c46ba58b83494fe4a6be9eb82022c50242eaf2d745cceaf2ad3a4886f81ee381dd27fdc519d109c3f4ba6da6f8443d46bf37e646fa5403969cda315a43cda7cd011a06c7152408be5140719c535ae458d2c8406260709e66fa35b27f4b25841af4deebc39cd7cf0152030521faca92f59a380ba3add9cb99d4f9cf9ee9547935a8823b094417566f297edd70105043f267389643a6dc1395281ba4d15fa050819b89c89a7518c48ff8eb4e42f128c300ff8318ecce7a8e1e9b5c6ee685f60bef37060b80bb73d96f97337cb7681d3f7f4b891bc5c976661d370b284cea191b18dca48070a239afe50fb5a11e3e4629d150ba8b3e9be56153124980194279f352b7fd89947d2eafdacb14e30db5e62ce55efe2fecfd70fc6ff1fd4a1d6bbd135994dea01993de4d18228e9d56dba08312a06bee5e93b6fc0ca7755f6374b30a2999e6d9792031a8bf77ecb187a41624f781362c6cbe4206fa29f6faf92553a3379c60ef3efed8b3d84cfea380be8c5c48f727eaaeae7d7410c72ea7b3a81c1c86c687252f3e9811dd845cb642d426e1322e8a5f1c0d688ef9abc6bbf33abd94c72a4d27a56950dcfc63b957c914f0afd701862a51cfbc64698e6c31d5c5f2d54758f33c4226f79dbf43175167b832180ab20e920401e1e907d317b7d778376014a9b2d158e78cfa0d598612364dc901f4b40e015e503edbde81e1ce568e7c699e9dec14bca3eb52f5f58e9d63b3ff9310bac09dbcb48bc76c9d5c1d9226036fbfc656a5be8841f44d4e5ff4bcd08a3a38749944b2b1b6f9cb3ae388f3813c0226c03c9e39307b2005dbfafe85e9ed4b5b22f2e7cb1e155792bae15545d60c1aa2da0d95580c4cb9413ee5aa2145583edfcaa013994a7d29a99e1973ac3449fce3b81cb4338bc69285cea390d3866f5bd19bc9c1d1616dff82709f4218f0ceb21dbd58c395d9d163bf84a5d80807383f6c3dc617509b251bf07c3d13af8192cc96801fc20e28a5e302f7065a4fa99bdbdeb2c811b04c3b390f536ffc902f438367d318f6107d00ea60bfa6ff14f34aa4f4cfe4a08c7176b5ad177b53378a5208446d576add13bd5cb43e9420531e7f4bdb3eb2827b4aa4ab29218725a380140407bc69a36e3668dc8d5a24bb6e9de39d671b965059c31c799c8c9e8882c7d6f563aa18631866232cb46e6248644167a329a470f56cb37869ec36d3fe0cad8f88ac9114d6f679f25dabe9665458d67f4b4717a056a7a8c5dfd54cba8f77095d743bed10752834b99dfb4e84945ceaf355240266ef0ddd96cb7148cf7f30bb2e286d1951243650b112fe90a6f99c3b870919ad3a25789005c4ecdb5742031ac695cf8a9bf96760e23edfcc161b8f7606b7ca5a7018489fa933842c5cae83554e0b8914d25ee9dbbb0db5a3fab43efbbe5af719ec7c0732da512cc2ccd405c31aedda851afacea92529bd300933abb8b9880ea0ca87e82eb3b4befc8cb54ea052f51d335653cd2c8885fc045b19e0e584ebf1e3d5dfb9d570225c99109d51995057775eab67dcade36f860be2acd6465ce2b1ac8938e6e1344b56a66aa33effed1edf03b8c09a43fc10d237a18a4e09689ed2a69202f2a6b9163b74e0b8688ae7cf6005dc65f449b3ac7f12e0643778c511254fe45a50d6204ef1e267da9dd914ed65de968d2672fe896eb1e6216c68e476d57839ddb30d66e353b57528b8e9709840c9c35e8f365f2dbaf110892cd87d334b5f8be0105bf334a4d6dd0c7159ba751bdb178f668d02a9d1d0d0415128984d175f824ce51115671a5e0120469800e16d443a0828833d49f23833629db424acc6a64830b68120aca6175422c6cf5b229f5494012e634db517857def820640757e61e827db605fa4e7cce4b8805a5cf7d64a2fdd301d2a87c74b557674ca846e02677633f28eb58383eddf10b5f6105009f3d567d8f6d0a50046c5852174aba3c167da0450d1a971fed760ae55c43c7291f19b7dbb9c9124a1ba81708782ffed2ce798171ccf7d61552edb83e454b460ac0813146f0501522bfbb6923d1f899655b5a963676dcd2bc2ea7d92a86a2e4326c9f0db3be449acda6b659aac1e5f2fa01a57722bc4604b05caabefc1bde10bb81e94a1862200c2027b24a7a84729250e6b18427160d89b679a7abd66689e0efdff654811a03ef9b0ed28ee9331753cd9bc19593d493020bd8a9d713ebb0fb78c2a5d7a366aae619f1c6ac383acfe0c800a0b31b2fc5e1ce4d8d543be5a192107b59fb1763fe3986441d8e77cee5cf96dbf9872a06ae6cab4c833e077892099d2c765ef099156bcebec28f0a7bb37cb010dc318589ee5b4f802030d5197f234826bb5a76c47f770774569776b27f0a32382f047a88c995dccb34466ac97861b917b0d94b62a85ad3b2fc4cca15bf1e4e995dc5854b50c9f28aafd8fea483107e87761cee84c4305ee6267f3ea6cca973329101bc35f1822a8c4046e0da3bee66d15dc8a8af03ca50fb1b8e81c254990ad0339015da8cb3ceb065898c5992af6592baa7dc2d026c1b6fbfe48e7bf2cd53df2d9cdf3d9808ad264e86178dd7df09217eb9034fb5b0f8d747f7d1b7f26c11bbcc72be51c92765fbecaf7eee8740c9f7ba2e0ddc6e0922e5ee45cce42a1289e4dd9c59e701ca049dc7c89ee7f12b7b5d29beb622df88f21d8b908b96edb0baf7cd14e4447f46288a38ea0c065199c09f1ac5084608c6c3c60f8dabe3d311ab0f91aac23937140852779bbda8983a4f6eaea75a6fc4cb215e7e33b6611eb1759fc4de3b3e1585c1c1bacc1a53c737cfede1690569b3b07c604914fe0d9ebf9318cc99c2db87310ed141be2cd8b948799c82606bbdd8a3d26b0dcf4ada8d0c5d4be8c69e492845679464818b8401dd5fb5173b33d7c68423331a5bc221ce278a406cc22f87cfda9c021801ae8cd87107166ee403721d4f47f0f2a1a4eee591788fcc01da4748fae098f2adc3c6ca113726b1c53b7c45949780509d219b12f5b254eaa3c4295427849cc8abfaee249662aba8096c9a61dceac1c8060148d337c74c31978a82be7622a793e9fd49e33acf0967731fd3abc56efac6d27bc18fac40f484290d26fb062cb5870ecd539c92b288cede90d05a57aefa5427224099719ee88aee176b24c8507508fd4505279719dc4a7502dbc9998d2395a489fd857be28077cc7bceeb1e1754213f90cdbb22725a9342d1ede7d3634a5efd5e9dc58f131d775c437062e30b6527b54475cefd40102593bd586e5d4b4e6abc7b358cb6b4b49366d929ca1b4e4c98fae94574d16ed84249f8d8f23c3c1c916dbe9bc3b5a9afb6acd23f3f7847856aaf0e4d345800fda8ef2fd0a6f040338ba15fdec32c54742ec3223e12e5ec3da201c6df80464858b4748ed72ad246219c57ddee4d16b281b775284fcb7c08c984582de9afd5a13e5e9dc3f9de97f7a31b1d233c11614cfe0d71e26b4a97ae177d118941aa7d9880dd74630b96590ad477339b60912c99788ee8f1fdd804785f40f5a094e6e79ebbbb7c0992765074c9fbe1084cc83a3b6225f8e3f15e4207677ec6731d3fa5a849be48
  
    
      
      
        密码是“12345678”
      
    
  

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/02/18/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/" title="Hexo-butterfly">Hexo-butterfly</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-18T07:32:33.000Z" title="发表于 2021-02-18 15:32:33">2021-02-18</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.971Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E8%AE%B0%E5%BD%95/">记录</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E5%8D%9A%E5%AE%A2/">博客</a></span></div><div class="content">
个人博客搭建 Hexo一、创建博客
先安装 git 和 node.js


然后在你要保持博客的路径下执行下面命令

1234$ npm install -g hexo-cli   # 安装hexo$ hexo init &lt;folder&gt;		# 安装博客$ cd &lt;folder&gt;				# 进入到安装博客的路径$ npm install				# 安装npm



然后进入到 xiaofanBlog/ 修改文件





然后执行命令
12&gt;$ npm install hexo-deployer-git --save&gt;$ hexo d


如果不行重新输入 hexo d


上面就已经上传到了github仓库了
下面就是怎么修改主题



如果你没有设置 git 的邮箱和用户名则在
hexo d 时会出现下面提示
只需要设置邮箱和用户名即可


二、修改主题从 hexo主题 官网下载主题，直接 git clone 即可
然后就是把主题放到博客文件夹 themes里面，重命名
然后在 _config.yml 中修改主题（注意名称要和 themes 里面的主题文件夹一致）

保存之后用重新部署一下如图


如果出现了下面这个问题


解决方案输入下面命令
1$ npm install hexo-renderer-pug hexo-renderer-stylus --save
清理缓存代码
1$ hexo clean

三、主题美化标签页1$ hexo n page tags
12345678然后找到	source/tags/index.md文件修改为---title: 標籤date: 2018-01-05 00:00:00 # 不动type: &quot;tags&quot;top_img: # 图片---


分类页1$ hexo n page categories
1234567同样找到	source/categories/index.md文件修改为---title: 分類date: 2018-01-05 00:00:00type: &quot;categories&quot;---
代码主题和能否Copy123456# 主题配置文件highlight_theme: pale night #  darker / pale night / light / ocean / mac / mac light / falsehighlight_copy: true # 能否复制highlight_lang: true # show the code languagehighlight_shrink: false # true 全部代碼框不展開，需点击&gt;打開false 代碼狂展開，有&gt;點擊按鈕 none 不顯示&gt;按鈕code_word_wrap: false # 代码换行
主页标签页等图片设置1234567891011121314151617181920212223242526// 主题配置文件# Disable all banner imagedisable_top_img: false # 显示顶部图为 false# 顶部图index_img: /img/背景.jpg# 默认的top_img，当页面的top_img 没有配置时，会显示default_top_imgdefault_top_img:# 归档页面的top_imgarchive_img:# tag 子页面的默认top_imgtag_img:# tag 子页面的top_img，可配置每个 tag 的 top_img#  - tag name: xxxxxtag_per_img:# category 子页面的默认top_imgcategory_img:# category 子页面的top_img，可配置每个category 的top_img#  - category name: xxxxxcategory_per_img:
文章图片设置123456789101112# 主题配置文件cover:  # display the cover or not (是否顯示文章封面)  index_enable: true # 在主页  aside_enable: true # 在文章页  archives_enable: true  # the position of cover in home page (封面顯示的位置)  # left/right/both  position: left # 图片在左边  # When cover is not set, the default cover is displayed (當沒有設置cover時，默認的封面顯示)  default_cover:    #- https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg
文章在主页展示的字数12345# 主题配置文件index_post_content:  method: 3  length: 200 # 预览多少。0 就没有了
如200

文章置顶
直接在文章的front-matter区域里添加sticky: 1属性来把这篇文章置顶。数值越大，置顶的优先级越大。

文章主页和阅读页显示1234567891011121314// 主题配置post_meta:  page: # Home Page    date_type: both # created or updated or both 主頁文章日期是創建日或者更新日或都顯示    date_format: date # date/relative 顯示日期還是相對日期    categories: true # true or false 主頁是否顯示分類    tags: true # true or false 主頁是否顯示標籤    label: true # true or false 顯示描述性文字  post:    date_type: both # created or updated or both 文章頁日期是創建日或者更新日或都顯示    date_format: date # date/relative 顯示日期還是相對日期    categories: true # true or false 文章頁是否顯示分類    tags: true # true or false 文章頁是否顯示標籤    label: true # true or false 顯示描述性文字


文章阅读页显示目录123456# 主题配置文件# toc (目錄)toc:  enable: true  number: true  style_simple: false


特定文章也可以设定是否显示目录
在文章头部添加
toc_number和toc，配置为 true 和 false

相关文章
相关文章推荐的原理是根据文章tags的比重来推荐

1234567# 主题配置文件# Related Articlesrelated_post:  enable: true  limit: 5 # 篇数  date_type: created # or created or updated 文章日期顯示創建日或者更新日


文章描点
开启文章锚点后，当你在文章页进行滚动时，文章链接会根据标题ID进行替换(注意:每替换一次，会留下一个历史记录。所以如果一篇文章有很多锚点的话，网页的历史记录会很多。)

1234# 主题配置文件# anchor# when you scroll in post, the URL will update according to header id.anchor: true


文章编辑按钮
在文章标题旁边显示一个编辑按钮，点击会跳转到对应的链接去。

12345678# 主题配置文件# Post edit# Easily browse and edit blog source code online.post_edit:  enable: true  # url: https://github.com/755400668/755400668.github/edit/main/source/  # For example: https://github.com/jerryc127/butterfly.js.org/edit/main/source/  url: https://github.com/755400668/755400668.github/edit/main/source/


文章版权123456# post_copyright:  enable: true  decode: true # 显示中文网址  license: CC BY-NC-SA 4.0  license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/
如果想要某偏文章不显示版权，在文章标题添加copyright: false 即可

文章打赏1234567891011# 主题配置文件# Sponsor/rewardreward:  enable: true  QR_code:    - img: /img/wechat.jpg      link:      text: wechat    - img: /img/alipay.jpg      link:      text: alipay


头像12345# 主题配置文件# Avatar (頭像)avatar:  img: /img/wechat.gif  effect: false # 转圈


网站内容是否可以复制12345678# 主题配置文件# copy settings# copyright: Add the copyright information after copied content (複製的內容後面加上版權信息)copy:  enable: true  copyright:    enable: true    limit_count: 500

页脚设置123456789# 主题配置文件# Footer Settings# --------------------------------------footer:  owner:    enable: true    since: 2021  custom_text: 愿世间美好与你环环相扣  copyright: true # Copyright of theme and framework


夜间模式1234567891011# 主题配置文件# dark modedarkmode:  enable: true  # Toggle Button to switch dark/light mode  button: true  # Switch dark/light mode automatically (自動切換 dark mode和 light mode)  # autoChangeMode: 1  Following System Settings, if the system doesn&#x27;t support dark mode, it will switch dark mode between 6 pm to 6 am  # autoChangeMode: 2  Switch dark mode between 6 pm to 6 am  # autoChangeMode: false  autoChangeMode: 1

阅读模式123# 主题配置文件# Read Mode (閲讀模式)readmode: true




字体大小1234# 主题配置文件# Bottom right button (右下角按鈕)# Change font sizechange_font_size: true


访问人数12345678# 主题配置文件# busuanzi count for PV / UV in site# 訪問人數busuanzi:  site_uv: true  site_pv: true  page_pv: true


侧边栏1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# 主题配置文件# aside (側邊欄)# --------------------------------------aside:  enable: true  hide: false  button: true  mobile: true # display on mobile  position: right # 右边显示  # 头像卡片  card_author:    enable: true    description:    button:      enable: true      icon: fab fa-github      text: Github      link: https://github.com/755400668  # 公告卡片  card_announcement:    enable: true    content: 欢迎来到灰灰爱吃小云朵的博客  card_recent_post:    enable: true    limit: 5 # if set 0 will show all    sort: date # date or updated    sort_order: # Don&#x27;t modify the setting unless you know how it works  # 分类卡片  card_categories:    enable: true    limit: 8 # if set 0 will show all    expand: none # none/true/false    sort_order: # Don&#x27;t modify the setting unless you know how it works  # 标签卡片  card_tags:    enable: true    limit: 40 # if set 0 will show all    color: true    sort_order: # Don&#x27;t modify the setting unless you know how it works  card_archives:    enable: true    type: monthly # yearly or monthly    format: MMMM YYYY # eg: YYYY年MM月    order: -1 # Sort of order. 1, asc for ascending; -1, desc for descending    limit: 8 # if set 0 will show all    sort_order: # Don&#x27;t modify the setting unless you know how it works  card_webinfo:    enable: false    post_count: true    last_push_date: true    sort_order: # Don&#x27;t modify the setting unless you know how it works


访问人数1234567# 主题配置文件# busuanzi count for PV / UV in site# 訪問人數busuanzi:  site_uv: true  site_pv: true  page_pv: true


网站运行时间123456# 主题配置文件# Time difference between publish date and now (網頁運行時間)# Formal: Month/Day/Year Time or Year/Month/Day Timeruntimeshow:  enable: true  publish_date: 02/18/2021


Tag-hide


评论1234567891011121314# 主题配置文件# gitalk# https://github.com/gitalk/gitalkgitalk:  client_id: aa776ef94071498f6753  client_secret: 1cbad93b480c8980863bbfcf1fd8926c2fdd9863  repo: 755400668.github.io  owner: 755400668  admin: 755400668  language: zh-CN # en, zh-CN, zh-TW, es-ES, fr, ru  perPage: 10 # Pagination size, with maximum 100.  distractionFreeMode: false # Facebook-like distraction free mode.  pagerDirection: last # Comment sorting direction, available values are last and first.  createIssueManually: false # Gitalk will create a corresponding github issue for your every single page automatically


搜索先安装
1npm install hexo-generator-search --save
然后主题配置文件
123# Local searchlocal_search:  enable: true


UI颜色123456789101112131415# 主题配置文件# theme_color:  enable: true  main: &quot;#49B1F5&quot;  paginator: &quot;#00c4b6&quot;  button_hover: &quot;#FF7242&quot;  text_selection: &quot;#00c4b6&quot;  link_color: &quot;#99a9bf&quot;  meta_color: &quot;#858585&quot;  hr_color: &quot;#A4D8FA&quot;  code_foreground: &quot;#F47466&quot;  code_background: &quot;rgba(27, 31, 35, .05)&quot;  toc_color: &quot;#00c4b6&quot;  blockquote_padding_color: &quot;#49b1f5&quot;  blockquote_background_color: &quot;#49b1f5&quot;


图片加载动画123456# 主题配置文件# Lazyload (圖片懶加載)# https://github.com/verlok/lazyloadlazyload:  enable: true  post: /img/loading1.gif




网站背景12345678# 主题配置文件# Website Background (設置網站背景)# can set it to color or image (可設置圖片 或者 顔色)# The formal of image: url(http://xxxxxx.com/xxx.jpg)background:# 页脚显示和首页一样footer_bg: true


鼠标聚集几何图形12345678910# 主题配置文件# canvas_nest# https://github.com/hustcc/canvas-nest.jscanvas_nest:  enable: true  color: &#x27;0,0,255&#x27; #color of lines, default: &#x27;0,0,0&#x27;; RGB values: (R,G,B).(note: use &#x27;,&#x27; to separate.)  opacity: 0.7 # the opacity of line (0~1), default: 0.5.  zIndex: -1 # z-index property of the background, default: -1.  count: 199 # the number of lines, default: 99.  mobile: true


鼠标点击效果12345# 主题配置# Mouse click effects: Heart symbol (鼠標點擊效果: 愛心)click_heart:  enable: true  mobile: true


页面美化12345678910111213# 主题配置# Default display mode (網站默認的顯示模式)# light (default) / darkdisplay_mode: light# Beautify (美化頁面顯示)beautify:  enable: true  # post 只在文章頁生效  # site 在全站生效  field: sist # site/post  title-prefix-icon: &#x27;\f0c1&#x27;  title-prefix-icon-color: &#x27;#F47466&#x27;


主页打字123456789101112131415161718192021# 主题配置# the subtitle on homepage (主頁subtitle)subtitle:  enable: true  # Typewriter Effect (打字效果)  effect: true  # loop (循環打字)  loop: true  # source調用第三方服務  #source: true # 關閉調用  source: 1 # 調用搏天api的隨機語錄（簡體）  # source: 2  調用一言網的一句話（簡體）  # source: 3  調用一句網（簡體）  # source: 4  調用今日詩詞（簡體）  # subtitle 會先顯示 source , 再顯示 sub 的內容  #source: false  # 如果有英文逗號&#x27; , &#x27;,請使用轉義字元 &amp;#44;  # 如果有英文雙引號&#x27; &quot; &#x27;,請使用轉義字元 &amp;quot;  # 開頭不允許轉義字元，如需要，請把整個句子用雙引號包住  # 如果關閉打字效果，subtitle只會顯示sub的第一行文字  sub: 


PWA1npm install hexo-offline --save




字数统计1npm install hexo-wordcount --save
1234567# 主题配置# wordcount (字數統計)wordcount:  enable: true  post_wordcount: true  min2read: true  total_wordcount: true


图片放大模式123456789101112# 主题配置# Lightbox (圖片大圖查看模式)# --------------------------------------# You can only choose one, or neither (只能選擇一個 或者 兩個都不選)# medium-zoom# https://github.com/francoischalifour/medium-zoommedium_zoom: false# fancybox# http://fancyapps.com/fancybox/3/fancybox: true


弹窗12345678910# 主题配置# Snackbar (Toast Notification 彈窗)# https://github.com/polonel/SnackBar# position 彈窗位置# 可選 top-left / top-center / top-right / bottom-left / bottom-center / bottom-rightsnackbar:  enable: true  position: bottom-left  bg_light: &#x27;#ffc0cb&#x27; # The background color of Toast Notification in light mode  bg_dark: &#x27;#121212&#x27; # The background color of Toast Notification in dark mode


修改背景
引入一个新的 CSS 文件

使用 js 文件
 但是会在一定程度上延缓网页的加载时间，且修改复杂


下面使用第一种方案

\themes\hexo-theme-butterfly\source\css 目录下新建 background.css 

或者你可以在 css 目录下创建一个自己写的新文件夹如（mycss），然后在该目录下创建background.css 


编辑 butterfly 主题的背景 div 的 id 是 web_bg 

修改为图片
1234567891011121314#web_bg &#123;  /* 背景图像的地址（url括号里）  */  background: url();  /* 背景图像不重复 */  background-repeat: no-repeat;  /* 背景图像大小 */  background-size: cover;&#125;# 关于 background 更多用法：https://developer.mozilla.org/zh-CN/docs/Web/CSS/background# 关于 background-repeat 更多用法：https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-repeat# 关于 background-size 更多用法：https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size
修改为渐变背景（如下几种）
1234567891011# 蓝红色渐变#web_bg &#123;  &#x2F;* webkit内核 5.1 - 6.0 *&#x2F;  background: -webkit-linear-gradient(left, red, blue);  &#x2F;* Opera 11.1 - 12.0 *&#x2F;  background: -o-linear-gradient(right, red, blue);  &#x2F;* Firefox 3.6 - 15 *&#x2F;  background: -moz-linear-gradient(right, red, blue);  &#x2F;* 标准的语法 *&#x2F;  background: linear-gradient(to right, red, blue);&#125;
123#web_bg &#123;    background: linear-gradient(102.7deg,#fddaff 8.2%,#dfadfc 19.6%,#adcdfc 36.8%,#adfcf4 73.2%,#caf8d0 90.9%);&#125;
1234# 紫蓝色渐变#web_bg &#123;    background: linear-gradient(to right bottom, rgb(0, 255, 240), rgb(92, 159, 247) 40%, rgb(211, 34, 255) 80%);&#125;
1234# 图片滤镜渐变#web_bg&#123;    background-image: url(&quot;https://ae01.alicdn.com/kf/H18a4b998752a4ae68b8e85d432a5aef0l.png&quot;), linear-gradient(60deg, rgba(255, 165, 150, 0.5) 5%, rgba(0, 228, 255, 0.35)), url(&quot;https://ae01.alicdn.com/kf/H21b5f6b8496141a1979a33666e1074d9x.jpg&quot;);&#125;

更多的渐变网址
https://webgradients.com/
https://www.grabient.com/




最后将文件引入
 123456789# 主题配置文件# Inject# Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)# 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前inject:  head:    - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/mycss/background.css&quot;&gt;  bottom:    # - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;
 



如果没有生效的话修改如下
12345&gt;# 主题配置文件&gt;# Website Background (設置網站背景)&gt;# can set it to color or image (可設置圖片 或者 顔色)&gt;# The formal of image: url(http://xxxxxx.com/xxx.jpg)&gt;background: &quot;#efefef&quot;



修改页脚
同样的和上面修改背景一样，新建一个css文件如我的



下面在某博主上面看到两种样式


渐变
  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/* 页脚footer *//* 渐变色滚动动画 */@-webkit-keyframes Gradient &#123;    0% &#123;        background-position: 0 50%;    &#125;    50% &#123;        background-position: 100% 50%;    &#125;    100% &#123;        background-position: 0 50%;    &#125;&#125;@-moz-keyframes Gradient &#123;    0% &#123;        background-position: 0 50%;    &#125;    50% &#123;        background-position: 100% 50%;    &#125;    100% &#123;        background-position: 0 50%;    &#125;&#125;@keyframes Gradient &#123;    0% &#123;        background-position: 0 50%;    &#125;    50% &#123;        background-position: 100% 50%;    &#125;    100% &#123;        background-position: 0 50%;    &#125;&#125;#footer &#123;    background: linear-gradient(-45deg, #ee7752, #ce3e75, #23a6d5, #23d5ab);    background-size: 400% 400%;    -webkit-animation: Gradient 10s ease infinite;    -moz-animation: Gradient 10s ease infinite;    animation: Gradient 10s ease infinite;    -o-user-select: none;    -ms-user-select: none;    -webkit-user-select: none;    -moz-user-select: none;    user-select: none;    border-top-left-radius: 10px;    border-top-right-radius: 10px;&#125;#footer:before &#123;    background-color: rgba(0, 0, 0, 0);&#125;
半透明
  12345678910111213141516171819#footer &#123;    background: rgba(255,255,255,.15);    color: #000;    border-top-right-radius: 20px;    border-top-left-radius: 20px;    backdrop-filter: saturate(100%) blur(5px)&#125;#footer::before &#123;    background: rgba(255,255,255,.15)&#125;#footer #footer-wrap &#123;    color: var(--font-color);&#125;#footer #footer-wrap a &#123;    color: var(--font-color);&#125;

然后引入即可




手机侧边栏默认不展开
新建 js 文件即可，然后引入



123456789var mobile_sidebar_menus = document.getElementById(&quot;mobile-sidebar-menus&quot;);var menus_item_child = mobile_sidebar_menus.getElementsByClassName(    &quot;menus_item_child&quot;);var menus_expand = mobile_sidebar_menus.getElementsByClassName(&quot;menus-expand&quot;);for (var i = 0; i &lt; menus_item_child.length; i++) &#123;    menus_item_child[i].style.display = &quot;none&quot;;    menus_expand[i].className += &quot; menus-closed&quot;;&#125;


加入clustrmaps访问者地图

clustrmaps.com
注册账号或直接登录



填写你的网址然后会看到代码，一种是JS一种是HTML的，这里我选用HTML的

先在主题配置文件加入
1card_maps: true

然后在 
themes\hexo-theme-butterfly\layout\includes\widget
路径下创建一个文件 如 card_maps.pug 
1234567.card-widget.card-map    .card-content        .item-headline            i.fa.fa-map-marker(aria-hidden=&quot;true&quot;)            span= _p(&#x27;足迹&#x27;)    # 这里是你复制过来的代码    &lt;a href=&#x27;https://clustrmaps.com/site/1bgca&#x27;  title=&#x27;Visit tracker&#x27;&gt;&lt;img src=&#x27;//clustrmaps.com/map_v2.png?cl=ffffff&amp;w=300&amp;t=tt&amp;d=Ti7plTQaKk8zjpyoUXfK29uCDrIzNldAuvoLvSLy1bU&amp;ct=ffffff&amp;co=2d78ad&#x27;/&gt;&lt;/a&gt;
如图

然后在 widget/ 目录下找得到 index.png 加上下面代码
12if theme.aside.card_maps    !=partial(&#x27;includes/widget/card_maps&#x27;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)
如图

添加评论
首先去 leadcloud 国际版注册一个账号Leadcloud国际版 。

然后创建应用
 
 

创建class
 
 

找到用户栏添加用户
 
 

然后修改访问权限
 
 
 

把 _User 的权限全部设置为指定用户但不添加，就是为了没有用户可以修改，防止别人通过 id 和 key 篡改我们用户数据
即上一步添加用户就是这么个作用
Leancloud的配置就告一段落了


然后在主题配置文件中填写 Leancloud 信息
 12345678910111213141516171819# valine# https://valine.js.orgvaline:  appId:  # leancloud application app id  appKey:  # leancloud application app key  pageSize: 10 # comment list page size  avatar: monsterid # gravatar style https://valine.js.org/#/avatar  lang: zh-CN # i18n: zh-CN/zh-TW/en/ja  placeholder: Please leave your footprints # valine comment input placeholder (like: Please leave your footprints)  guest_info: nick,mail # valine comment header info (nick/mail/link)  recordIP: false # Record reviewer IP  serverURLs: # This configuration is suitable for domestic custom domain name users, overseas version will be automatically detected (no need to manually fill in)  bg: # valine background  emojiCDN: # emoji CDN  enableQQ: true # enable the Nickname box to automatically get QQ Nickname and QQ Avatar  requiredFields: nick,mail # required fields (nick/mail)  visitor: false  option:
最后不要忘记打开这个
 


文章加密1npm install --save hexo-blog-encrypt
然后在文章的头部写上，如下例子

顶部标签页顶部图片</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/02/18/IDE%E9%85%8D%E7%BD%AE/" title="IDE配置">IDE配置</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-18T07:32:33.000Z" title="发表于 2021-02-18 15:32:33">2021-02-18</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.977Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%BD%AF%E4%BB%B6/">软件</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E8%AE%B0%E5%BD%95/">记录</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6/">软件</a></span></div><div class="content">
Vscode
preLaunchTask”C/C++: gcc.exe 生成活动文件”已终止，退出代码为 -1

点击仍要调试后出现下图情况


只需要修改 tasks.json 中一个地方
即 “command”: 处修改为 g++.exe

123456789101112131415161718192021222324252627282930// launch.json&#123;    // 使用 IntelliSense 了解相关属性。     // 悬停以查看现有属性的描述。    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        &#123;            &quot;name&quot;: &quot;gcc.exe - 生成和调试活动文件&quot;,            &quot;type&quot;: &quot;cppdbg&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;,            &quot;args&quot;: [],            &quot;stopAtEntry&quot;: false,            &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;,            &quot;environment&quot;: [],            &quot;externalConsole&quot;: false,            &quot;MIMode&quot;: &quot;gdb&quot;,            &quot;miDebuggerPath&quot;: &quot;D:\\Program Files\\RELY\\x86_64-8.1.0-release-posix-sjlj-rt_v6-rev0\\mingw64\\bin\\gdb.exe&quot;,            &quot;setupCommands&quot;: [                &#123;                    &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;,                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,                    &quot;ignoreFailures&quot;: true                &#125;            ],            &quot;preLaunchTask&quot;: &quot;C/C++: gcc.exe 生成活动文件&quot;        &#125;    ]&#125;
12345678910111213141516171819202122232425262728// tasks.json&#123;    &quot;tasks&quot;: [        &#123;            &quot;type&quot;: &quot;cppbuild&quot;,            &quot;label&quot;: &quot;C/C++: gcc.exe 生成活动文件&quot;,            &quot;command&quot;: &quot;g++.exe&quot;,            &quot;args&quot;: [                &quot;-g&quot;,                &quot;$&#123;file&#125;&quot;,                &quot;-o&quot;,                &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;            ],            &quot;options&quot;: &#123;                &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;            &#125;,            &quot;problemMatcher&quot;: [                &quot;$gcc&quot;            ],            &quot;group&quot;: &#123;                &quot;kind&quot;: &quot;build&quot;,                &quot;isDefault&quot;: true            &#125;,            &quot;detail&quot;: &quot;调试器生成的任务。&quot;        &#125;    ],    &quot;version&quot;: &quot;2.0.0&quot;&#125;






IDEA常用设置设置鼠标滚轮调节字体大小
鼠标悬浮在代码有提示
自动导包和优化多余包手动导包：Ant + Enter自动导包：
同一个包下的类，超过指定个数导包合并为 *
显示行号和方法之间分隔符
忽略大小写提示
多个类不隐藏，多行显示
设置默认字体，大小，行间距（编辑区和控制台都会变化）
修改注释




设置类头的文档注释信息   123456/*** @ Author: xxx* @ Date: $&#123;DATE&#125; - $&#123;TIME&#125;* @ Description: $&#123;PACKAGE_NAME&#125;* @ Version: 1.0*/
   
设置文件编码格式默认全选为 UTF-8
自动编译
导入 jar 包




生成序列化版本号

快捷键
创建内容：Alt + Ins
main() ：psvm
复制行：Ctrl + D
删除行：Ctrl + Y
代码上/下 移动：Ctrl + Shift + Up/Dn
收缩类：Ctrl + N
生成代码：Alt + Ins (如构造器, hashcode)
百能快捷键：Alt + Enter （导包，生成变量等）
单行注释或者多行注释：Ctrl + / 、Ctrl + Shift + /
重命名：Shift + F6
for循环：fori
代码块包围：Ctrl + Alt + T
自动补全提示：Alt + /
代码一层层调用：点进源码：Ctrl + 鼠标悬浮 + 点进去
左右回退：
显示代码结构：Alt + 7
显示导航：Alt + 1

Clion运行多个 main() 函数
将 CMakeLists.txt 文件写成如下

12345file (GLOB_RECURSE files *.cpp)foreach (file $&#123;files&#125;)    string(REGEX REPLACE &quot;.+/(.+)/(.+)\\..*&quot; &quot;\\1-\\2&quot; exe $&#123;file&#125;)    add_executable ($&#123;exe&#125; $&#123;file&#125;)endforeach ()
EX：

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/02/18/%E5%88%9D%E8%AF%86%E6%B1%87%E7%BC%96/" title="初识汇编">初识汇编</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-18T06:47:11.000Z" title="发表于 2021-02-18 14:47:11">2021-02-18</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.927Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C</a><i class="fas fa-angle-right"></i><a class="article-meta__categories" href="/categories/C/C/">C++</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E5%BA%95%E5%B1%82/">底层</a></span></div><div class="content">初识汇编概述语言
进制
进制如何运算
二进制（量子计算）
数据宽度
有符号数和无符号数
原码反码补码
位运算
位运算计算
汇编（OD）
寄存器
内存
汇编指令
内存复制
堆栈指令
汇编如何写函数
堆栈传参
堆栈平衡
外挂
语言什么是机器语言？
123456# 目前主流的电子计算机状态：0 1加	0100 0000减	0100 1000乘	0100 1000 0100 1000除	0100 1000 1100 1000
上述为机器语言，通过助记符 -&gt; 得到汇编语言，如下
1234加	INC	-编译器-&gt; 0100 0000减	DEC			 0100 1000乘	MUL			 0100 1000 0100 1000除	DIV			 0100 1000 1100 1000
汇编只是用于助记机器语言
进制
测试

1234567891011121314151617181920212223242526# 一进制 1 - 2011 11 1 11 1 1 1.........# 三进制0		1		210		11		1220		21		22100		101		102110		111		112120		121		122200		201		202210		211		212220		221		2221000	1001	10021010	1011	1012# 七进制0	1	2	3	4	5	610	11	12	13	14	15	1620	21	22	23	24	25	2630	31	...
加密解密：进制的加密
数字量一大，总有规律

进制的运算

1234567891011# 八进制计算2 + 3 = 52 * 3 = 64 + 5 = 114 * 5 = 24277 + 333 = 632276 * 54 = 20250273 - 54 = 217234 / 4 = 47
结论：无论什么进制，本事都有一套完美的运算体系，都可以通过列表的方式计算出来

二进制

计算机使用二进制 0 1 转态！ 电子！ 
物理极限：摩尔定理！追求语言的极限！并发语言！软操作！
量子计算机：一旦民用，目前的安全系统不再有用，爆破几分钟的事
可以实现量子计算的机器
传统计算机：集成电路：0 1     硅晶片
量子计算机的单位：昆比特
光子：正交偏振方向
磁场：电子的自旋方向
21世纪    计算力    快到尽头了
量子计算机    -&gt;    提高计算机的计算力
量子比特，量子叠加态，量子纠缠，量子并行原理
为什么要学习理解二进制？
寄存器、内存、位！底层的每一个位都是有含义的。
汇编高级：了解程序深层！操作系统的内核
数据宽度 C C++ Java 都需要定义数据的类型。计算机底层需要我们给这些数据定义宽度
位    0 1字节    0 - 0XFF字    0 - 0XFFFF双字    0 - 0XFFFFFFFF
有符号数和无符号数数据都是有宽度的，每个数据代表什么意思？
规则
二进制解码增加一个规则

无符号数规则
  11001 1010	十六进制：0x9A	十进制：154
有符号数规则
  最高位是符号位：1（负数）0（正数）


原码反码补码编码规则 ：有符号位的编码规则

原码：最高位是符号位
反码：
正数：反码和原码相同
负数：符号位一定是1，其余对原码取反


补码：
正数：补码和原码相同
负数：符号位一定是1，反码 +1




例子

12345678910111213141516# 如果是正数，都是一样的1# 原码	0000 0001# 反码	0000 0001# 补码	0000 0001# 如果是负数-1# 原码	1000 0001# 反码	1111 1110# 补码	1111 1111-7# 原码	1000 0111# 反码	1111 1000# 补码	1111 1001
一个二进制数，需要了解它是有符号数还是无符号数
如一个 32 位机器
FFFF FFFF

有符号表示 -1
无符号表示 4,294,967,295

位运算2 * 8 最高效的计算方式   -&gt;  2&lt;&lt;3
很多调试器，需要通过位来判断 CPU 状态

与运算（and &amp;）串行
 1231011 00011101 10001001 0000
或运算（or |）并行
 1231011 00011101 10001111 1001
异或运算（xor ^）不同为1
 1231011 00011101 10000110 1001
非运算（单目运算符 not ~）
 0 就是 1，1 就是 0
 121101 10000010 0111
位运算（移动位，左移 * 2，右移 / 2）
 12340000 0001	10000 0010	20000 0100	40000 1000	8
 左移：shl    &lt;&lt;
 10000 0001 # 所以二进制位全部左移若干位，高位丢弃，低位补0
 右移：shr    &gt;&gt;
 10000 0001 # 所以二进制位全部左移若干位，低位丢弃，高位补补0或1（正数补0，负数补1）




位运算的加减乘除12345678910111213141516171819202122232425262728293031# 计算机怎么操作 4 + 5？0000 01000000 0101----------计算机不会直接加0000 1001# 下面是计算机怎么计算的# 第一步， 异或：如果没有进位，异或直接就可以出结果0000 01000000 0101---------0000 0001# 第二步：与运算（判断进位，如果与运算结果为0，则没有进位）0000 01000000 0101---------0000 0100# 第三步，将与运算的结果，左移一位0000 1000# 第四步：异或0000 00010000 1000---------0000 1001# 第五步：与运算（判断进位，如果与运算结果为0，没有进位）0000 00010000 1000---------0000 0000# 所以最终结果就是与运算为0的上一个异或运算的值


寄存器寄存器：
存储数据：CPU -&gt; 内存 -&gt; 硬盘
32位 CPU：8    16    32
64位 CPU：8    16    32    64
通用寄存器
32位的通用寄存器只有 8 个

存值的范围    0 - FFFFFFFF
对于二进制来说，直接修改值
计算机如果像寄存器存值
mov 指令
12mov 存的地址,存的数mov 存的地址1,存的地址1
可以将数字写入寄存器，可以将寄存器中的值写到寄存器
不同的寄存器
12345678932位		16位		8位EAX		 AX		 ALECX		 CX		 CLEDX		 DX		 DLEBX		 BX		 BLESP		 SP		 AHEBP		 BP		 CHESI		 SI		 DHEDI		 DI		 BH
8位：L低8位，H高8位
除了这些通用寄存器之外，那么其他的寄存器都有自己特定的功能！
内存寄存器很小，不够用，所以把数据放到内存中
每个应用程序都有4GB的内存空间，空头支票
程序真正运行的时候，才会用到物理内存
123451B = 8bit1kb = 1024B1MB = 1024KB1GB = 1024MB4GB = 4096M = 4096 * 1024 * 1024B = 2^(12+10+10) = 2^32
内存地址
存一个数：占用的大小，数据宽度！存到哪里？
计算机中内存地址很多，空间很大，每个空间分配一个地址，名字
如32位系统：0x00000000 - 0xFFFFFFFF
32位：寻址能力！4GB
FFFFFFFF + 1 = 100000000，最大的值
位是怎么限制内存大小的
100000000 内存地址 * 8 = 位：800000000
转换为10进制 /8 ：4,294,967,296字节
按照规则 /1024 ，最终即为 4GB
内存如何存值
数据宽度：    byte    word    dwrod
不是任意的地址都可以写东西，申请使用的。只有程序申请过的内存才可以使用
123456# 汇编如何向内存中写值mov 数据宽度 内存地址,值mov byte/word/dword/qword,-1eg:mov byte ptr ds:[0xFFFFFFFF],1# 传递的值的大小一定要和数据宽度相等
内存有多种写法
123456ds:[0x0090FFFF+4]	内存地址偏移ds:[eax]			寄存器ds:[eax+4]			寄存器偏移# 数组[]ds:[reg+reg*&#123;1,2,4,8&#125;]		数组ds:[reg+reg*&#123;1,2,4,8&#125;+4]	数组偏移


</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/02/18/Git%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%BD%95%EF%BC%89/" title="Git-个人记录">Git-个人记录</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-18T01:19:37.000Z" title="发表于 2021-02-18 09:19:37">2021-02-18</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.965Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/tools/">tools</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Git/">Git</a></span></div><div class="content">
Git 常用命令level intro4
level rampup3
level mixed1
123456789101112131415$ git commit$ git branch &lt;branch_name&gt;$ git checkout &lt;branch_name&gt;$ git checkout -b &lt;branch_name&gt;$ git merge &lt;branch_name&gt;	# 把 branch_name 分支合并到当前所处分支$ git rebase &lt;branch_name&gt;$ git checkout &lt;has&gt;$ git ./git/HEAD # 查看 HEAD 指向$ git symbolic-ref HEAD	# 查看 HEAD 指向$ git branch -f main HEAD~3	 # 将 main 分支强制指向 HEAD 的第 3 级父提交$ git reset HEAD^	# 本地分支撤回$ git revert HEAD 	# 远程分支撤回$ git cherry-pick &lt;name&gt; [&lt;name&gt; ...]$ git rebase -i HEAD^


Git 使用
Git是目前世界上最先进的分布式版本控制系统。

一、安装方面
安装 git 
官网：https://git-scm.com/
淘宝镜像下载：http://npm.taobao.org/mirrors/git-for-windows/ 


  Git Bash：Unix与Linux风格的命令行，使用最多，推荐最多
  Git CMD：Windows风格的命令行
  Git GUI：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令

基本 Linux 命令


cd ：改变目录。

cd . . 回退到上一个目录，直接 cd 进入默认目录

pwd : 显示当前所在的目录路径。

ls(ll):  都是列出当前目录中的所有文件, ll更为详细。

touch :文件

vi ：新建文件并编辑

rm:  删除文件

mkdir:  新建文件夹。

rm -r :  删除文件夹

mv 移动文件/ 文件重命名，必须保证文件和目标文件夹在同一目录下。

reset：重新初始化终端/清屏。

clear：清屏。

history：查看命令历史。

help：帮助。

exit：退出。

#：表示注释



Git 配置
查看配置：git config -l

查看不同级别的配置文件：



系统 config ：git config –system –list
用户 global ：git config –global –list


  git 相关配置文件：
  
  - Git\etc\gitconfig ：Git 安装目录下的 gitconfig            –system 系统级别
  - C:\Users\用户名\.gotconfig ：只适用于当前登录用户的配置     –global 全局


设置用户名与邮箱

法一单独配置：引号要不要都可以 如：  git config –global user.name “MingHuifan”  git config –global user.email “&#120;&#120;&#120;&#120;&#120;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;“
法二文件写：  git config –global –edit  会进入.gitconfig文件编辑，把name和email写进去 :wq 退出并保存  


生成 SSH 公钥
 设置本机绑定 SSH 公钥，实现免密登录
 在 C:\Users\用户名\ .ssh 目录
 如果没有则用：ssh -keygen 生成，一路回车即可
 然后进去 C:\Users\用户名\ .ssh 目录 有一个 .pub 后缀的文件，这是公钥

在 gitee 设置公钥，github 一样
 



然后就是如何使用 git push 到 github 或者 gitee 上了

二、操作方面

前序工作已经完成，接下来是如何操作

在 github 上创建一个仓库（Repository）
 

然后克隆到本地
1$ git clone URL
然后下载到你的本地仓库

右键选择 git Bash Here  —&gt;  git clone + [url] 
  然后就会有一个 .git 的目录

可以下载到你的项目路径中，然后就可以用命令操作了

或者复制到其他的路径中，**.git**文件绑定了你的远程仓库，所以只要复制到任何地方都可以

考虑一种情况：我从远程仓库下载并保存在 E:\A\ 目录下那么 A 目录下就有 .git （该文件绑定了一个远程仓库），我就可以操作本地仓库 A ，然后我在把 .git 文件复制到 E:\B\ 目录下，那么我是不是可以将两个的文件叠加的上床到远程仓库中  其实并不能，并且两个路径不可以同时使用 git ，只能使用一个文件路径下的 git




几个命令

git add .
git commit -m 说明
git push
git pull
git rm -r –cached filePath : 清除缓存-指定路径
git rm -r –cached . ：清除缓存-清除全部缓存
git clone
git remote add origin SSH地址：链接远程仓库地址
git remote remove origin：移除远程仓库地址
git remove -v：查看远程仓库地址



</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/1970/01/01/Linux%E5%AE%89%E8%A3%85%E4%B8%AD%E6%96%87%E6%89%8B%E5%86%8C/" title="无题">无题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="1970-01-01T00:00:00.000Z" title="发表于 1970-01-01 08:00:00">1970-01-01</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:15:34.985Z" title="更新于 2022-04-02 22:15:34">2022-04-02</time></span></div><div class="content">


安装中文手册
先下载中文手册包
https://src.fedoraproject.org/repo/pkgs/man-pages-zh-CN/
或者直接用该链接下载：https://src.fedoraproject.org/repo/pkgs/man-pages-zh-CN/manpages-zh-1.5.2.tar.bz2/cab232c7bb49b214c2f7ee44f7f35900/manpages-zh-1.5.2.tar.bz2

解压
1$ tar -jxvf manpages-zh-1.5.2.tar.bz2
编译
12$ cd manpages-zh-1.5.2$ ./configure --disable-zhtw




</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/1970/01/01/nvim/" title="无题">无题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="1970-01-01T00:00:00.000Z" title="发表于 1970-01-01 08:00:00">1970-01-01</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-05T10:13:18.307Z" title="更新于 2022-04-05 18:13:18">2022-04-05</time></span></div><div class="content">


init.vimbasic.vimmap.vimPacker/home/minghui/.local/share/nvim/lsp_servers/
/home/minghui/.local/share/nvim/site/pack/packer/start/
123456789101112131415161718192021222324252627282930313233343536# 下面状态条&quot;vim-airline/vim-airline&quot;	&quot;vim-airline/vim-airline-themes&quot;	&quot;ryanoasis/vim-devicons&quot;# 主题&quot;sainnhe/gruvbox-material&quot;# ranger&quot;kevinhwang91/rnvimr&quot;# xda# 代码提示--Nvim LSP 客户端的快速入门配置use &quot;neovim/nvim-lspconfig&quot;use &#123;	&quot;hrsh7th/nvim-cmp&quot;,    requires = &#123;        &quot;hrsh7th/cmp-nvim-lsp&quot;, --neovim 内置 LSP 客户端的 nvim-cmp 源        --以下插件可选，可以根据个人喜好删减        &quot;onsails/lspkind-nvim&quot;, --美化自动完成提示信息        &quot;hrsh7th/cmp-buffer&quot;, --从buffer中智能提示        &quot;hrsh7th/cmp-nvim-lua&quot;, --nvim-cmp source for neovim Lua API.        &quot;octaltree/cmp-look&quot;, --用于完成英语单词        &quot;hrsh7th/cmp-path&quot;, --自动提示硬盘上的文件        &quot;hrsh7th/cmp-calc&quot;, --输入数学算式（如1+1=）自动计算        &quot;f3fora/cmp-spell&quot;, --nvim-cmp 的拼写源基于 vim 的拼写建议        &quot;hrsh7th/cmp-emoji&quot;, --输入: 可以显示表情    &#125;&#125;-- 代码段提示use &#123;    &quot;L3MON4D3/LuaSnip&quot;,    requires = &#123;        &quot;saadparwaiz1/cmp_luasnip&quot;, -- Snippets source for nvim-cmp        &quot;rafamadriz/friendly-snippets&quot; --代码段合集    &#125;&#125;


</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">xiaofan</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">63</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/755400668"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/755400668" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:755400668@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到灰灰爱吃小云朵的博客！</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/04/02/ArchLinux%E5%AE%89%E8%A3%85MySQL8/" title="ArchLinux安装Mariadb">ArchLinux安装Mariadb</a><time datetime="2022-04-02T08:28:58.000Z" title="发表于 2022-04-02 16:28:58">2022-04-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/25/Oracle11g%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9AOracle-%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86/" title="Oracle-安全管理">Oracle-安全管理</a><time datetime="2022-03-25T02:28:58.000Z" title="发表于 2022-03-25 10:28:58">2022-03-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/20/Linux%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E4%B9%A0%E9%A2%98/" title="Linux用户和权限管理习题">Linux用户和权限管理习题</a><time datetime="2022-03-20T01:28:58.000Z" title="发表于 2022-03-20 09:28:58">2022-03-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/18/Oracle11g%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9AOracle-%E6%A8%A1%E5%BC%8F%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/" title="Oracle-模式对象管理">Oracle-模式对象管理</a><time datetime="2022-03-18T02:28:58.000Z" title="发表于 2022-03-18 10:28:58">2022-03-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/16/Linux%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/" title="Linux文件和目录管理习题">Linux文件和目录管理习题</a><time datetime="2022-03-16T02:28:58.000Z" title="发表于 2022-03-16 10:28:58">2022-03-16</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item parent"><a class="card-category-list-link" href="/categories/C/"><span class="card-category-list-name">C</span><span class="card-category-list-count">1</span><i class="fas fa-caret-left "></i></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C/C/"><span class="card-category-list-name">C++</span><span class="card-category-list-count">1</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C/"><span class="card-category-list-name">C++</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Linux/"><span class="card-category-list-name">Linux</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Oracle11g%E5%AE%9E%E9%AA%8C/"><span class="card-category-list-name">Oracle11g实验</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Windows/"><span class="card-category-list-name">Windows</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/javaSE/"><span class="card-category-list-name">javaSE</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/tools/"><span class="card-category-list-name">tools</span><span class="card-category-list-count">3</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/Linux/" style="font-size: 1.45em; color: rgb(191, 176, 27)">Linux</a><a href="/tags/java/" style="font-size: 1.27em; color: rgb(121, 59, 53)">java</a><a href="/tags/CSS/" style="font-size: 1.15em; color: rgb(2, 163, 94)">-CSS</a><a href="/tags/%E8%AE%B0%E5%BD%95/" style="font-size: 1.39em; color: rgb(21, 110, 64)">记录</a><a href="/tags/Windows/" style="font-size: 1.27em; color: rgb(44, 120, 106)">-Windows</a><a href="/tags/Linux/" style="font-size: 1.15em; color: rgb(17, 84, 149)">-Linux</a><a href="/tags/Git/" style="font-size: 1.15em; color: rgb(14, 197, 160)">Git</a><a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 1.15em; color: rgb(114, 132, 114)">服务器</a><a href="/tags/HTML/" style="font-size: 1.15em; color: rgb(162, 50, 160)">-HTML</a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 1.15em; color: rgb(123, 82, 166)">博客</a><a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 1.15em; color: rgb(10, 65, 4)">软件</a><a href="/tags/Maven/" style="font-size: 1.15em; color: rgb(70, 96, 127)">Maven</a><a href="/tags/MySQL/" style="font-size: 1.27em; color: rgb(179, 63, 135)">MySQL</a><a href="/tags/Oracle/" style="font-size: 1.33em; color: rgb(13, 62, 129)">Oracle</a><a href="/tags/C/" style="font-size: 1.27em; color: rgb(136, 108, 19)">C++</a><a href="/tags/tree-java/" style="font-size: 1.15em; color: rgb(177, 46, 84)">tree - java</a><a href="/tags/Vue/" style="font-size: 1.15em; color: rgb(98, 29, 129)">Vue</a><a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 1.15em; color: rgb(126, 138, 163)">链表</a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.27em; color: rgb(19, 140, 93)">数据结构</a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.27em; color: rgb(194, 98, 66)">算法</a><a href="/tags/LeetCode/" style="font-size: 1.15em; color: rgb(90, 167, 168)">LeetCode</a><a href="/tags/wxy/" style="font-size: 1.15em; color: rgb(13, 163, 39)">wxy</a><a href="/tags/%E5%A3%81%E7%BA%B8/" style="font-size: 1.15em; color: rgb(56, 185, 16)">壁纸</a><a href="/tags/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.21em; color: rgb(63, 117, 114)">C++ - 数据结构</a><a href="/tags/vim/" style="font-size: 1.15em; color: rgb(133, 165, 35)">vim</a><a href="/tags/vlan/" style="font-size: 1.15em; color: rgb(134, 147, 56)">vlan</a><a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 1.15em; color: rgb(166, 12, 109)">汇编</a><a href="/tags/%E5%BA%95%E5%B1%82/" style="font-size: 1.21em; color: rgb(38, 191, 158)">底层</a><a href="/tags/%E4%B8%AA%E4%BA%BA/" style="font-size: 1.15em; color: rgb(53, 158, 148)">个人</a><a href="/tags/route/" style="font-size: 1.21em; color: rgb(77, 17, 110)">route</a><a href="/tags/Wireshark/" style="font-size: 1.15em; color: rgb(9, 25, 27)">Wireshark</a><a href="/tags/Burp-Suite/" style="font-size: 1.15em; color: rgb(124, 51, 14)">Burp Suite</a><a href="/tags/%E6%96%87%E4%BB%B6/" style="font-size: 1.15em; color: rgb(162, 73, 142)">文件</a><a href="/tags/%E4%B9%A6%E7%B1%8D/" style="font-size: 1.15em; color: rgb(69, 190, 28)">书籍</a><a href="/tags/%E9%80%9A%E4%BF%A1/" style="font-size: 1.15em; color: rgb(195, 200, 22)">通信</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/04/"><span class="card-archive-list-date">四月 2022</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/03/"><span class="card-archive-list-date">三月 2022</span><span class="card-archive-list-count">8</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/02/"><span class="card-archive-list-date">二月 2022</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/01/"><span class="card-archive-list-date">一月 2022</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/12/"><span class="card-archive-list-date">十二月 2021</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/11/"><span class="card-archive-list-date">十一月 2021</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/10/"><span class="card-archive-list-date">十月 2021</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/09/"><span class="card-archive-list-date">九月 2021</span><span class="card-archive-list-count">3</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">63</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2021-02-17T16:00:00.000Z"></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">83.1k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2022-04-11T08:45:16.788Z"></div></div></div></div><div class="card-widget"><div class="item-headline"><i></i><span>访客</span></div><div class="item-content"><script type="text/javascript" id="clstr_globe" src="//clustrmaps.com/globe.js?d=Ti7plTQaKk8zjpyoUXfK29uCDrIzNldAuvoLvSLy1bU"></script></div></div></div></div></main><footer id="footer" style="background: flse"><div id="footer-wrap"><div class="copyright">&copy;undefined - 2022  <i id="heartbeat" class="fa fas fa-heartbeat"></i> xiaofan</div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn"><span>湘ICP备2021007749号</span></a><div id="running-time"></div><script>setInterval(()=>{let create_time=Math.round(new Date(Date.UTC(2021,01,18,0,0,0)).getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600;}if(second>=24*3600){time[1]=parseInt(second/(24*3600));second%=24*3600;}if(second>=3600){time[2]=parseInt(second/3600);second%=3600;}if(second>=60){time[3]=parseInt(second/60);second%=60;}if(second>0){time[4]=second;}currentTimeHtml='本站已安全运行 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';document.getElementById("running-time").innerHTML=currentTimeHtml;},1000);
</script></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function subtitleType () {
  getScript('https://sdk.jinrishici.com/v2/browser/jinrishici.js').then(() => {
    jinrishici.load(function (result) {
      if (true) {
        var sub = "".length == 0 ? new Array() : "".split(',')
        var content = result.data.content
        var both = sub.unshift(content)
        var typed = new Typed('#subtitle', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('subtitle').innerHTML = result.data.content
      }
    })
  })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'dark',
      })
      true && mermaid.init()
    })
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>