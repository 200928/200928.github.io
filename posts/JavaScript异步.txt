---
title: "JavaScript 异步"
date: 2023-10-09T09:04:08+08:00
draft: false
author: ming
---

---

# 同步模式与异步模式

## 同步模式

JavaScript 语言的执行是单线程的，从执行代码来看，是单独一条一条语句从上至下执行，但是这样就会存在阻塞，比如某个操作比较费时（文件读写、网络IO等）下面的代码就不得不等待这个耗时操作执行完成后在执行，显然这种方式非常影响整个程序的使用。

为什么 JavaScript 不设计成多线程执行语言，举个例子，在 Web 应用中，A 函数删除了一个 DOM 节点，B 函数修改了同一个 DOM 节点，那么之后我是使用 A 函数的执行结果还是 B 函数的执行结果？这样会出现很多的问题

## 异步模式

![image-20230913134012465](https://ming-blog.oss-cn-shenzhen.aliyuncs.com/image/blog_img/image-20230913134012465.png)

异步模式大概是指运行环境提供的 API 是以同步或者异步模式进行工作的，同步模式指 JavaScript 代码会以同步模式执行，但是其某些 API 会调用其他线程完成某些工作。换句话说，JavaScript 是单线程工作的，但其浏览器并不是单线程工作的，执行 JavaScript 的线程是单线程的。

# 回调函数

> 所有异步编程方案的根基，由调用者定义，交给执行者执行的函数

# Promise

> 一种更优雅的异步编程统一方案

![image-20230913140107398](https://ming-blog.oss-cn-shenzhen.aliyuncs.com/image/blog_img/image-20230913140107398.png)

### 基本用法

```javascript
// Promise 基本用法

const promise = new Promise((resolve, reject) => {
  // 承诺达成后需要执行的函数
  resolve(100);

  // 承诺失败后需要执行的函数
  reject(new Error("Promise rejected"));
});

promise.then(
  (value) => {
    console.log("resolve", value);
  },
  (error) => {
    console.log("rejected", error);
  },
);
```

### Ajax 例子

```javascript
// Promise 方式的 AJAX

const ajax = (url) => {
  return new Promise((resolve, reject) => {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.responseType = "json";
    xhr.onload = () => {
      if (this.status === 200) {
        resolve(this.response);
      } else {
        reject(new Error(this.statusText));
      }
    };
    xhr.send();
  });
};

const url =
  "http://localhost:8081/tcarSpotCheckItem/listInspectionItems/装载机";

ajax(url).then(
  (res) => {
    console.log("resolve", res.data.data);
  },
  (error) => {
    console.log("reject", error);
  },
);
```

### 链式调用

1. Promise 对象的 then 方法会返回一个全新的 Promise 对象
2. 后面的 then 方法就是在为上一个 then 返回的 Promise 注册回调
3. 前面 then 方法中回调函数的返回值会作为后面 then 方法回调的参数
4. 如果回调中返回的是 Prmose，那么后面 then 方法的回调会等待它的结束

```javascript
ajax(url).then(
  (res) => {
    // 成功
  },
  (error) => {
    // 失败
  },
);
```

```javascript
ajax(url)
  .then((res) => {
    // 成功
  })
  .catch((error) => {
    // 失败
  });

// catch 方法其实就是 then 方法的别名，换言之，调用 catch 等价于下面的 then 写法
ajax(url)
  .then((res) => {
    // 成功
  })
  .then(undefined, (error) => {
    // 失败
  });
```

### 静态方法

1. resolve

   foo 将会作为 Promise 成功结果返回，然后注册返回 Promise 的成功回调

   ```javascript
   Promise.resolve("foo").then((value) => {
     console.log(value);
   });
   ```

   等价于下面写法，新的 Promise 对象掉调用了成功回调，并传入了 foo 字符串，后面在将返回的 Promise 对象注册成功回调

   ```javascript
   new Promise((resolve) => {
     resolve("foo");
   }).then((value) => {
     console.log(value);
   });
   ```

   输出结果都是`foo`

   如果 resolve 接收的是一个 Promise 对象

   通过 resolve 返回的 Promise 与原来 Promise 相同

   ```javascript
   const p1 = new Promise((resolve, reject) => {});
   const p2 = Promise.resolve(p1);
   console.log(p1 === p2);

   // 输出
   true;
   ```

2. reject

   ```javascript
   Promise.reject("anything").catch((error) => {
     console.log(error);
   });
   
   // 输出
   anything;
   ```

3.
