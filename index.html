<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>灰灰爱吃小云朵 - 云层小卖铺</title><meta name="author" content="xiaofan"><meta name="copyright" content="xiaofan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="灰灰爱吃小云朵">
<meta property="og:url" content="http://755400668.github.io/index.html">
<meta property="og:site_name" content="灰灰爱吃小云朵">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://755400668.github.io/img/%E5%A4%B4%E5%83%8F.gif">
<meta property="article:author" content="xiaofan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://755400668.github.io/img/%E5%A4%B4%E5%83%8F.gif"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://755400668.github.io/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":500,"languages":{"author":"作者: xiaofan","link":"链接: ","source":"来源: 灰灰爱吃小云朵","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#ffc0cb","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: false,
  isHome: true,
  isHighlightShrink: true,
  isToc: false,
  postUpdate: '2021-12-26 14:40:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/css/mycss/background.css"><link rel="stylesheet" href="/css/mycss/footer.css"><link rel="stylesheet" href="/css/mycss/scroll_bar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/css/hideCategory.min.css"><link rel="stylesheet" href="/css/mycss/read.css"><link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('http://p1.qhimg.com/bdr/__85/t01013525c6b73d2c2f.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">灰灰爱吃小云朵</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">灰灰爱吃小云朵</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://github.com/755400668" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:755400668@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/12/25/%E5%AE%9E%E9%AA%8C%E5%85%AD%EF%BC%9ABurpSuite%E6%8D%95%E8%8E%B7%E5%B9%B6%E4%BF%AE%E6%94%B9HTTP%E6%8A%A5%E6%96%87/" title="实验六：BurpSuite 捕获并修改 HTTP 报文">实验六：BurpSuite 捕获并修改 HTTP 报文</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-25T11:59:33.000Z" title="发表于 2021-12-25 19:59:33">2021-12-25</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-26T06:39:48.742Z" title="更新于 2021-12-26 14:39:48">2021-12-26</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%BD%91/">计网</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Burp-Suite/">Burp Suite</a></span></div><div class="content">

如果文中有什么纰漏或错误的话，请留言指正！！！

实验内容
安装与配置
捕获 HTTP 报文并分析其格式
修改 HTTP 报文（选做）

BurpSuite 安装
如果已经安装了可以忽略


下面的 BurpSuite 资源包由网名为轮回百转长相依同学赞助提供！


下载 BurpSuite 资源包 和 JDK1.8（如果自身电脑JDK是1.8就不用下载）
我电脑是 JDK 14，所以我需要 JDK1.8


解压得到如下文件


打开BurpSuite v2.1文件夹，用记事本编辑link.bat文件

在红框编辑 JDK1.8 的路径，并保存退出


然后点击Start.vbs，来到此界面


这个时候请输入许可证秘钥，双击burp-loader-keygen-2.jar


选择手动激活



然后就完成了，


捕获 HTTP 报文并分析其格式
捕获 HTTP 报文需要用到浏览器，火狐浏览器比较好配置，下载链接：https://www.firefox.com.cn/


配置火狐浏览器



通过火狐浏览器访问www.51cpc.com


看到已经被拦截了，浏览器一直是加载状态


下面对该 HTTP 请求报文放包处理，也就是 BurpSuite 会将从浏览器拦截到的 HTTP 请求发送给对应服务器，服务器就会将 HTTP 响应报文发给 BurpSuite，BurpSuite 再将响应数据给浏览器，浏览器解析该数据，展示出来

放包之后可以看到已经得到了响应


下面分析其报文格式

请求行




参数
含义



GET
请求方法，该请求是 GET 请求


/
请求 URL，/ 表示请求网站根目录


HTTP/1.1
HTTP 协议及版本



请求头




参数
含义



Host
Host


User_Agent
表示用户本地环境（工具环境）


Accept
浏览器可解析的应用环境


Accept-Language
浏览器可解析的语言类型


Accept-Encoding
浏览器可解析的编码方式


DNT
禁止追踪，1表示用户不想被第三方网站追踪，0代表接受追踪


Connection
表示连接类型，close表示连接以经关闭，


Upgrade-Insecure-Requests
是一个请求首部，用来向服务器端发送信号，表示客户端优先选择加密及带有身份验证的响应


Pragma
是一个在 HTTP/1.0 中规定的通用首部，详情


Cache-Control
通过指定指令来实现缓存机制，详情



请求头还有很多参数，具体查看：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers



修改 HTTP 报文
重新来到火狐浏览器，通过必应搜索来修改 HTTP 报文
先地址栏输入https://cn.bing.com进入必应搜索首页

这里为什么不用百度的原因：百度首页是异步更新，每次输入一个字符就会发一个请求，会产生很多与此次实验无关的报文，到时候太难找到需要修改的报文，所以用必应搜索更加容易找到我们需要修改的报文

遇到这种情况需要安装证书，下面安装证书

打开新标签输入http://burp，点击CA Certificate









再来到火狐浏览器设置


火狐下载路径一般是在下载目录下


然后重新打开一个新标签页https://cn.bing.com

然后点放包，浏览器就把响应的数据解析出来了


在必应搜索栏输入Hello World


然后找到该搜索的HTTP请求报文
前面可能有很多包，需要放包，一个个观察，找到 URL 中包含Hello World的包


下面对该请求报文进行修改


点击放包，看浏览器变化

然后看到浏览器的搜索内容由原来的Hello World变成了BurpSuite


修改 HTTP 报文完成！


</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/12/19/CentOS7%20%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6/" title="CentOS7 安装组件">CentOS7 安装组件</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-19T07:51:41.000Z" title="发表于 2021-12-19 15:51:41">2021-12-19</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-26T06:35:41.466Z" title="更新于 2021-12-26 14:35:41">2021-12-26</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E8%AE%B0%E5%BD%95/">记录</a></span></div><div class="content">
安装 JDK12345678$ yum install java-11-openjdk-devel$java -version$ yum install java-11-openjdk $ alternatives --config java$ yum install java-1.8.0-openjdk-devel$ java -version$ alternatives --config java$ java -version



安装 JDK 11
1$ yum install java-11-openjdk-devel


安装 JDK 8
1$ yum install java-1.8.0-openjdk-devel





安装 tomcat
下载 tomcat
1$ wget https://dlcdn.apache.org/tomcat/tomcat-8/v8.5.73/bin/apache-tomcat-8.5.73.tar.gz

如果报错

1$ yum install -y ca-certificates
开启



部署war
来到/usr/local/tomcat/apache-tomcat-8.5.73/webapps

上传war文件到这个目录，使用rz上传文件

来到 /usr/local/tomcat/apache-tomcat-8.5.73/conf打开service.xml
1&lt;Context path=&quot;/&quot; docBase=&quot;/usr/local/tomcat/apache-tomcat-8.5.73/webapps/info-academic.war&quot; debug=&quot;0&quot; reloadable=&quot;true&quot;/&gt;


来到/usr/local/tomcat/apache-tomcat-8.5.73/bin，启动tomcat

下面是汇总




</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/12/15/CentOS7%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="CentOS7搭建FTP服务器">CentOS7搭建FTP服务器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-15T13:51:41.000Z" title="发表于 2021-12-15 21:51:41">2021-12-15</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-26T06:32:55.402Z" title="更新于 2021-12-26 14:32:55">2021-12-26</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E8%AE%B0%E5%BD%95/">记录</a></span></div><div class="content">
安装下载
查看是否安装


安装


主配置文件/etc/vsftpd/vsftpd.conf


查看配置，并去掉注释
1$ cat vsftpd.conf | grep -v &quot;#&quot;


为了更好的配置，做一下处理




本地登录
本地用户模式是通过 Linux 系统本地的账户密码信息进行认证的模式，相较于匿名开放模式更安全，而且配置起来相对简单。但是如果被黑客破解了账户的信息，就可以畅通无阻地登录FTP服务器，从而完全控制整台服务器。


先关闭匿名登录，开启本地登录（默认是开启的）


下面用ftp用户登录
先修改ftp用户的密码
1$ passwd ftp
/var/ftp/默认是登录后可以看到的文件夹



创建文件发现被拒绝了

给权限


下面就可以创建并修改了


如果无法登录
无法登录考虑到防火墙


查看是否打开


核实防火墙是否加载了FTP 模块，发现结果为空


开放和关闭 FTP 端口
12345678暂时开放 FTP 服务$ firewall-cmd --add-service=ftp永久开放 FTP 服务$ firewall-cmd --add-service=ftp --permanent永久关闭 FTP 服务$ firewall-cmd --remove-service=ftp --permanent
开发和检查是否生效




参考：


https://www.modb.pro/db/111811
https://zhuanlan.zhihu.com/p/354583347

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/12/08/%E5%AE%9E%E9%AA%8C%E4%BA%94%EF%BC%9AWireshark%E6%8A%93%E5%8C%85/" title="实验五：Wireshark 抓包分析">实验五：Wireshark 抓包分析</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-08T07:59:33.000Z" title="发表于 2021-12-08 15:59:33">2021-12-08</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-13T08:37:17.982Z" title="更新于 2021-12-13 16:37:17">2021-12-13</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%BD%91/">计网</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Wireshark/">Wireshark</a></span></div><div class="content">

如果文中有什么纰漏或错误的话，请留言指正！！！

GNS3 的安装和使用
这里我们要装两个东西：GNS3本体、在虚拟机里装上官方提供的GNS3镜像
即下面两个东西
问：为什么不装 Wireshark？ 因为在装 GNS3 本体的时候可以勾选装与不装 Wireshark，建议勾选，否则还要单独装



装 GNS3 本体






可能会弹出下图，等待



抓包需要用到它，安装就是






网络有问题，下载不了 Wireshark，那么就直接点取消吧，影响不大，到时候单独装就好了




等待即可





OK，GNS3 程序本体安装好了！！！


然后打开






OK！先告一段落了，不过等会它还会回来，阴魂不散


差点忘记了，如果刚刚下载安装 Wireshark 失败，现在就要重新安装一下 Wireshark

官网下载 ，如果不想下载，那个压缩包（群里）都有

在虚拟机里装 GNS3 镜像

最简单的方法：找到GNS3 VM.ova直接拖到虚拟机里面去



选好存放位置后导入



然后就有了这个系统，其他设置有需要自行配置


然后打开，请屏幕前的你耐心等待！！！



恭喜！经过耐心的等待，终于有了结果



将 GNS3 本体和虚拟机联合起来（连接）

打开 GNS3，点开箭头所指



按图下进行设置




然后添加 IOU 镜像

把下面 3 行信息复制粘贴到下图位置

123[license]gns3-iouvm = cd11acbc599f2364;gns3vm = 73635fd3b0a13ad0;


然后添加 IOU 镜像（包括路由器和交换机）下面演示导入交换机镜像






路由器同样的操作，这里就不在赘述了！！！


新建工程，不要有中文路径以及工程名也不要是中文，开始下面的实验




IDLE PC 值
1FE：1个千兆以太网口
1E：1个百兆以太网口
1TX：1个双绞线接口
4T：4个串口（广域网接口）
16ESW：16个百兆以太网口，充当交换机用

IOS、IOU 简单理解
IOS 镜像运行在本地电脑

IOU 镜像运行在虚拟机系统，也就是官方提供的 GNS3 系统镜像，其系统镜像就是一个Ubuntu系统（以桌面应用为主的 Linux 发行版）

那么在 GNS3 软件中导入 IOU 镜像的过程中，当我们选择好了点 OK 之后，它会将本地镜像文件上传到虚拟机系统中去，下面不妨简单验证下，看是否上传到了虚拟机系统中

这里说镜像保存的位置在/opt/gns3路径下


对该路径进行查看，发现本地选择的镜像这里都有了（且该镜像的大小和本机上的大小一致）


为什么不选择运行在本地的 IOS 镜像？本地不是更方便吗，还不用安装虚拟机？
通过上网查阅发现没有本地运行的交换机 IOS 镜像，但是可以通过两种方法解决，点击具体查看
最后发现还不如直接用虚拟机装上 GNS3 的系统，然后添加路由器和交换机的 IOU 镜像，而且通过虚拟机运行镜像，功能也比本地的 IOS 镜像多。


实验步骤前置工作
搭建拓扑图


把拓扑图上的信息配置好
先打开设备的终端（命令行配置窗口），右击它选择Console，下面进行 IP 等信息的配置


GNS3 的路由器配置和 Packet Tracer 是一样的
PC 主机要用命令配置，可以输入ip ?查看命令帮助


下面进行 IP、子网掩码等信息配置，PC 要配置网关，想必都已经清楚怎么找网关了

重要：在 GNS3 中，配置好了之后似乎不会自动写入文件中，因此配置好了一定要记得保存
路由器保存命令是（在特权模式下）：write memory
PC 的保存命令是：save
具体下面会提到！


R1

记得保存，保存要先进入到特权模式（从配置模式直接输入end按回车即可），即一个#号的那个模式


R2

记得保存，保存要先进入到特权模式（从配置模式直接输入end按回车即可），即一个#号的那个模式


当过了一会出现了下面情况（如果你没有出现，那么可以直接跳过），提示意思大概为双工不匹配，执行下面语句即可解决（其实配置 R1 的时候就遇到过了），注：这里我提示是 e0/0 接口不是全双工，所以是int e0/0，如果你此时的接口是 e1/0，那么就是int e1/0，表示对这个接口配置



PC1

记得保存，PC 保存命令为save


PC2
记得保存




最后如何查看是否已经保存成功（写入文件）了呢？

比如我查看 PC1 是否保存成功了


测试 PC1 与 PC2 是否可通信，为后面抓包做准备

目的主机不可到达
为何这样？前面不是都配置好了



原因是忘记配路由协议了，为了简单起见，下面我使用的是静态路由，R1 和 R2 都要添加




再次测试能否通信，能够通信



配置工作已经完成，下面用 WireShark 软件进行抓包分析



用 WireShark 软件进行抓包分析前言
下面是我们要抓包分析的协议


数据链路层协议
PPP 协议（点到点协议）


网际层协议
IP 协议
ICMP 协议
ARP 协议


传输层协议
UDP 协议
TCP 协议



数据链路层协议PPP 协议（P121）

准备工作
根据我们前面搭建好的网络结构，没有单独配置点到点协议，默认会有一个协议，我对 R1 用命令show int s2/0查看（s2/0 表示路由器的接口编号，若不同，替换成你的接口编号）
发现这个默认协议是 HDLC，因此在分析 PPP 协议抓包的实验中，要将该协议改为 PPP 协议

下面将 R1 和 R2 连线的接口都改为 PPP 协议

R1


此时如果你 ping R2 会发现不通，两个接口协议不一致不可通信

R2


此时 R1 与 R2 可通信了

下面进行抓包分析
鼠标右键 R1 与 R2 之间的链路


点击 OK 之后会自动打开Wireshark

随便点击一条记录

然后用 R1 ping R2，随便点击一个 ICMP 数据报



网际层协议IP、ICMP、ARP协议
这三个协议可以通过 ping 命令全部抓取
ICMP 报文是在 IP 数据报内部被传输，因此下面用 ping 命令就是，ping 命令就是会产生一个 ICMP 报文发送给目标地址，因此有了 ICMP 报文就有可以抓取到 ICMP、IP 协议的数据包
不仅如此，在 ping 的同时，如果该终端设备的 ARP 缓存中没有目标 IP 地址的条目，就会以广播发送 ARP 请求帧，那么包含 ARP 协议的数据包也能够抓取到！


在 PC1 和交换机的链路右键开始抓包



然后用 PC1 ping PC2，先查看PC1本地 ARP 缓存是否有记录，如果有则要清空



抓取的数据中有用 IP、ICMP、ARP 协议封装的数据包，下面依次分析它们内部的细节

IP 数据包（P252）



ICMP 报文格式（P277）



ARP 协议


注意：PC1 ping PC2，这两台设备不在同一个网段，因此，ARP 请求的目标 IP 地址就是网关了


ARP 请求包



ARP 响应包




传输层协议
抓取这两个协议数据包不需要用到 GNS3 和 虚拟机了，直接抓取本地网卡数据
重新打开Wireshark软件

UDP 协议（P349）

因为我是无线连接的，因此选择无线网卡对其抓包分析，若为有线，选择对应网卡！


随便选取一个 UDP 协议数据包分析



TCP 协议（P352）

在 UDP 的基础上修改过滤条件为TCP并按回车


随便选取一条 TCP 协议数据包分析




参考资料


韩立刚《计算机网络原理创新教材》
TCP/IP 与 UDP 报文协议抓包浅析 - 碎岁语 - 博客园 (cnblogs.com)
ARP协议抓包分析_xiaoxiao的博客-CSDN博客_arp报文分析
ARP报文格式详解 (biancheng.net)

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/12/01/SQL20%E9%A2%98/" title="SQL20题">SQL20题</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-12-01T02:32:33.000Z" title="发表于 2021-12-01 10:32:33">2021-12-01</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-09T03:00:36.099Z" title="更新于 2021-12-09 11:00:36">2021-12-09</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/MySQL/">MySQL</a></span></div><div class="content">

如果文中有什么纰漏或错误的话，请留言指正！！！

建库建表
仅仅为了做测试，可以不做这一步


DBMS用的是 MySQL


新建一个数据库sql_twenty，然后建表以及添加数据做测试（检验所写 SQL 语句是否正确）
下面SQL语句包括了建库、建表和数据添加，只需要手动复制并执行即可

12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576DROP DATABASE IF EXISTS `sql_twenty`;CREATE DATABASE sql_twenty    DEFAULT CHARACTER SET = &#x27;utf8mb4&#x27;;	USE sql_twenty;DROP TABLE IF EXISTS `SC`;DROP TABLE IF EXISTS `Course`;DROP TABLE IF EXISTS `Student`;DROP TABLE IF EXISTS `Teacher`;CREATE TABLE Student(    `S#` CHAR(2) PRIMARY KEY COMMENT &#x27;学生编号&#x27;,    `Sname` VARCHAR(20) COMMENT &#x27;学生姓名&#x27;,    `Sage` DATE COMMENT &#x27;出生年月&#x27;,    `Ssex` CHAR(1) COMMENT &#x27;学生性别&#x27;) DEFAULT CHARACTER SET UTF8 COMMENT &#x27;学生表&#x27;;CREATE TABLE Teacher(    `T#` CHAR(4) PRIMARY KEY COMMENT &#x27;教师编号&#x27;,    `Tname` VARCHAR(20) COMMENT &#x27;教师姓名&#x27;) DEFAULT CHARACTER SET UTF8 COMMENT &#x27;教师表&#x27;;CREATE TABLE Course(    `C#` CHAR(2) NOT NULL PRIMARY KEY COMMENT &#x27;课程编号&#x27;,    `Cname` VARCHAR(255) NOT NULL COMMENT &#x27;课程名称&#x27;,    `T#` CHAR(4) COMMENT &#x27;教师编号&#x27;,    FOREIGN KEY(`T#`) REFERENCES Teacher(`T#`) ) DEFAULT CHARACTER SET UTF8 COMMENT &#x27;课程表&#x27;;CREATE TABLE SC(    `S#` CHAR(2) NOT NULL COMMENT &#x27;学生编号&#x27;,    `C#` CHAR(2) NOT NULL COMMENT &#x27;课程编号&#x27;,    `score` TINYINT COMMENT &#x27;分数&#x27;,    PRIMARY KEY(`S#`,`C#`),    FOREIGN KEY(`S#`) REFERENCES Student(`S#`),    FOREIGN KEY(`C#`) REFERENCES Course(`C#`)) DEFAULT CHARACTER SET UTF8 COMMENT &#x27;成绩表&#x27;;INSERT INTO Student(`S#`,`Sname`,`Sage`,`Ssex`) VALUES(&#x27;01&#x27;,&#x27;赵同学&#x27;,&#x27;2000-1-1&#x27;,&#x27;男&#x27;);INSERT INTO Student(`S#`,`Sname`,`Sage`,`Ssex`) VALUES(&#x27;02&#x27;,&#x27;钱同学&#x27;,&#x27;2001-2-1&#x27;,&#x27;女&#x27;);INSERT INTO Student(`S#`,`Sname`,`Sage`,`Ssex`) VALUES(&#x27;03&#x27;,&#x27;孙同学&#x27;,&#x27;2002-3-1&#x27;,&#x27;男&#x27;);INSERT INTO Student(`S#`,`Sname`,`Sage`,`Ssex`) VALUES(&#x27;04&#x27;,&#x27;李同学&#x27;,&#x27;2003-4-1&#x27;,&#x27;女&#x27;);INSERT INTO Student(`S#`,`Sname`,`Sage`,`Ssex`) VALUES(&#x27;05&#x27;,&#x27;周同学&#x27;,&#x27;2004-5-1&#x27;,&#x27;女&#x27;);INSERT INTO Student(`S#`,`Sname`,`Sage`,`Ssex`) VALUES(&#x27;06&#x27;,&#x27;李同学&#x27;,&#x27;2004-5-1&#x27;,&#x27;女&#x27;);INSERT INTO Student(`S#`,`Sname`,`Sage`,`Ssex`) VALUES(&#x27;07&#x27;,&#x27;周同学&#x27;,&#x27;2000-5-1&#x27;,&#x27;男&#x27;);INSERT INTO Student(`S#`,`Sname`,`Sage`,`Ssex`) VALUES(&#x27;08&#x27;,&#x27;李同学&#x27;,&#x27;2002-9-1&#x27;,&#x27;男&#x27;);INSERT INTO Teacher(`T#`,Tname) VALUES(&#x27;1001&#x27;,&#x27;张三&#x27;);INSERT INTO Teacher(`T#`,Tname) VALUES(&#x27;1002&#x27;,&#x27;李四&#x27;);INSERT INTO Teacher(`T#`,Tname) VALUES(&#x27;1003&#x27;,&#x27;王五&#x27;);INSERT INTO Teacher(`T#`,Tname) VALUES(&#x27;1004&#x27;,&#x27;JACK&#x27;);INSERT INTO Course(`C#`,`Cname`,`T#`) VALUES(&#x27;01&#x27;,&#x27;数学&#x27;,&#x27;1001&#x27;);INSERT INTO Course(`C#`,`Cname`,`T#`) VALUES(&#x27;02&#x27;,&#x27;数据库&#x27;,&#x27;1002&#x27;);INSERT INTO Course(`C#`,`Cname`,`T#`) VALUES(&#x27;03&#x27;,&#x27;计算机网络&#x27;,&#x27;1003&#x27;);INSERT INTO Course(`C#`,`Cname`,`T#`) VALUES(&#x27;04&#x27;,&#x27;外语&#x27;,&#x27;1004&#x27;);INSERT INTO SC(`S#`,`C#`,`score`) VALUES(&#x27;01&#x27;,&#x27;01&#x27;,80);INSERT INTO SC(`S#`,`C#`,`score`) VALUES(&#x27;01&#x27;,&#x27;02&#x27;,75);INSERT INTO SC(`S#`,`C#`,`score`) VALUES(&#x27;02&#x27;,&#x27;02&#x27;,85);INSERT INTO SC(`S#`,`C#`,`score`) VALUES(&#x27;02&#x27;,&#x27;03&#x27;,65);INSERT INTO SC(`S#`,`C#`,`score`) VALUES(&#x27;03&#x27;,&#x27;01&#x27;,50);INSERT INTO SC(`S#`,`C#`,`score`) VALUES(&#x27;03&#x27;,&#x27;03&#x27;,62);INSERT INTO SC(`S#`,`C#`,`score`) VALUES(&#x27;04&#x27;,&#x27;01&#x27;,65);INSERT INTO SC(`S#`,`C#`,`score`) VALUES(&#x27;04&#x27;,&#x27;02&#x27;,70);INSERT INTO SC(`S#`,`C#`,`score`) VALUES(&#x27;04&#x27;,&#x27;03&#x27;,30);INSERT INTO SC(`S#`,`C#`,`score`) VALUES(&#x27;05&#x27;,&#x27;01&#x27;,59);INSERT INTO SC(`S#`,`C#`,`score`) VALUES(&#x27;05&#x27;,&#x27;02&#x27;,90);INSERT INTO SC(`S#`,`C#`,`score`) VALUES(&#x27;05&#x27;,&#x27;03&#x27;,75);



T20
下面所写的20个题的 SQL 语句不一定完全正确，但是测试都是正确的，也有可能有些特殊情况没有考虑到！！！

==前提知识（做题需掌握的知识）==


WHERE子句用法、IN运算符用法
自然连接写法：表一名称 NATURAL JOIN 表二名称，这应当写在 FROM 语句中
左外连接写法：表一名称 LEFT JOIN 表二名称 ON(连接条件)
EXISTS谓词的使用：它执行流程详细看书上P109
GROUP BY子句、HAVING短语的用法



下面每道题后面都有一个SQL语句的结果图
测试的数据在数据库sql_twenty中，DBMS用的是 MySQL
下图是sql_twenty数据库里四个表的数据



根据热心网友的宝贵发现对以下题做了修改（有错误）

2021/12/07更新了下面几个地方

T19：是输出学生编号，原来写的输出分数、已修改 SQL 语句

T16：SELECT 后面漏写了 Sname，不及格学生应该要有学号和姓名（因为有重名的，两个属性一起才是主码）



查询”01”课程比”02”课程成绩高的学生编号及课程分数

只涉及SC(成绩)表
使用EXISTS谓词，外层循环先筛选出是“01”课程的元组（即满足C# = &#39;01&#39;这个条件），然后执行EXISTS括号的 SQL 语句，EXISTS括号是内层循环，内层循环从SC表第一条元组开始遍历判断，只有当外层循环元组的学生编号等于内层循环当前元组的学生编号且内层循环元组的课程编号为“02”且外层循环元组的成绩高于内层循环当前元组的成绩，EXISTS 才返回真，反之为假。所以当外层循环的两个条件满足时，即为所求元组，最后投影到学生编号和课程分数。

1234567SELECT `S#`, score	FROM SC AS A	WHERE `C#` = &#x27;01&#x27; AND EXISTS(		SELECT *			FROM SC			WHERE A.`S#` = `S#` AND `C#` = &#x27;02&#x27; AND A.score &gt; score	);


查询平均成绩大于等于60分的同学的学生编号和平均成绩

涉及Student(学生)表和SC(成绩)表
Student 表和 SC 表自然连接，每个学生可能有多个选课成绩，所以用 GROUP BY 子句按S#(学生学号)进行分组，分组之后再用 HAVING短语筛选出平均成绩大于等于 60 分的元组

1234SELECT `S#`,AVG(score) AS &#x27;平均成绩&#x27;	FROM Student NATURAL JOIN SC	GROUP BY `S#`		HAVING AVG(score) &gt;= 60;


查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩

涉及Student表和SC表
Student 表与 SC 表按属性S#左外连接，然后按S#进行分组，最后在SELECT后面跟上题目要统计的信息即可
注：这里不可以用内连接，因为考虑到有些学生一门课也没有选，如果用了内连接就会漏掉这些一门课也没选的学生

123SELECT Student.`S#`, Sname, COUNT(`C#`), SUM(score)	FROM Student LEFT JOIN SC ON(Student.`S#` = SC.`S#`)	GROUP BY `S#`;


查询”李”姓老师的数量
123SELECT COUNT(*)	FROM Teacher	WHERE Tname LIKE &#x27;李%&#x27;;


查询学过”张三”老师授课的同学的信息

法一：

涉及全部表（4个表）
将四个表自然连接，从连接之后的表中筛选出授课老师是“张三”的元组，最后投影到学生信息的四个属性上

123SELECT `S#`, `Sname`, `Sage`, `Ssex`	FROM Student NATURAL JOIN SC NATURAL JOIN Course NATURAL JOIN Teacher	WHERE Tname = &#x27;张三&#x27;;
法二：嵌套查询

也是涉及全部表
学生表和成绩表连接之后有课程编号这一属性，而一个老师对应一个课程编号
所以可以通过内循环找到“张三”老师授课的课程编号，然后在外层循环的 WHERE 子句条件中筛选出课程编号是此编号的元组，最后投影到学生信息的四个属性上

123456SELECT `S#`,`Sname`,`Sage`,`Ssex`	FROM Student NATURAL JOIN SC	WHERE `C#` IN(		SELECT `C#`			FROM Teacher NATURAL JOIN Course			WHERE Tname = &#x27;张三&#x27;);




查询学过编号为”01”并且也学过编号为”02”的课程的同学的学生编号

法一：

只涉及一个SC表，但是用到两次，因此下面取别名区分它们
将 SC 表（取别名为A）与 SC 表（取别名为B）通过属性S#等值连接，然后筛选出 A 表选了“01”课程且 B 表选了“02”课程的元组，然后投影到S#(学生编号)

123SELECT A.`S#`	FROM SC AS A, SC AS B	WHERE A.`S#` = B.`S#` AND A.`C#` = &#x27;01&#x27; AND B.`C#` = &#x27;02&#x27;;
法二：

只涉及一个SC表，运用 EXISTS谓词
首先取外层查询中选课表（SC）第一个选了“01”课程的元组，然后到内层循环，内层循环会遍历选课表的元组，判断内层循环的 WHERER 子句是否满足，若不满足则返回假，满足返回真。
所以只有当一个学生同时选了“01”和“02”课，内层循环返回真给外层循环的WHERE子句，外层循环条件满足将元组放到结果表，最后投影到S#(学生编号)

123456SELECT `S#`	FROM SC AS A	WHERE `C#` = &#x27;01&#x27; AND EXISTS(		SELECT *			FROM SC			WHERE A.`S#` = `S#` AND `C#` = &#x27;02&#x27;);




查询没有学全所有课程的同学的信息

涉及SC表和Student表
没有选全可以用学生选课数量与全部课程数量做比较，前者小于后者表示未选全
内层循环筛选出没有选全课程的学生编号集合，外层用IN谓词筛选出包含该集合元素的元组，最后投影到各个属性上（学生信息）

1234567891011SELECT `S#`, Sname, Sage, Ssex	FROM Student	WHERE `S#` IN (		SELECT Student.`S#`	 -- 选出没有学全所有课程的学号			FROM Student LEFT JOIN SC ON(Student.`S#` = SC.`S#`)			GROUP BY `S#`			HAVING COUNT(*) &lt; (				SELECT DISTINCT COUNT(*)   -- 统计课程总数量					FROM Course			)	);


查询至少有一门课与学号为”01”的同学所学相同的同学的学生编号

只涉及一个SC表
嵌套查询：内层循环找出学号为“01”同学所选的课程编号（C#），外层循环遍历全部元组，包括就放到结果表中，最后用 DISTINCT去重

12345678SELECT DISTINCT `S#`	FROM SC	WHERE `C#` IN(		SELECT `C#`			FROM SC			WHERE `S#` = &#x27;01&#x27;	)	ORDER BY `S#`; -- 升序


检索”01”课程分数小于60，按分数降序排列的学生信息
1234SELECT `S#`, `Sname`, `Sage`, `Ssex`, `score`	FROM SC NATURAL JOIN Student	WHERE `C#` = &#x27;01&#x27; AND score &lt; 60	ORDER BY `score` DESC;


查询没学过”张三”老师讲授的任一门课程的学生编号

涉及到全部表
先找到张三老师课程编号，然后找到选了张三老师课的学生编号，最后选出不包含选了张三老师课的学生编号

1234567891011SELECT DISTINCT `S#`	FROM Student	WHERE `S#` NOT IN(		SELECT DISTINCT `S#`  -- 找到选了张三老师课的学生编号			FROM SC 			WHERE `C#` in(				SELECT `C#` -- 找到张三老师课程编号					FROM Teacher NATURAL JOIN Course					WHERE Tname = &#x27;张三&#x27;			)	);


查询每门课程被选修的学生数

涉及Course表和SC表
Course 表左外连接 SC 表，连接条件(写在ON括号里)是课程编号，然后用GROUP BY子句按C#属性分组
然后按S#属性统计每个分组的数量，最后用ORDER BY对课程编号升序排列

1234SELECT Course.`C#`, COUNT(`S#`)	FROM Course LEFT OUTER JOIN SC ON(Course.`C#` = SC.`C#`)	GROUP BY Course.`C#`	ORDER BY `C#`;


查询出只有两门课程的全部学生的学号

只涉SC表
用GROUP BY子句对学号（S#）进行分组，然后用 HAVING短语筛选出学生选课数为 2 的元组

1234SELECT `S#`	FROM SC	GROUP BY `S#`	HAVING COUNT(`C#`) = 2;


查询姓名相同的学生名单，并统计同名人数

只涉及Student表
使用EXISTS谓词，外循环对学生表元组依次遍历，遍历一个就进入内循环，然后内循环通过WHERE子句判断返回真假，直到外循环元组遍历完。
EXISTS 返回真时：内层循环元组的学号与外层循环元组的学号不同且内层循环元组的姓名等于外层循环元组的姓名
所以只有当有同名学生才会返回真

12345678SELECT Sname, COUNT(Sname) AS &#x27;同名人数&#x27;	FROM Student AS A	WHERE EXISTS(		SELECT *			FROM Student			WHERE A.`S#` &lt;&gt; `S#` AND A.Sname = Sname		)	GROUP BY Sname;


查询课程名称为”数学”，且分数低于60的学生姓名和分数
123SELECT Sname, score	FROM SC NATURAL JOIN Course NATURAL JOIN Student	WHERE Cname = &#x27;数学&#x27; AND score &lt; 60;


查询选修了全部课程的学生信息

涉及了Student表、SC表和 Course表
选修全部课程可用学生选修课程数量是否等于课程表的总元组数量判断

1234567891011SELECT `S#`, Sname, Sage, Ssex	FROM Student	WHERE `S#` IN(		SELECT `S#`			FROM SC			GROUP BY `S#`			HAVING COUNT(*) = (				SELECT COUNT(*)					FROM Course			)	);


查询各学生不及格的课程
123SELECT `S#`, Sname, Cname	FROM Student NATURAL JOIN SC NATURAL JOIN Course	WHERE score &lt; 60;


查询男生、女生人数
123SELECT Ssex, COUNT(Ssex)	FROM Student	GROUP BY `Ssex`;


查询任何一门课程成绩在70分以上的姓名、课程名称和分数
123SELECT Sname, Cname, score	FROM SC NATURAL JOIN Student NATURAL JOIN Course	WHERE score &gt; 70;


查询”01”课程成绩第二高分的学生编号
参考链接：https://leetcode-cn.com/problems/second-highest-salary/solution/tu-jie-sqlmian-shi-ti-ru-he-cha-zhao-di-ngao-de-sh/

法一：

只涉及SC表
内循环先计算出“01”课程第一高分的分数；然后中间循环计算出比第一高分（内循环的结果）低且是最高的分数，就是第二高分；最后在外循环中找到是“01”课程且分数是第二高分（也就是中间循环返回的分数）的学生学号。

1234567891011SELECT `S#`	FROM SC	WHERE `C#` = &#x27;01&#x27; AND score = (		SELECT MAX(DISTINCT score)	-- 找到&quot;01&quot;课程第二高分			FROM SC 			WHERE `C#` = &#x27;01&#x27; AND score &lt; (				SELECT MAX(DISTINCT score)	-- 找到&quot;01&quot;课程最高分					FROM SC					WHERE `C#` = &#x27;01&#x27;			)	);
法二：看参考链接，本质上和法一一样
123456789SELECT `S#`	FROM SC	WHERE `C#` = &#x27;01&#x27; AND score = (		SELECT score	-- 这里会找到第二高分(01课程)			FROM SC			WHERE `C#` = &#x27;01&#x27;			ORDER BY score DESC			LIMIT 1, 1	-- 跳过排序后的第一个分数(也就是第一高分),读取第二个分数(也就是第二高分)	);






查询各学生的年龄

YEAR(DATE)函数传入一个 DATE 类型，返回年

12SELECT `S#`, Sname, 2021 - YEAR(Sage) AS &#x27;年龄&#x27;	FROM Student;



</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/11/17/%E7%A1%AC%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%BD%AF%E9%93%BE%E6%8E%A5/" title="Windows-硬链接与软链接">Windows-硬链接与软链接</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-17T03:32:33.000Z" title="发表于 2021-11-17 11:32:33">2021-11-17</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-17T10:10:00.048Z" title="更新于 2021-11-17 18:10:00">2021-11-17</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Windows/">Windows</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%96%87%E4%BB%B6/">文件</a></span></div><div class="content">

软链接
有两种软链接


/D 是创建一个目录的软链接
不带参数是一个文件的软链接

注意：软链接是看绝对路径，创建的时候用绝对路径，还有要注意的是，软链接文件要和源文件放在同一个目录下，否则软链接无效
12$ mklink /d &quot;old_dir&quot; &quot;new_dir&quot;$ mklink &quot;old_file&quot; &quot;new_file&quot;
硬链接
硬链接创建可以使用绝对路径，如果使用相对路径创建的时候就要到需要创建硬链接的源文件所在目录
一个文件可以有多个硬链接，只要不删除最后一个硬链接，都可以通过它访问
Windows 下一个文件最多有 2^10 - 1（1023）个硬链接

硬链接两个特点：

删除具有硬链接的文件，不影响其他链接对内容的访问
修改其中之一的内容，其他链接文件的内容同时改变

但是硬链接创建不可以跨分区，Windows系统只能在 NTFS 文件系统使用
1$ mklink /h &quot;old_file&quot; &quot;new_file&quot;
查看一个文件的硬链接有哪些
1$ fsutil hardlink list &quot;file_name&quot;




</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/11/15/%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9ARIP%E4%B8%8EOSPF%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/" title="实验四：RIP与OSPF动态路由配置">实验四：RIP与OSPF动态路由配置</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-15T01:32:33.000Z" title="发表于 2021-11-15 09:32:33">2021-11-15</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-08T12:30:10.848Z" title="更新于 2021-12-08 20:30:10">2021-12-08</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%BD%91/">计网</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/route/">route</a></span></div><div class="content">

如果文中有什么纰漏或错误的话，请留言指正！！！

实验四：RIP与OSPF动态路由配置
按照书上内容配置：

RIP：P220 ~ P227【RIP协议排错】也要做
OSPF：P235 ~ P24



两个协议配置，放到一个 Word 文档里就行
还有实验文件（pkt）用一个也行，上面是 RIP 下面是 OSPF，如图所示


实验内容
RIP动态路由协议

配置RIP协议

学会查看路由表

观察RIP协议路由更新活动

测试RIP协议健壮性

RIP协议排错



OSPF动态路由协议

配置OSPF协议

查看OSPF协议三张表

监控OSPF协议的活动

验证OSPF协议的健壮性

OSPF协议配置排错




RIP 协议配置
首先做第一个动态路由协议 RIP


由于前面做了 3 次实验了，这里省略一些细节，直接在图上标注好各个网段以及各个接口的IP地址和子网掩码


根据拓扑图搭建好框架

路由器可选：PT-Router
交换机可选：2950T
路由器相连可选不带时钟频率的线Serial DTE



然后根据上图写好的各个接口的 IP 地址以及子网掩码给路由器和 PC 配置好（交换机不用配置）

注意：PC 主机要设置网关，这里的网关就是路由器与交换机相连的那个出口：比如 PC1 的网关就是路由器1 fa0/0 的 IP 地址


配置前先给路由器重命名，以免混淆。当然不命名也行（/滑稽）

初次打开直接输入 no 跳过一些设置

下面演示一个路由器，其他自行配置，不要手误打错数字了（/滑稽）


给每个路由器配置 RIP 协议
前面只是给各个接口分配了 IP 地址，以及给 PC 主机设置了网关等信息，易知，两台 PC 是不能通信的
提示目的主机不可到达

接下配置 RIP 协议使之任意终端设备都能通信

R1


R2


R3

我这里忘记打version 2了，自行打上去，不打的话后续 RIP 协议学习到的路由记录可能不完全



R4


R5

我这里忘记打version 2了，自行打上去，不打的话后续 RIP 协议学习到的路由记录可能不完全





查看路由表
1234# 查看整张路由表$ show ip route# 只查看RIP协议路由表$ show ip route rip
查看 R1 的整张路由表

仅仅查看 R1 路由器 RIP 协议学到的路由
可以发现除了 R1 的直连网段，其他的网段都通过 RIP 协议学习到了

下面查看其他路由器的通过 RIP 协议学到的路由
通过分析路由表可以知道，每个路由器通往其他网段的路由都有了


测试两台电脑是否可通信
PC1 ping PC2 可通信


观察 RIP 协议路由更新活动
1234# 观察 RIP 协议路由更新活动$ debug ip rip# 关闭诊断输出$ undebug all


记得用 undebug all 命令关闭，不然一直会输出信息


测试 RIP 协议健壮性
动态路由会随着网络的变化重新生成到各个网络的路由，当最佳路径没有了，就会从备用路径中重新选择一个最佳路径。
下面测试一下 PC1 到 PC2 的数据包路径
在 PC1 上，用tracert 192.168.3.1命令跟踪到 PC2 的数据包路径，可以看到数据完整路径是PC1-&gt;R1-&gt;R2-&gt;R3-&gt;PC2


接下来用一个方法观察路由表更新过程

先在 R3 上启用 RIP 协议诊断
然后用 shutdown命令关闭 R2 左边的接口（物理断开一样的）

然后将高亮部分的路由记录通过 RIP 协议的合并规则合并后即可得到最新的路由表，192.168.1.0 网段是无法到达的


再次测试从 PC1 到 PC2 的数据包路径

可以看到数据完整路径是PC1-&gt;R1-&gt;R4-&gt;R5-&gt;R3-&gt;PC2


RIP 协议排错

先把 R2 左边的接口开启，因为上一步关闭了


下面查看路由器的 RIP 协议配置

如果我们在配置 R1 路由器的 RIP 协议时，network 少写了一个 192.168.0.0，其他路由器就不能学习到到该网段的路由
下面取消添加到 192.168.0.0 的网段，该网段不再参与 RIP 协议

然后再 R3 路由器上查看 RIP 协议学到的路由，可以看到已经没有到 192.168.0.0/24 网段的路由了




OSPF 协议配置
拓扑图和 RIP 的一样

我这里是直接复制（CV 大法好/滑稽） RIP 协议的，然后把 RIP 协议关闭一下就行了（或者前面配置好 IP 之后就复制，然后就不用关闭 RIP 协议的了）
关闭 RIP 协议如下图，剩下的 R2、R3、R4、R5 都要关闭 RIP 协议，不在赘述




配置 OSPF 协议

OSPF 配置方法


下面对 R1 ~ R5 进行 OSPF 配置

R1


R2


R3


R4


R5




查看 OSPF 协议三张表

邻居表、链路状态数据库表、路由表



邻居表
查看 R1 的邻居表


链路状态数据库表
查看 R1 的链路状态数据库表


路由表
查看 R1 的路由表（OSPF 生成的）




监控 OSPF 的活动

前面 RIP 协议是观察路由更新活动

下面对 OSPF 进行监控，有两个选项，adj 似乎没啥输出信息，就只查看 events 信息

查看 events 信息（事件信息）


验证 OSPF 协议健壮性
当网络的链路状态发送改变后，OSPF协议会迅速通过泛洪更新链路状态，每个路由器单独计算到各个网段的路由
下面验证 OSPF 协议的健壮性
测试一下 PC1 到 PC2 的数据包路径，可以看到数据完整路径是PC1-&gt;R1-&gt;R2-&gt;R3-&gt;PC2

然后关闭 R1 与 R2 之间的链路：只需要把 R2 左边接口shutdown即可（或者把 R1 右边接口 shutdown）

再测试一下 PC1 到 PC2 的数据包路径，可以看到数据完整路径是PC1-&gt;R1-&gt;R4-&gt;R5-&gt;R3-&gt;PC2

做完之后重新把 R2 左边接口打开

OSPF 协议配置排错
如果配置了网络中的路由器使用 OSPF 协议，但是查看路由表发现有些网段没有通过 OSPF 学习到，就需要检查路由器接口是否配置了正确的 IP 地址和子网掩码，要是串口还要检查是否配置了时钟频率。进行了这些常规检查，还要检查 OSPF 协议的配置。
输入 show ip protocols能够显示动态路由协议的配置

由于这里我们添加的是一个比较大的网段192.168.0.0/16所以这里只有一条 Networks，如果是单独添加就不止一条
总之出现问题之后可以先看下 OSPF 配置是否正确


</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/10/31/%E5%AE%9E%E9%AA%8C%E4%B8%89%E2%80%94%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E4%B8%8E%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/" title="实验三：子网划分与静态路由">实验三：子网划分与静态路由</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-31T04:32:33.000Z" title="发表于 2021-10-31 12:32:33">2021-10-31</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-01T13:06:05.319Z" title="更新于 2021-12-01 21:06:05">2021-12-01</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%BD%91/">计网</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/route/">route</a></span></div><div class="content">

如果文中有什么纰漏或错误的话，请留言指正！！！

实验三：子网划分与静态路由实验步骤
根据拓扑图搭建框架

路由器选择 PT-Router
交换机选择 2950T
路由器之间连接线可选择带时钟频率的Serial DCE线或者不带时钟频率的线Serial DTE
带时钟频率的线多一步设置频率，不带时钟频率的线不用设置
下面的配置都是针对我这种连线方式进行（比如我中间路由器左边用 Se2/0 口，右边用 Se3/0 口），如你的连线方式不同，找到对应接口配置即可



子网划分

该拓扑图中一共有 5 个区域（见下图）
N1 区域有 100 台电脑
N2 区域有 50 台电脑
N3 区域有 25 台电脑
N4 区域为两端路由器，包括 2 个地址
N5 区域为两端路由器，包括 2 个地址


现我们有一个 C 类地址 192.168.1.0 255.255.255.0，需要给这 5 个区域分配不同的网段

N1 100 台电脑可分配 128 个可用地址给它

N2 50 台电脑可分配 64 个可用地址给它

N3 25 台电脑可分配 32 个可用地址给它

N4 和 N5 都只有两个地址，可分配 2 个可用地址给它


根据上面分析，我们可以把地址写出来理解一下怎么分给这 5 个区域
12345678910111213141516171819202122232425262728293031323334353637383940414243444546我们现在拥有 256 个地址256 个地址如下，前面三段用十进制表示，最后一段用二进制表示        ==========以下4个地址给-&gt;N4===========        192.168.1.00000000  --&gt; 192.168.1.0        192.168.1.00000001  --&gt; 192.168.1.1        192.168.1.00000010  --&gt; 192.168.1.2        192.168.1.00000011  --&gt; 192.168.1.3        ===================================        ==========以下4个地址给-&gt;N5===========        192.168.1.00000100  --&gt; 192.168.1.4        192.168.1.00000101  --&gt; 192.168.1.5        192.168.1.00000110  --&gt; 192.168.1.6        192.168.1.00000111  --&gt; 192.168.1.7        ===================================        192.168.1.00001000  --&gt; 192.168.1.8        192.168.1.00001001  --&gt; 192.168.1.9        ..............        ==========以下32个地址给-&gt;N3==========        192.168.1.00100000  --&gt; 192.168.1.32        192.168.1.00100001  --&gt; 192.168.1.33        192.168.1.00100010  --&gt; 192.168.1.34        ..............        192.168.1.00111110  --&gt; 192.168.1.62        192.168.1.00111111  --&gt; 192.168.1.63        ====================================        ..............        ===========以下64个地址给-&gt;N2==========        192.168.1.01000000  --&gt; 192.168.1.64        192.168.1.01000001  --&gt; 192.168.1.65        192.168.1.01000010  --&gt; 192.168.1.66        ..............        192.168.1.01111110  --&gt; 192.168.1.126        192.168.1.01111111  --&gt; 192.168.1.127        =====================================        ..............        ===========以下128个地址-&gt;N1===========        192.168.1.10000000  --&gt; 192.168.1.128        192.168.1.10000001  --&gt; 192.168.1.129        192.168.1.10000010  --&gt; 192.168.1.130        ..............        192.168.1.11111111  --&gt; 192.168.1.252        192.168.1.11111111  --&gt; 192.168.1.253        192.168.1.11111110  --&gt; 192.168.1.254        192.168.1.11111111  --&gt; 192.168.1.255        =====================================


补充常用二进制对应十进制数




二进制
十进制



1000 0000
128


1100 0000
192


1110 0000
224


1111 0000
240


1111 1000
248


1111 1100
252


1111 1110
254


1111 1111
255


这样就实现了地址的分配，然后进行子网划分，每一段地址表示一个子网，因此可得到下表



区域
网段
子网掩码
CIDR值



N1
191.168.1.0
255.255.255.252
/30


N2
191.168.1.4
255.255.255.252
/30


N3
191.168.1.32
255.255.255.224
/27


N4
191.168.1.64
255.255.255.192
/26


N5
191.168.1.128
255.255.255.128
/25



规划好给各个接口分配什么 IP 地址

经过上面的分析，划分了 5 个子网，现在将他们填写到图上便于后续分配 IP 地址给各个接口



到这一步已经知道了每个区域的 IP 地址范围，但是有个细节就是：主机号全为 ‘0’ 和全为 ‘1’ 的地址不可分配，一个是网络地址，一个是广播地址
下面举例说明

N1 
N1 网段的子网掩码为 255.255.255.128
第四段写为为二进制   255.255.255.10000000
子网掩码为 1 的位表示网络位，为 0 的位表示会主机位
所以该网段的主机位为后面 7 位，也就是黄色框住的
所以当主机位全为 ‘0’ 时 IP 地址为 192.168.1.128
​                  全为 ‘1’ 时 IP 地址为 192.168.1.255
那么这两个 IP 地址都不可以分配给接口使用
可分配 IP：192.168.1.129 ~ 192.168.1.254



N2
同理，黄色区域为主机位
不可以分配 IP 为：192.168.1.64 和 192.168.1.127
可分配 IP：192.168.1.65 ~ 192.168.1.126



N3、N4、N5 如图
黄色为主机号，两个红色 IP 不可分配




知道每个网段都有两个地址（主机号全为 0 和 1）不可以分配后，先规划好各个接口分配哪个 IP
我的分配思路：每个网段的可分配 IP 的前两个给 PC 主机，最后一个给路由器与交换机的接口，当然 N4 和 N5 只有两个可用 IP 刚好分配给两个接口
具体如图




给每个接口分配 IP 地址

先配路由器，从左到右依次改名为：R1、R2、R3


R1：配置两个接口：fa0/0、se2/0


R2：配置三个接口：fa0/0、se2/0、se3/0，并且给 se2/0 和 se3/0 设置时钟频率为 64000


R3：配置两个接口：fa0/0、se2/0




然后手动配置 PC IP地址、子网掩码和网关，网关就是连接的路由器的那个接口 IP


PC1 和 PC2


PC3 和 PC4


PC5 和 PC6




测试在同一个子网的 PC 是连通的，在不同子网是不连通的

同一子网测试通信
PC1 ping PC2 通
R1 ping PC1 和 PC2 通




不同子网测试通信
PC1 ping PC3、PC5 均不通
R1 ping PC3、PC5 均不通




路由器之间 ping，R1 和 R2 通、R1 和 R3 不通、R2 和 R3 通


配置静态路由表达到全部可通信

配置路由表双向都要配，不然配一方的话，数据能传过去，但是对方发送数据传不过来


R1：需要配置两条静态路由，一条是针对 N2 子网，一条是针对 N3 子网


R2：也需要两条，一条是针对 N1 子网，一条是针对 N3 子网


R3：也需要两条，一条是针对 N1 子网，一条是针对 N2 子网




由于 N1 子网设备向 N2 和 N3 子网设备通信都是通过 R2 的 se2/0 转发出去，那么可以使用默认路由简化添加路由表的条目
同理，N3 子网也可以设置默认路由
但是 R2 不可以设置默认路由，因为它连接了两个路由，必须指定通往子网的下一跳


对 R1 路由器配置：先删除原先配置的两条路由记录，再添加默认路由



对 R3 路由器配置：先删除原先配置的两条路由记录，再添加默认路由




配置好路由表之后，测试任何两台 PC 主机都是连通的

PC1 ping PC3 和 PC5 均通



PC3 ping PC1 和 PC5 均通



PC5 ping PC1 和 PC3 均通



最后整理一下拓扑图



补充知识
IP 地址分类
12345678910111213141516171819202122232425262728293031323334A 类地址：为高位为 0网络号全零不可用00000000 00000000 00000000 00000000 --&gt; 0.0.0.000000000 00000000 00000000 00000001 --&gt; 0.0.0.1.... .... .... ....00000000 11111111 11111111 11111110 --&gt; 0.255.255.25400000000 11111111 11111111 11111111 --&gt; 0.255.255.255==================可用地址区间=====================00000001 00000000 00000000 00000000 --&gt; 1.0.0.000000001 00000000 00000000 00000001 --&gt; 1.0.0.1	可用的最小IP00000001 00000000 00000000 00000010 --&gt; 1.0.0.2.... .... .... ....#########################私有地址########################00001010 00000000 00000000 00000000 --&gt;  10.0.0.000001010 00000000 00000000 00000001 --&gt;  10.0.0.1.... .... .... ....00001010 11111111 11111111 11111101 --&gt;  10.255.255.25300001010 11111111 11111111 11111110 --&gt;  10.255.255.25400001010 11111111 11111111 11111111 --&gt;  10.255.255.255#######################################################.... .... .... ....01111110 11111111 11111111 11111101 --&gt; 126.255.255.25301111110 11111111 11111111 11111110 --&gt; 126.255.255.254	可用的最大IP01111110 11111111 11111111 11111111 --&gt; 126.255.255.255=======================================================网络号为127的作为保留网段01111111 00000000 00000000 00000000 --&gt; 127.0.0.001111111 00000000 00000000 00000001 --&gt; 127.0.0.101111111 00000000 00000000 00000010 --&gt; 127.0.0.2.... .... .... ....01111111 11111111 11111111 11111101 --&gt; 127.255.255.25301111111 11111111 11111111 11111110 --&gt; 127.255.255.25401111111 11111111 11111111 11111111 --&gt; 127.255.255.255
1234567891011121314151617B 类地址：最高位为 1010000000 00000000 00000000 00000000 --&gt; 128.0.0.010000000 00000000 00000000 00000001 --&gt; 128.0.0.1	可用的最小IP10000000 00000000 00000000 00000010 --&gt; 128.0.0.2.... .... .... ....#########################私有地址########################10101100 00010000 00000000 00000000 --&gt; 172.16.0.010101100 00010000 00000000 00000001 --&gt; 172.16.0.1.... .... .... ....10101100 00011111 11111111 11111101 --&gt; 172.31.255.25310101100 00011111 11111111 11111110 --&gt; 172.31.255.25410101100 00011111 11111111 11111111 --&gt; 172.31.255.255#######################################################.... .... .... ....10111111 11111111 11111111 11111101 --&gt; 191.255.255.25310111111 11111111 11111111 11111110 --&gt; 191.255.255.254	 可用的最大IP10111111 11111111 11111111 11111111 --&gt; 191.255.255.255
1234567891011121314151617C 类地址：最高位为 11011000000 00000000 00000000 00000000 --&gt; 192.0.0.011000000 00000000 00000000 00000001 --&gt; 192.0.0.1	可用的最小IP11000000 00000000 00000000 00000010 --&gt; 192.0.0.2.... .... .... ....#########################私有地址########################11000000 10101000 00000000 00000000 --&gt; 192.168.0.011000000 10101000 00000000 00000001 --&gt; 192.168.0.1.... .... .... ....10101100 10101000 11111111 11111101 --&gt; 192.168.255.25310101100 10101000 11111111 11111110 --&gt; 192.168.255.25410101100 10101000 11111111 11111111 --&gt; 192.168.255.255#######################################################.... .... .... ....11011111 11111111 11111111 11111101 --&gt; 223.255.255.25311011111 11111111 11111111 11111110 --&gt; 223.255.255.254	 可用的最大IP11011111 11111111 11111111 11111111 --&gt; 223.255.255.255
12345678D 类地址：最高位为 111011100000 00000000 00000000 00000000 --&gt; 224.0.0.011100000 00000000 00000000 00000001 --&gt; 224.0.0.1	可用的最小IP11100000 00000000 00000000 00000010 --&gt; 224.0.0.2.... .... .... ....11101111 11111111 11111111 11111101 --&gt; 239.255.255.25311101111 11111111 11111111 11111110 --&gt; 239.255.255.254	 可用的最大IP11101111 11111111 11111111 11111111 --&gt; 239.255.255.255
12345678E 类地址：剩下的11110000 00000000 00000000 00000000 --&gt; 240.0.0.011110000 00000000 00000000 00000001 --&gt; 240.0.0.1	可用的最小IP11110000 00000000 00000000 00000010 --&gt; 240.0.0.2.... .... .... ....11111111 11111111 11111111 11111101 --&gt; 255.255.255.25311111111 11111111 11111111 11111110 --&gt; 255.255.255.254	可用的最大IP11111111 11111111 11111111 11111111 --&gt; 255.255.255.255



</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/10/22/vlan%E9%85%8D%E7%BD%AE/" title="实验二：vlan 配置以及 vlan 间通信">实验二：vlan 配置以及 vlan 间通信</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-22T04:32:33.000Z" title="发表于 2021-10-22 12:32:33">2021-10-22</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-15T16:45:23.688Z" title="更新于 2021-11-16 00:45:23">2021-11-16</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%BD%91/">计网</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/vlan/">vlan</a></span></div><div class="content">

如果文中有什么纰漏或错误的话，请留言指正！！！

实验二：vlan 配置以及 vlan 间通信
步骤如下


根据拓扑图搭建好框架


FastEthernet是百兆以太网口
GigbitEthernet是千兆以太网口


后面的配置中需要知道每台 PC 主机连接到交换机的接口编号，如果没有，到设置中打开



配置 vlan

step1：对各个主机划分不同 vlan ，根据此实验要求，vlan 划分见下表



主机名称
处于哪一个 vlan



PC0
vlan 1


PC1
vlan 1


PC2
vlan 2


PC3
vlan 3


PC4
vlan 4


PC5
vlan 2



step2：将 PC 主机划分到所处的 vlan 中

在进行 vlan 划分之前，可以先把信息填写到拓扑图上，这样更清晰



先对左边交换机进行 vlan 划分的配置
先改名为 S1 （为了区分并记忆）



用命令 show vlan 查看交换机 vlan 配置



可以看到交换机的各个接口默认处于 vlan 1
因此交换机连接的 PC0 和 PC1 接口不用进行 vlan 配置（它们所处的交换机接口默认为 vlan 1）
下面将 PC2 配置到 valn 2 上

先创建 vlan 2

然后把 PC2 划分（设置）到 vlan 2 中


经过上面的演示知道怎么创建 vlan 和划分 vlan，下面简单对右边交换机配置下

先创建 vlan 2、vlan 3、vlan 4

然后根据拓扑图上的注释对各个 PC 主机划分到对应 vlan 中
PC3(fa0/1) -&gt; vlan 3
PC4(fa0/2) -&gt; vlan 4
PC5(fa0/3) -&gt; vlan 2




vlan 划分好了，现在给每个 vlan 分配网段，以及给每个 PC 主机静态分配 IP地址

下面表格一些高亮的数字：91、92、93、94 就是分配给大家的网段，每个人都不同，使用自己的数字分配即可


同一 vlan 下的 PC 主机的 IP 需要和该 vlan 网段一致
比如 vlan 1 设置为 192.168.91.0，那么所处该 vlan 1 的 PC0 和 PC1 这两台主机的 IP 前面三位固定就是 192.168.91，最后是主机号，自己分配
这里分配 100、110、120、130、140、150，只是为了与 PC 编号对应




主机名称
主机 IP
处于哪一个 vlan
各个 vlan 的网段



PC0
192.168.91.100
vlan 1
192.168.91.0    255.255.255.0


PC1
192.168.91.110
vlan 1
192.168.91.0    255.255.255.0


PC2
192.168.92.120
vlan 2
192.168.92.0    255.255.255.0


PC3
192.168.93.130
vlan 3
192.168.93.0    255.255.255.0


PC4
192.168.94.140
vlan 4
192.168.94.0    255.255.255.0


PC5
192.168.92.150
vlan 2
192.168.92.0    255.255.255.0


然后将这些信息填写上去，便于后续配置

其实 vlan 的网段并不需要设置，只是规定这个区间就是 vlan 1，那个区间就是 vlan 2 ……
只需要对 PC 设置 IP 地址，下面演示一个，剩余 5 个自行配置


都设置好了之后，验证不同 vlan 间的计算机不能通信

如果没有配错的话，现在只有 PC0 和 PC1 是可通信的，因为他们同属一个 vlan，并连接在一个交换机上



实现不同 vlan 间通信

step1：在三层交换机上也要创建相应的 vlan （vlan 2、vlan 3、vlan 4）


step2：给每一个 vlan 的虚接口配置 ip 地址，该 ip 地址作为该网段的网关地址


设置好网关之后，为每台 PC 主机配置相对应的网关
可以先用 show run命令查看各个 vlan 的网关地址



这个也就是刚刚设置的，然后我们为每台 PC 主机设置网关，同一 vlan 网关相同
每台 PC 主机都要设置好





交换机相连的接口工作模式设置为trunk模式，并添加容许通过的 vlan

图中这些接口均要设置为 trunk 模式，即交换机互相连接的 4 个接口



先对 SW1交换机 的 g0/2 口设置为 trunk 工作模式



同理，设置 SW2交换机 的 g0/2 口



同理，对 L3SW1 交换机配置 g0/1 和 g0/2 口



此时，测试各个主机是否可通信，结果还是只有 PC0 和 PC1 可通信，其他均不可


最后，在三层交换机上启用路由功能，就可实现各个 vlan 间通信了


然后验证各个主机是否可通信，截图粘贴到 word 中


不出意外每台主机都是可以互相通信的，如果发现不能互通，检查自己是否哪里少了步骤，或者哪里配置错误




最后：交换机配置好了记得用 write memory 保存
不保存的话，你关闭了软件之后重新打开这个实验文件（pkt 文件），前面对交换机的配置就都没有了！！！



</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/10/10/Wallpaper%20Engine%20%E5%A3%81%E7%BA%B8%E6%8F%90%E5%8F%96/" title="Wallpaper Engine 壁纸提取">Wallpaper Engine 壁纸提取</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-10-10T02:32:33.000Z" title="发表于 2021-10-10 10:32:33">2021-10-10</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-11T03:11:43.751Z" title="更新于 2021-10-11 11:11:43">2021-10-11</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%A3%81%E7%BA%B8/">壁纸</a></span></div><div class="content">

如何把 Wallpaper Engine 壁纸提出出来？
看到一个博客说是找到 GitHub 上一个开源项目，然后本地编译，利用编译好的程序代码，然后写好脚本
具体教程 https://www.zhihu.com/question/277034435
下面记录一下操作过程，使用更加简单


将开源项目：https://github.com/notscuffed/repkg  拉取到本地

然后用 Visual Studio 打开这个箭头文件


执行不调试


这个目录就是一些编译后的文件，我们可以把这些文件复制到一个容易找到的地方（就放这里也可以，强迫症想换一个位置）
我是放到了 E:\Tools\pkgToPng


写一个脚本文件（.bat 文件）和编译后的文件放在一起：名称任取


如 pkg.bat 内容如下

两个 move 用来移动提取的壁纸到指定位置，比如我这里把壁纸就是移动到 E:\Tools\pkgToPng\photo 下
rd 是删除提取文件（因为提取文件不仅仅是一张壁纸，还有很多个文件），这里不删除也行，但是还是删除一下，占空间
然后 explorer 后面带的是需要打开的文件目录
exit 退出终端
123456&quot;RePKG.exe&quot; extract ./scene.pkgmove output\materials\*.jpg E:\Tools\pkgToPng\photomove output\materials\*.png E:\Tools\pkgToPng\photord output /s /qexplorer E:\Tools\pkgToPng\photoexit
然后我们把这个路径添加环境变量，便于后面用 CMD 使用该脚本


使用方法
先在 Wallpaper Engine 找到壁纸在文件管理器打开

然后在此路径下打开 CMD

之后输入上面脚本的名称，我这里是 pkg.bat 


success


</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/09/27/%E9%80%9A%E4%BF%A1%E5%9F%BA%E7%A1%80/" title="通信技术[基础]">通信技术[基础]</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-27T02:32:33.000Z" title="发表于 2021-09-27 10:32:33">2021-09-27</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-11T03:10:31.475Z" title="更新于 2021-10-11 11:10:31">2021-10-11</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E9%80%9A%E4%BF%A1/">通信</a></span></div><div class="content">
通信技术演变图

改图截取自：https://www.bilibili.com/video/BV1hE411P7k3?spm_id_from=333.999.0.0

FDD 与 TDDFDD：频分复用，上行和下行的频率不同，互不干扰，可以同时传送数据（双车道）
TDD：时分复用，上行和下行使用一样的频率，不可以同时传送数据（单车道）

技术家族最上面一条是 3GPP 家族、中间是高通家族，目前电信的 2G、3G 在使用这个技术，最下面是 WiMax 家族，目前手机上似乎没有涉及到该通信技术

三大运营商



2G
3G
4G



移动
GSM、GPRS、EDGE
TD-SCDMA
TDD-LTE、FDD-LTE


联通
GSM、GPRS、EDGE
WCDMA
FDD-LTE


电信
CMDA 1x
CMDA 2000
FDD-LTE



移动现已没有了 3G（TD-SCDMA），从 18 年开始部署 FDD-LTE 技术

单卡双待、VoLTE和CSFB 技术
4G 的 LTE 技术只是用于上网，并不可以进行语音通话，那么当你正使用 4G 网络时候，来了一个电话要怎么接听呢？
4G 本身是不可以进行语音通话，2、3G 可以，所以我们就要将网络转变为 2/3G

CSFB 技术就是实现在接听电话的时候将 4G 网络退回到 2/3G 
如果不可以回落的话，比如电信的 2/3G 使用的是高通的技术，但是 4G 使用的是 3GPP 技术，其不可以直接从 4G 到 3G，那么要打电话就要用 单卡双待 技术实现
移动：由于现在没有了 3G 所以打电话的时候网络就会回落到 2G 
联通：打电话网络回落到 3G
电信：技术不同，不能直接回落到 3G，使用了 单卡双待 技术就是同时会有两个网络频段，比如通知栏（LTE\1X）
单卡双待和 CSFB 都有缺陷，后来出现了 VoLTe 技术，VoLTE 就可以不回退网络直接在 4G 网络下打电话
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/09/27/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84/" title="网络是怎样连接的">网络是怎样连接的</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-27T02:32:33.000Z" title="发表于 2021-09-27 10:32:33">2021-09-27</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-23T06:39:16.095Z" title="更新于 2021-10-23 14:39:16">2021-10-23</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E4%B9%A6%E7%B1%8D/">书籍</a></span></div><div class="content">

从在浏览器中输入网址，到屏幕上显示出网页的内容，在这个只有几秒钟的过程中，很多硬件和软件都在各自的岗位上相互配合完成了一系列的工作。本书将以探索之旅的形式，带领大家探索这一系列工作中的每一个环节。每个单独的环节都并不复杂，只要仔细阅读就一定能够理解。不过，探索之旅中出现的硬件和软件数量庞大，如果仅从微观的视角关注每一个单独的点，可能就会因为看不到整体而迷失了方向。因此，在真正出发开始探索之前，我们先来对这次探索之旅作个简单的介绍。下面的介绍中还包含一张探索之旅的路线图，万一在旅途中迷失了方向，请大家务必回来看一看这张地图



大纲，章节目录


Web 浏览器
协议栈、网卡
集线器、交换机、路由器
接入网、网络运营商
防火墙、缓存服务器
Web 服务器


本书关键字，按照章节


浏览器生成消息
浏览器、Web 服务器、网址（URL）、HTTP、HTML、协议、URI、请求消息、解析器、Socket 库、DNS 服务器、域名

用电信号传输 TCP/IP 数据




第一章 浏览器生成消息
qu：浏览器等网络应用程序实际上并不具备网络控制功能

应用程序并不是自己控制网络，而是委托操作系统（协议栈）来控制网络
1.1 生成 HTTP 请求消息1.1.1 输入网址开始URL 会以 http:、ftp:、file:、mailto: 等作为开头，简单理解为这些开头是给浏览器一个访问方法，告诉浏览器访问的是什么服务器。比如 ”http:“ 访问 Web 服务器、”ftp:“ 访问 FTP 服务器。我们把这些开头文字理解为协议类型（HTTP 协议、FTP 协议等）
通常 URL 会包含服务器的域名和要访问的文件的路径名而发邮件的 URL 则包含收件人的邮件地址，此外，根据需要，URL 中还会包含用户名、密码、服务器端口号等信息。

1.1.2 浏览器解析 URL

1.1.3 省略文件名情况
浏览器的第一步工作就是对 URL 进行解析


http://www.lab.glasscom.com/dir/
很清楚，访问 dir 目录下设置的默认文件，大多数情况是 index.html、default.htm

http://www.lab.glasscom.com/
访问 / 目录下的默认文件

http://www.lab.glasscom.com
没有写目录，代表访问根目录下事先设置的默认文件

http://www.lab.glasscom.com/whatisthis
whatisthis 后面没有 /很容易理解为是一个文件，其实实际上很多人会把目录后面的/省略不写。所以这种情况下，如果 Web 服务器上存在名为 whatisthis 的文件，就当做文件名处理，如果存在名为 whatisthis 的目录，就当做目录名来处理

我们无法创建两个名字相同的文件和目录，因此不可能既有一个名为 whatisthis 的文件，同时又有一个名为whatisthis 的目录。只要查询一下磁盘中的文件和目录，就可以知道whatisthis 究竟是一个文件还是一个目录了，并不会产生歧义。



1.1.4 HTTP 基本思路解析完 URL 之后，我们就知道应该要访问的目标在哪里了。接下来，浏览器会使用 HTTP 协议来访问 Web 服务器。
HTTP 协议定义了客户端和服务器之间交互的消息内容和步骤，其基本思路非常简单。
首先，客户端会向服务器发送请求消息（图1.4）。请求消息中包含的内容是“对什么”和“进行怎样的操作”两个部分。其中相当于“对什么”的部分称为 URI。一般来说，URI 的内容是一个存放网页数据的文件名或者是一个 CGI 程序的文件名，例如“/dir1/file1.html” “/dir1/program1.cgi”等。不过，URI 不仅限于此，也可以直接使用“http:”开头的 URL 来作为URI。换句话说就是，这里可以写各种访问目标，而这些访问目标统称为 URI。相当于接下来“进行怎样的操作”的部分称为方法。方法表示需要让 Web 服务器完成怎样的工作，其中典型的例子包括读取 URI 表示的数据、将客户端输入的数据发送给 URI 表示的程序等。

响应消息的状态码（详情）表示操作的执行结果是成功还是错误，比如找不到文件就显示 404 Not Found 的错误信息



GET 方法能够发送的数据只有几百个字节，如果表单中的数据超过这一长度，则必须使用POST 方法来发

1.1.5 生成 HTTP 请求消息请求消息是从在浏览器顶部的地址栏中输入网址开始的，但浏览器并非只有在这一种场景下才会向Web 服务器发送请求消息。比如点击网页中的超级链接，或者在表单中填写信息后点击“提交”按钮，这些场景都会触发浏览器的工作，而选用哪种方法也是根据场景来确定的。


第一行：末尾要写上 HTTP 的版本号，为了表示该消息是基于哪个版本的 HTTP 规格编写的
第二行：称为 消息头，保存一些额外的详细信息。消息头的规格中定义了很多项目，如日期、客户端支持的数据类型、语言、压缩格式、客户端和服务器的软件名称和版本、数据有效期和最后更新时间等
写完消息头之后，还需要添加一个完全没有内容的空行，然后写上需要发送的数据。这一部分称为消息体，也就是消息的主体。不过，在使用 GET 方法的情况下，仅凭方法和 URI，Web 服务器就能够判断需要进行怎样的操作，因此消息体中不需要填写任何数据。消息体结束之后，整个消息也就结束了


表单请求消息在 HTML 中的代码


1.1.6 发送请求后会收到响应响应消息的格式以及基本思路和请求消息是相同的（图1.5（b）），差别只在第一行上。在响应消息中，第一行的内容为状态码和响应短语，用来表示请求的执行结果是成功还是出错。状态码和响应短语表示的内容一致，但它们的用途不同。状态码是一个数字，它主要用来向程序告知执行的结果（表1.3）；相对地，响应短语则是一段文字，用来向人们告知执行的结果。
返回响应消息之后，浏览器会将数据提取出来展现在屏幕上，如果这个网页之后文字就结束了，如果里面还有图片资源，浏览器就还要给 Web 服务器发送请求消息。由于每条请求消息只能写一个 URI，即每次只能能获取一个文件，所以有多少张图片就要发送多少个请求消息。
判断所需的文件，然后获取这些文件并显示在屏幕上，这一系列工作的整体指挥也是浏览器的任务之一，而 Web 服务器却毫不知情。Web 服务器完全不关心这 4 条请求获取的文件到底是 1 个网页上的还是不同网页上的，它的任务就是对每一条单独的请求返回 1 条响应而已。

1 条请求消息中只能写1 个URI。如果需要获取多个文件，必须对每个文件单独发送1 条请求。


示例：我们需要获取一张名为 sample1.htm 的网页，网页中包含一张名为 picture.jpg 的图片


1.2 向 DNS 服务器查询 Web 服务器的 IP 地址1.2.1 IP 地址的基本知识生成了 HTTP 消息之后，我们就要委托操作系统的协议栈将消息发送给 Web 服务器，虽然浏览器能够解析网址生成 HTTP 消息，但是不具备将消息发送到网络的功能
但是在此之前我们还需要一个工作，就是将服务器的域名转化为 IP 地址，这样才能访问到域名所指向的服务器。

IP 的表示方法

32 位二进制数，每 8 个为一组（即化为十进制最大为 2^8^ - 1 = 255），习惯上转化为十进制数
/后面为子网掩码，与 IP 地址一样是 32 位二进制数，子网掩码为 1 的部分表示网络号，子网掩码为 0 的部分表示主机号。将子网掩码按照和 IP 地址一样的方式以每 8 比特为单位用圆点分组后写在 IP 地址的右侧。
子网掩码的两种写法：

10.11.12.13/255.255.255.0
10.11.12.13/24

后者 24 即表示从左边数有多少个 1，3 组 8 位即有 24 个 1


顺带一提，主机号部分的比特全部为 0 或者全部为 1 时代表两种特殊的含义
IP 地址的主机号

全 0：表示整个子网
全 1：表示向子网上所有设备发送包，即“广播”

1.2.2 IP 和 子网掩码并用理由1.2.3 Socket 库提供查询 IP 地址的功能
Socket 库是用于调用网络功能的程序组件集合


DNS：Domain Name System，域名服务系统。将服务器名称和 IP 地址进行关联是 DNS 最常见的用法
通过 DNS 查询 IP 地址的操作称为域名解析，因此负责执行解析（resolution）这一操作的就叫解析器（resolver）了
解析器实际上是一段程序，它包含在操作系统的 Socket 库中，Socket 库中包含很多用于发送和接收数据的程序组件

我们电脑本地具有 DNS 客户端（DNS 解析器），可以进行更改，全国DNS服务器IP大全

1.2.4　通过解析器向 DNS 服务器发出查询在编写浏览器等应用程序的时候，只要像图1.11 这样写上解析器的程序名称“gethostbyname”以及Web 服务器的域名“www.lab.glasscom.com”就可以了，这样就完成了对解析器的调用
浏览器在向 Web 服务器发送消息时，只要从该内存地址取出 IP 地址，并将它与 HTTP 请求消息一起交给操作系统就可以了


根据域名查询IP 地址时，浏览器会使用Socket 库中的解析器。

1.2.5　解析器的内部原理
1.3 全世界 DNS 服务器的大接力1.3.1 DNS 服务器的基本工作客户端的查询方式包括 3 种信息

域名：服务器、邮件服务器（邮件地址中@ 后面的部分）的名称
Class：在最早设计DNS 方案时，DNS 在互联网以外的其他网络中的应用也被考虑到了，而Class 就是用来识别网络的信息。不过，如今除了互联网并没有其他的网络了，因此Class 的值永远是代表互联网的IN
记录类型：表示域名对应何种类型的记录。例如，当类型为A 时，表示域名对应的是IP 地址；当类型为MX 时，表示域名对应的是邮件服务器。对于不同的记录类型，服务器向客户端返回的信息也会不同

DNS 服务器上事先保存有前面这3 种信息对应的记录数据，如图1.14所示。DNS 服务器就是根据这些记录查找符合查询请求的内容并对客户端作出响应的


例如，如果要查询www.lab.glasscom.com 这个域名对应的IP 地址，客户端会向 DNS 服务器发送包含以下信息的查询消息。（a） 域名 = www.lab.glasscom.com（b） Class = IN（c） 记录类型 = A


DNS 服务器会从域名与IP 地址的对照表中查找相应的记录，并返回IP 地址。

1.3.2　域名的层次结构我们知道 IP 是一串以点分隔的字符串，以点分隔成多个部分，每个部分对应该层次的 DNS 服务器
比如，全国是一个最大的域，中国是全国域中的一个子集，中国的省份是中国域中的一个子集，就这样层层分隔下去

实际上，由于一台DNS 服务器可以存放多个域的信息，因此并不是每个域名都有一台与之相对应的DNS 服务器。比如网络运营商的DNS 服务器中就存放了很多个域的信息

1.3.3　寻找相应的 DNS 服务器并获取 IP 地址根域几乎每个 DNS 服务器都保存有，只要访问任何一个 DNS 服务器都可以找到根域，来到根域然后一路找下去就可以找到需要查找的服务器 IP 了

分配给根域DNS 服务器的 IP 地址在全世界仅有 13 个，而且这些地址几乎不发生变化，因此将这些地址保存在所有的DNS 服务器中也并不是一件难事
根域 DNS 服务器在运营上使用多台服务器来对应一个 IP 地址，因此尽管 IP 地址只有13 个，但其实服务器的数量是很多的

下图客户端先访问最近的一台 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的DNS 服务器地址）


1.3.4　通过缓存加快DNS 服务器的响应通过上面的内容，并不是每个 DNS 服务器都只管理一个域，现实中上级域和下级域可能共享在一台 DNS 服务器中
此外，有时候并不需要从最上级的根域开始查找，因为 DNS 服务器有一个缓存功能，可以记住之前查询过的域名。如果要查询的域名和相关信息已经在缓存中，那么就可以直接返回响应，接下来的查询可以从缓存的位置开始向下进行。相比每次都从根域找起来说，缓存可以减少查询所需的时间

这个缓存机制中有一点需要注意，那就是信息被缓存后，原本的注册信息可能会发生改变，这时缓存中的信息就有可能是不正确的。因此，DNS 服务器中保存的信息都设置有一个有效期，当缓存中的信息超过有效期后，数据就会从缓存中删除。而且，在对查询进行响应时，DNS 服务器也会告知客户端这一响应的结果是来自缓存中还是来自负责管理该域名的 DNS 服务器

1.4 委托协议栈发送消息1.4.1　数据收发操作概览知道目标服务器的 IP 地址之后，浏览器就可以委托操作系统内部的协议栈向该 IP 地址的服务器发送 HTTP 请求消息了
HTTP 消息是一种数字信息（digital data），因此可以说是委托协议栈发送数字信息。收发数字信息的这一操作并不局限于浏览器，对于使用网络的应用程序都是共通的
和向DNS 服务器查询 IP 地址的操作一样，这里也需要使用 Socket 库中的程序组件。不过，查询 IP 地址只需要调用一个程序组件就可以了，而这里需要按照指定的顺序调用多个程序组件，这个过程有点复杂

向操作系统内部的协议栈发出委托时，需要按照指定的顺序来调用 Socket 库中的程序组件

收发数据的操作分为若干个阶段，可以大致总结为以下4 个

创建套接字（创建套接字阶段）
将管道连接到服务器端的套接字上（连接阶段）
收发数据（通信阶段）
断开管道并删除套接字（断开阶段）

1.4.2　创建套接字阶段
① 调用 Socke 库名为的 socket 程序组件就可以创建一个套接字了，套接字创建完成后，协议栈会返回一个描述符，应用程序会将收到的描述符放在内存中
描述符是用来识别不同的套接字的，可以理解为给套接字进行编号
当创建套接字后，我们就可以使用这个套接字来执行收发数据的操作了。这时，只要我们出示描述符，协议栈就能够判断出我们希望用哪一个套接字来连接或者收发数据了

应用程序是通过“描述符”这一类似号码牌的东西来识别套接字的





1.4.3　连接阶段：把管道接上去1.4.4　通信阶段：传递消息1.4.5　断开阶段：收发数据结束
第2章 用电信号传输TCP/IP 数据2.1 创建套接字2.1.1 协议栈的内部结构
比如我们要在两个端系统上传送数据，应用是在应用层，如何实现两个端系统在应用层进行数据收发，这就要借助传输层提供的服务
我们要传输给对方数据
第一：需要知道对方的 IP 地址以及端口号，常见的 Web 服务器端口号为 80
第二：自身的 IP 以及应用也需要传送给对方
应用层里面有应用，应用跑在某个主机上面，


2.1.2　套接字的实体就是通信控制信息2.1.3　调用socket 时的操作2.2　连接服务器2.2.1　连接是什么意思2.2.2　负责保存控制信息的头部</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/09/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/" title="编译原理">编译原理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-07T02:32:33.000Z" title="发表于 2021-09-07 10:32:33">2021-09-07</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-11-21T04:32:00.721Z" title="更新于 2021-11-21 12:32:00">2021-11-21</time></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%BA%95%E5%B1%82/">底层</a></span></div><div class="content">
第一章 引论
程序编译有几个阶段？各有什么功能？

词法分析：从源程序中一个个读取字符，识别一个个单词
语法分析
语义分析
中间代码生成
代码优化
目标代码生成


一个经典的编译程序由哪几部分组成？各有什么功能？

词法分析程序

语法分析程序

语义分析程序

中间代码生成程序

代码优化程序

目标代码生成程序

出错处理程序

表格管理程序




第二章 文法和语言
考点：文法、语言、短语、直接短语、句柄

文法的直观概念文法是一套规则集合，描述某一特征的符号串，可以说文法是以有穷的集合刻画无穷的集合的一个工具
符号和符号串
几个概念解释：


字母表（符号集）：元素的非空有穷集合，字母表中的元素称为符号。以汉语为例，汉语字母表就是各种汉字、数字、标点符号的集合；以英语为例，英语字母表就是各种字母、数字、标点符号的集合……那么到了编程，字母表就可能是字母、数字、各种专用符号和保留字了。

符号串：由字母表中的符号组成的任何 有穷序列 称为符号串
如 0101010001 就是字母表 A={0,1} 上的符号串
如果符号串 x 中有 m 个符号，称其长度为 m，记为 |x|=m，|ε|=0

符号串的头尾，固有头、固有尾
比如 x=abcd
x 的头：ε、a、ab、abc、abcd
x 的固有头：ε、a、ab、abc
x 的尾：ε、d、cd、bcd、abcd
x 的固有尾：ε、d、cd、bcd
头除去本身字符串就是固有头、尾除去本身字符串就是固有尾
以后算文法符号之间优先级会看到，好比 z=x··· 只关注它的头 x ，而对其他不予关注；z=···x··· 只关注符号 x 再某处地方出现

符号串集合：了解闭包和正闭包
有一个字母表 Σ，如何描述字母表 Σ 上的所有有穷长的符号串的集合
比如字母表 Σ={a,b}**，Σ** 上的所有有穷长的串的集合就是只包含有 Σ 字母表中的符号的字符串的集合，即 {ε,a,b,ab,ba,aa,bb,aab,···}，后面还有很多，只要是该符号串中的元素没有 Σ 外的字符就属于该集合。
用闭包表示这个集合 *Σ={ε,a,b,ab,ba,aa,bb,aab,···}，这样就表示了 **Σ 上的所有有穷长的串的集合
闭包：*Σ = Σ^0 ∪ Σ^1 ∪ Σ^2 ··· ∪ Σ^n ···**
正闭包(与闭包相比，单纯的少了一个 ε)：Σ+ = Σ^1 ∪ Σ^2 ··· ∪ Σ^n ···





文法和语言的形式定义
定义 2.1

文法 G 定义为四元组 (Vn, Vt, P, S)，Vn ∩ Vt = ∅

Vn：非终结符集
Vt：终结符集
P：为规则 (α–&gt;β) 的集合，α∈(Vn∪Vt)* 且至少包括一个非终结符，β∈(Vn∪Vt)*
S：识别符（开始符）


两个重要的定义：定义 2.5 和 定义 2.6 P23


定义 2.5：句型包括句子
句型，是指从文法G[S]的开始符S推导出来的符号串α，即S ⇒ *α
句子，如果句型 α 中不含有非终结符，则称串 α 是文法 G[S] 的句子

定义 2.6：语言就是文法描述对象的集合，也就是一切句子的集合。


文法的类型
G = (Vn, Vt, P, S)，P 中的产生式用 α–&gt;β 表示


0 型文法：文法的定义
1 型文法（上下文有关的）：0 型基础上，右部长度 &gt;= 左边长度 即 |β| &gt;= |α|
2 型文法（上下文无关的）：1 型基础上，左边只是一个非终结符
3 型文法（正规文法）：2 型基础上，规定右部只能是一个终结符或者一个终结符跟一个非终结符 即 文法只能是以下两种情形
A--&gt;aB
A--&gt;a




0 型号文法产生的语言：0 型语言
1 型文法产生的语言：上下文有关语言
2 型文法产生的语言：上下文无关语言
3 型文法产生的语言：正规语言

语法树
一种描述上下文无关文法的句型推导的直观工具，即语法树，也称推导树


文法：一套规则的集合，描述某一特征的符号串，以有穷的集合刻画无穷的集合的一个工具


什么是文法？
什么是语言？
什么是句型？什么是句子？（请举例回答）

第三章 词法分析单词的形式化描述工具正规文法(3型)
辅助字母表 Σ’={ ∅, ε, |, ., *, (, ) }
正规文法和正规式的等价性
将正规式转化成正规文法：P46
将正规文法转化为正规式：P47

有穷自动机
有穷自动机的 3 种表示方法：
五项定义、状态转化图、矩阵

确定的有穷自动机（DFA）
五元组定义
M=(K, Σ, f, S, Z)

K：一个有穷集，每个元素称为一个状态
Σ：一个有穷字母表，每个元素称为一个输入符号
f：转换函数，是 K x Σ -&gt; K 上的映像
S：S∈K，表示初态（只能有一个）
Z：Z⊆K，是一个终态集，也可称为接受状态或结束状态


状态图表示

矩阵表示


不确定的有穷自动机
五元组定义
Ｍ＝(K，Σ，f，S，Z)

Σ，K，Z的意义和ＤＦＡ的定义一样

f：转换函数，从 K x Σ* -&gt; 2^K 上的映像（2^K 表示 K 的幂集）
即f： K(Σ∪{ε})→2^k
 表示：f(q,a)={q1,q2,…,qk}
在状态转换图中,q向q1,q2,…,qk,各射出一条标记为a的箭弧。

S：S⊆K，表示有多个初态



对于每个 NFA M，存在一个 DFA M’，使得 L(M)=L(M’)


NFA 转换为等价的 DFA（子集法）DFA 的化简（分割法）正规式和有穷自动机的等价性
对于 Σ

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/08/23/EROOR/" title="平时遇到的错误">平时遇到的错误</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-23T01:29:57.000Z" title="发表于 2021-08-23 09:29:57">2021-08-23</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-26T06:32:46.830Z" title="更新于 2021-12-26 14:32:46">2021-12-26</time></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Windows/">-Windows</a></span></div><div class="content">
命令报错命令不存在
如
‘ipconfig’ 不是内部或外部命令，也不是可运行的程序或批处理文件。
netstat: The term ‘netstat’ is not recognized as a name of a cmdlet, function, script file, or executable program.Check the spelling of the name, or if a path was included, verify that the path is correct and try again.



解决方法

环境变量 Path 添加 %SystemRoot%\system32，然后重新启动程序


意外发现，我们没有添加%SystemRoot%\system32这个系统变量的时候，点开 Path是像上图那种
添加之后是会列表展开，更加的好操作


打开服务报错报错信息

System error 5 has occurred.
Access is denied.


解决方法
用管理员权限打开终端即可（搜索到终端，直接快捷键 Ctrl+Shift+Enter用管理员权限打开）


注意：因为我这里的 MySQL 的环境变量是放在了 管理员的变量中，所以我使用非管理员用户会报错

MySQL1366 报错 - 中文编码问题报错信息

ERROR 1366 (HY000): Incorrect string value: ‘\xE6\x9D\x8E\xE5\x8B\x87’ for column ‘Sname’ at row 1

解决方法

先查看表的编码
1234567891011121314$ SHOW FULL COLUMNS FROM table_name;-- 如mysql&gt; SHOW FULL COLUMNS FROM Student;+-------+-------------+-------------------+------+-----+---------+-------+---------------------------------+---------+| Field | Type        | Collation         | Null | Key | Default | Extra | Privileges                      | Comment |+-------+-------------+-------------------+------+-----+---------+-------+---------------------------------+---------+| Sno   | char(9)     | latin1_swedish_ci | NO   | PRI | NULL    |       | select,insert,update,references |         || Sname | char(20)    | latin1_swedish_ci | YES  | UNI | NULL    |       | select,insert,update,references |         || Ssex  | char(2)     | latin1_swedish_ci | YES  |     | NULL    |       | select,insert,update,references |         || Sage  | smallint(6) | NULL              | YES  |     | NULL    |       | select,insert,update,references |         || Sdept | char(20)    | latin1_swedish_ci | YES  |     | NULL    |       | select,insert,update,references |         |+-------+-------------+-------------------+------+-----+---------+-------+---------------------------------+---------+5 rows in set (0.00 sec)






修改编码，此处修改字符集为 utf8，校对规则为 utf8_bin（区分大小写）
1$ ALTER TABLE table_name CONVERT TO CHARACTER SET utf8 COLLATE utf8_bin;
在此查看编码是否更改完成
1234567891011mysql&gt; SHOW FULL COLUMNS FROM Student;+-------+-------------+-----------+------+-----+---------+-------+---------------------------------+---------+| Field | Type        | Collation | Null | Key | Default | Extra | Privileges                      | Comment |+-------+-------------+-----------+------+-----+---------+-------+---------------------------------+---------+| Sno   | char(9)     | utf8_bin  | NO   | PRI | NULL    |       | select,insert,update,references |         || Sname | char(20)    | utf8_bin  | YES  | UNI | NULL    |       | select,insert,update,references |         || Ssex  | char(2)     | utf8_bin  | YES  |     | NULL    |       | select,insert,update,references |         || Sage  | smallint(6) | NULL      | YES  |     | NULL    |       | select,insert,update,references |         || Sdept | char(20)    | utf8_bin  | YES  |     | NULL    |       | select,insert,update,references |         |+-------+-------------+-----------+------+-----+---------+-------+---------------------------------+---------+5 rows in set (0.00 sec)

插入数据的时候，如果是数字则可以不用引号（即使定义为 char）
引号可以为单引号，也可以为双引号



123456789101112131415mysql&gt; INSERT INTO Student VALUES(201215121,李勇,男,20,CS);ERROR 1054 (42S22): Unknown column &#39;李勇&#39; in &#39;field list&#39;mysql&gt; INSERT INTO Student VALUES(201215121,&quot;李勇&quot;,男,20,CS);ERROR 1054 (42S22): Unknown column &#39;男&#39; in &#39;field list&#39;mysql&gt; INSERT INTO Student VALUES(201215121,&quot;李勇&quot;,&quot;男&quot;,20,CS);ERROR 1054 (42S22): Unknown column &#39;CS&#39; in &#39;field list&#39;mysql&gt; INSERT INTO Student VALUES(201215121,&quot;李勇&quot;,&quot;男&quot;,20,&quot;CS&quot;);Query OK, 1 row affected (0.01 sec)-- 单引号mysql&gt; INSERT INTO Student VALUES(201215122,&#39;刘晨&#39;,&#39;女&#39;,19,&#39;CS&#39;);Query OK, 1 row affected (0.01 sec)


Navicat：ERROR 1130:
报错信息：ERROR 1130:Host ‘x.x.x.x’ is not allowed to connect to this MySQL server

可能是账号不允许从远程连接到数据库
解决方法

改表
123456# 使用 mysql 数据库$ use mysql;# % 表示任何 ip 都可连接$ update user set host=&#x27;%&#x27; where user=&#x27;root&#x27; and host=&#x27;localhost&#x27;;# 刷新生效$ flush privileges;
1234# 改回原来$ update user set host=&#x27;localhost&#x27; where user=&#x27;root&#x27; and host=&#x27;%&#x27;;# 刷新生效$ flush privileges;

下面是详细过程




接下来改动



授权
12$ GRANT ALL PRIVILEGES ON *.* TO &#x27;user&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27; WITH GRANT OPTION;$ FLUSH PRIVILEGES;




下面之后就可以连接了


ERROR 1045
登录数据库出现如下错误



法一：

1234567891011# 停止 mysql$ systemctl stop mysqld# 用以下命令启动MySQL，以不检查权限的方式启动$ mysqld --skip-grant-tables &amp;$ mysqld --user=root --skip-grant-tables &amp;# 登录 mysql$ mysql -u root# 更新root密码$ UPDATE mysql.user SET authentication_string=PASSWORD(&#x27;自己的密码&#x27;) where USER=&#x27;root&#x27;;# 刷新权限$ flush privileges;

systemctl stop mysqld

mysqld –skip-grant-tables &amp;
mysqld –user=root –skip-grant-tables &amp;


mysql -u root


UPDATE mysql.user SET authentication_string=PASSWORD(‘xxx’) where USER=’root’;


flush privileges;



法二：

先查看 CentOS7 下的 mysql 配置文件位置
使用命令：ps aux|grep mysql|grep &#39;my.cnf&#39;
如果没有没有输出内容则是使用默认配置位置
默认配置my.cnf位置
使用命令：mysql –help|grep ‘my.cnf’ （查看默认配置位置）
/etc/my.cnf、/etc/mysql/my.cnf、 /usr/local/etc/my.cnf、 ~/.my.cnf

打开 mysql.cnf 文件
skip-grant-tables



ERROR 1820
重新设置一个密码就行了

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/08/23/wt%20ssh%E5%92%8C%E9%80%9A%E8%BF%87ssh%E8%BF%9E%E6%8E%A5windows/" title="wt ssh和通过ssh连接windows">wt ssh和通过ssh连接windows</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-23T01:29:57.000Z" title="发表于 2021-08-23 09:29:57">2021-08-23</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-24T03:12:12.128Z" title="更新于 2021-08-24 11:12:12">2021-08-24</time></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Windows/">-Windows</a></span></div><div class="content">
Windows Terminal 连接服务器
小知识：本地 Windows 上传文件到 服务器上



Windows系统 连接服务器的软件有很多，比如 CMD、Powershell、git-bash、xshell 等等工具都可以通过 ssh 连接到服务器主机
下面我通过 Windows Terminal 连接服务器并添加一个启动项


直接在打开终端 ssh 连接，直接终端输连接命令即可


添加一个启动项（好处就是不用每次都输入 ssh 的连接命令）

打开 Windows Terminal 的 json 文件进行编辑

找到 list这个地方（方括号是一个是数组）


我们添加一个数组元素，即一个终端，内容如下
123456&#123;    &quot;commandline&quot;: &quot;ssh root@121.4.26.166&quot;,    &quot;guid&quot;: &quot;&#123;4f338cc5-b9f0-4707-96de-16c856dbfd87&#125;&quot;,    &quot;hidden&quot;: false,    &quot;name&quot;: &quot;CentOs7&quot;&#125;


guid 获取方式，在终端（在使用 ssh 连接的终端比如 cmd、wt）输入New-Guid






远程连接 Windows
打开设置（应用版块）安装 OpenSSH 服务器


打开 Openssh 服务



查看 22 端口是否开启

未开启



已开启



最后通过局域网的设备 ssh 登录到 Windows
但是我登录了很多次都不知道账户和密码





</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/08/19/Windows%20Terminal%20%E7%BE%8E%E5%8C%96/" title="Windows Terminal + Git-Bash">Windows Terminal + Git-Bash</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-19T01:29:57.000Z" title="发表于 2021-08-19 09:29:57">2021-08-19</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-24T01:34:01.714Z" title="更新于 2021-08-24 09:34:01">2021-08-24</time></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Windows/">-Windows</a></span></div><div class="content">
Windows Terminal先安装PowerShellhttps://github.com/PowerShell/PowerShell/releases

64位 Windows 可下载 msi 文件


安装Windows Terminal
打开微软商店，直接搜索 Windows Terminal 即可下载安装

安装 posh-git、oh-my-posh
https://github.com/JanDeDobbeleer/oh-my-posh2

打开 WindowsTerminal的 Powershell窗口

post-git加入的 -Verbose显示详情
12$ Install-Module posh-git -Scope CurrentUser$ Install-Module posh-git -Verbose -Scope CurrentUser

成功安装在 E:\Multimedia Data\文档\PowerShell\Modules\ 这个目录下



oh-my-posh
12$ Install-Module oh-my-posh -Scope CurrentUser$ Install-Module oh-my-posh -Verbose -Scope CurrentUser



开启插件
打开配置文件
1$ notepad $PROFILE


编辑引入模块
12345678# 引入 posh-gitImport-Module posh-git# 引入 oh-my-poshImport-Module oh-my-posh# 设置 PowerShell 主题Set-PoshPrompt -Theme agnoster


这里我使用的是一个博主提供的内容：https://gist.github.com/LittleNewton/04132945d9b9743ba7cab780fc44a67b

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100&lt;# * FileName: Microsoft.PowerShell_profile.ps1 * Author: 刘 鹏 * Email: littleNewton6@outlook.com * Date: 2020, May. 1 * Update: 2021, Mar. 14 * Copyright: No copyright. You can use this code for anything with no warranty.#&gt;#------------------------------- Import Modules BEGIN -------------------------------# 引入 posh-gitImport-Module posh-git# 引入 oh-my-poshImport-Module oh-my-posh# 设置 PowerShell 主题# Set-PoshPrompt -Theme ysSet-PoshPrompt -Theme nu4a#------------------------------- Import Modules END   -------------------------------#-------------------------------  Set Hot-keys BEGIN  -------------------------------# 设置预测文本来源为历史记录Set-PSReadLineOption -PredictionSource History# 设置 Tab 为菜单补全和 IntellisenseSet-PSReadLineKeyHandler -Key &quot;Tab&quot; -Function MenuComplete# 设置 Ctrl+d 为退出 PowerShellSet-PSReadlineKeyHandler -Key &quot;Ctrl+d&quot; -Function ViExit# 设置 Ctrl+z 为撤销Set-PSReadLineKeyHandler -Key &quot;Ctrl+z&quot; -Function Undo# 设置向上键为后向搜索历史记录Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward# 设置向下键为前向搜索历史纪录Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward#-------------------------------  Set Hot-keys END    -------------------------------#-------------------------------    Functions BEGIN   -------------------------------# Python 直接执行$env:PATHEXT += &quot;;.py&quot;# 更新 pip 的方法function Update-Packages &#123;	# update pip	Write-Host &quot;Step 1: 更新 pip&quot; -ForegroundColor Magenta -BackgroundColor Cyan	$a = pip list --outdated	$num_package = $a.Length - 2	for ($i = 0; $i -lt $num_package; $i++) &#123;		$tmp = ($a[2 + $i].Split(&quot; &quot;))[0]		pip install -U $tmp	&#125;	# update TeX Live	$CurrentYear = Get-Date -Format yyyy	Write-Host &quot;Step 2: 更新 TeX Live&quot; $CurrentYear -ForegroundColor Magenta -BackgroundColor Cyan	tlmgr update --self	tlmgr update --all	# update Chocolotey	choco outdated&#125;#-------------------------------    Functions END     -------------------------------#-------------------------------   Set Alias BEGIN    -------------------------------# 1. 编译函数 makefunction MakeThings &#123;	nmake.exe $args -nologo&#125;Set-Alias -Name make -Value MakeThings# 2. 更新系统 os-updateSet-Alias -Name os-update -Value Update-Packages# 3. 查看目录 ls &amp; llfunction ListDirectory &#123;	(Get-ChildItem).Name	Write-Host(&quot;&quot;)&#125;Set-Alias -Name ls -Value ListDirectorySet-Alias -Name ll -Value Get-ChildItem#-------------------------------    Set Alias END     -------------------------------




重新打开 Windows Terminal ：paradox 主题如下
尝试查看配置颜色，给了一个网址，打开之后告诉我们怎么更新到 V3


更新命令，同样我们加入 Verbose 查看信息

1$ Update-Module -Name oh-my-posh -Verbose -Scope CurrentUser



主题更改
查看主题

查看主题样式、列举所有主题命令

1$ Get-PoshThemes


更改主题
1$ Set-PoshPrompt -Theme theme_name



VsCode终端
经过上面的美化之后，Vscode 的终端也会得以改变，但是由于 Vscode 设置的字体可能会导致乱码


我们按住 Ctrl+Shift+P 输入 settings.json 然后编辑字体样式即可，我这里用到的是一个FiraCode NF 字体（这个好像是系统内部的，下载链接）
提供一个我的字体设置
1&quot;editor.fontFamily&quot;: &quot;Fira Code Medium, FiraCode NF, Consolas, &#x27;Courier New&#x27;, monospace&quot;,
当然还有很多字体都可以，比如 Hack 字体（下载链接），但是我安装之后在 Vscode里面没有用，在 Windows Terminal 的配置文件里面就可以用，具体什么原因不清楚
下面是 Windows Terminal 的配置文件


红色框表示设置终端字体类型，Hack NF、FiraCode NF 都可以达到特殊字符的显示


Git bash 美化前言
经过上面 Vscode 的启发，能否在 IDEA 上面把终端也改成 Windows Terminal 的样式
但是通过查看 Windows Terminal 的安装路径寻找它的可执行文件，然后在 IDEA 里面设置终端的启动文件
我通过 Everything 找到了 Windows Terminal 的文件路径，把 IDEA 的终端启动文件设置为 wt.exe 启动
但是它打开终端是独立打开的，不在 IDEA 窗口里面打开，于是想到能不能设置为 Git Bash启动，然后把 Git Bash 美化一下


下面 IDEA 设置为了 Git Bash 启动了，只需要把 Git Bash 美化即可



安装 zsh
https://packages.msys2.org/package/zsh?repo=msys&amp;variant=x86_64


解压，这个 .zst文件可能解压不了，需要安装一个软件peaziphttps://peazip.github.io/
然后找到第一步下载的，选择解压即可

解压之后会有一个去掉了 .zst后缀的文件，此时我们在次解压即可


我们把上面解压好的文件全部移动到 git的安装目录下，相当于对git bash做一个补充包，比如我这里


打开 Git Bash，输入 zsh然后你会发现进入了 zsh 终端
提示我们没有配置文件，输入 0 创建一个就行了



安装 oh my zsh
上面已经从进入了 zsh 终端了，执行下面命令安装 oh-my-zsh （给出官网）
123# 下面两个任选其一$ sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;$ sh -c &quot;$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;

这里我两个链接都没用


用另外方法安装，其实就是人工手动实现上面两种安装代码方式

首先随便在哪个地方新建文件 install.sh
然后打开网址 https://github.com/ohmyzsh/ohmyzsh/blob/master/tools/install.sh 复制里面的内容 写入install.sh文件中
1$ vim install.sh
赋予执行权限
1$ chmod +x install.sh
执行脚本
1$ ./install.sh

报错了，解决方法先还未知



提示：下面不用看了，因为写到一半发现错了



报错分析
根据上面的报错大概是说克隆仓库到本地出错，那我们查看它仓库里面的 install.sh 文件里面的内容
这是 ohmyzsh仓库 install.sh 的一部分代码，我想大概意思就是拉取仓库到本地，并且保存到 ~/.oh-my-zsh下（~/这个目录在Windows下是用户目录，Linux 是 root）

然后我验证了的确是这样的，我查看云服务器（安装了ohmyzsh）下 /root/目录下是否有个 .oh-my-zsh文件夹以及里面文件是否和仓库一致


lib                 提供了核心功能的脚本库tools             提供安装、升级等功能的快捷工具plugins         自带插件的存放位置templates     自带模板的存放位置themes         自带主题文件的存放位置custom         个性化配置目录，自安装的插件和主题可放这里


知道了 执行install.sh文件的目的是先拉取仓库到本地，我们干脆手动拉取到指定目录下


发现它那里写的是要拉取到.oh-my-zsh目录，我们只需将其改名即可

随后在 install.sh目录下执行该脚本看看
1$ ./install.sh


很明显，即使执行了 install.sh 也没有初始化一些文件，即配置文件 .zshrc
配置文件里面有一些东西，但是我们查看之后并没有
手动添加试试，我添加成功了，也同样开启了 zsh ，但是后面下载插件的时候会有路径上的错误，不知道怎么回事，所以这个方法不可行




插件安装待续
配置待续
Git SDK
Git SDK 全称 Git for Windows SDK，基于 MSYS2（MinGW64 + Cygwin 合体增强）的仿 Linux 环境；
安装后大约会占用 4~5 GB 的磁盘空间，但是包含了完整的仿 Linux 环境：包括常用工具，完整的 GNU Complier 链以及包管理器 pacman


Windows 里面 Powershell 有工具 oh-my-posh
Linux 里面 有 oh-my-zsh
接下来在 Windows 下安装 Git SDK 模拟一个 Linux环境

下载安装
方式一：直接从官网下载一个安装包，就是一个下载器，会自动从仓库克隆这个程序所需要的全部文件，但是由于下载速度很慢，不太可行
https://gitforwindows.org/

方式二：直接拉取仓库上的文件到本地（其实就是方式一中需要下载的文件），但是里面文件很大，大概有 5/6 GB
此时到你想保存的路径克隆下来就行
https://github.com/git-for-windows/git-sdk-64



由于我这里每次都拉取失败，这个就先到这里，具体之后需要安装的 zsh 和 oh-my-zsh 还要参考网上的教程

待续
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/08/18/CentOS+nginx-rtmp-module/" title="CentOs+Nginx-rtmp-module">CentOs+Nginx-rtmp-module</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-18T01:29:57.000Z" title="发表于 2021-08-18 09:29:57">2021-08-18</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-18T14:29:18.275Z" title="更新于 2021-08-18 22:29:18">2021-08-18</time></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">-Linux</a></span></div><div class="content">

尝试用云服务器搭建一个Nginx+rtmp服务器来做推流服务器

下载
我这里下载的文件全部保存在/opt/source下


nginx-rtmp-module
下载源文件
1$ git clone https://github.com/arut/nginx-rtmp-module.git
nginx：由于我原本有 nginx 
原来有，查看nginx版本rpm -qa nginx，然后下载相同版本的源码
比如我这里查看之后是nginx-1.16.1-3.el7.x86_64
那么我下载1.16.1版本的nginx源码，然后解压，如下
12$ wget http://nginx.org/download/nginx-1.16.1.tar.gz$ tar -zxvf nginx-1.16.1.tar.gz




nginx添加模块
我下载了 nginx-rtmp-module 模块，就要把它添加到 nginx 服务器里面


进入到cd nginx-1.16.1/目录（也就是刚刚解压的 Nginx 目录）

查看原来 Nginx 的配置信息
1$ nginx -V
比如我这里的配置参数如下


复制红色框中的内容
红色框的配置是我们原来的，这个时候只需要在后面追加上需要添加的模块

注意更该自己存放模块的路径

12# 需要在后面添加的内容$ --add-module=/opt/source/nginx-rtmp-module
然后配置参数
1$ ./configure --prefix=/usr/share/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --http-client-body-temp-path=/var/lib/nginx/tmp/client_body --http-proxy-temp-path=/var/lib/nginx/tmp/proxy --http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi --http-uwsgi-temp-path=/var/lib/nginx/tmp/uwsgi --http-scgi-temp-path=/var/lib/nginx/tmp/scgi --pid-path=/run/nginx.pid --lock-path=/run/lock/subsys/nginx --user=nginx --group=nginx --with-file-aio --with-ipv6 --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-stream_ssl_preread_module --with-http_addition_module --with-http_xslt_module=dynamic --with-http_image_filter_module=dynamic --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_degradation_module --with-http_slice_module --with-http_stub_status_module --with-http_perl_module=dynamic --with-http_auth_request_module --with-mail=dynamic --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream=dynamic --with-stream_ssl_module --with-google_perftools_module --with-debug --with-cc-opt=&#x27;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic&#x27; --with-ld-opt=&#x27;-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E&#x27; --add-module=/opt/source/nginx-rtmp-module
执行编译命令
1$ make

遇到了问题这一步


查看网上说没有安装其它依赖环境 pcre、zlib、openssl， 这些是解压包、ssl相关的依赖
但是我查看了下面 3 个显示有安装

123$ yum -y install pcre pcre-devel$ yum -y install zlib zlib-devel$ yum -y install openssl openssl-devel  
先不管有没有安装，尝试安装上述 3 个，安装完后在查看，好吧其实上面 3 个和我原来的不同

在尝试make，结果还是一样的报错
然后我尝试把划线部分删除

执行完之后如下报错

上网查找方法安装如下
1$ yum -y install libxslt-devel
然后重新./configure又有新报错，如下

查到解决方案，安装如下
1$ yum -y install perl-ExtUtils-Embed
然后重新./configure又有新报错，如下

查到解决方案，安装如下
1$ yum -y install gperftools
然后重新./configure，终于没有报错了


编译完成后，会生成一个objs的目录

objs目录文件如下

需要把箭头文件替换成原来的，使用which nginx查看原来的路径

把这个东西替换掉/usr/sbin/nginx
如果替换不了就先关闭 Nginx 服务
1$ systemctl stop nginx.service
替换好了之后打开 Nginx 服务
1$ systemctl start nginx.service
发现报错，启动不了服务

用 systemctl status nginx.service查看信息

这里说ngx_mail_module.so这个模块有问题，谷歌一波（手动滑稽）
最后实在找不到解决方案了，干脆重装 Nginx，先备份好配置文件
不对，想到一个方法，我们查找出错的这个模块，可以发现编译了一个新的，尝试替换原来的，看是否能解决


最后打开 Nginx 服务看是否成功
发现没有任何提示，终于解决了


添加配置etc/nginx/nginx.conf下面这个添加在 https{ } 只外
12345678910111213rtmp&#123;    server&#123;            listen 1935;  # 监听的端口          chunk_size 4000;  # 数据传输块的大小        application minghui &#123;  # rtmp 推流请求路径              live on;            hls on;               hls_path /myweb/rtmp/live;            hls_fragment 5s;            &#125;     &#125;    &#125;
添加配置之后来到 OBS 推流，服务器对应配置文件应该如下
123# 服务器rtmp://IP:PORT/推流请求路径# 串流秘钥：自己随便设置

开始推流之后别人想观看就通过下面这个链接，Potplay、VLC都可以观看
1rtmp://IP:PORT/推流请求路径/串流秘钥
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/08/14/CSS/" title="CSS">CSS</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-14T01:29:57.000Z" title="发表于 2021-08-14 09:29:57">2021-08-14</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-10-11T03:11:17.170Z" title="更新于 2021-10-11 11:11:17">2021-10-11</time></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/CSS/">-CSS</a></span></div><div class="content">
CSS简介
层叠样式表（英语：Cascading Style Sheets，缩写：CSS；又称串样式列表、级联样式表、串接样式表、阶层式样式表）是一种用来为结构化文档（如HTML文档或XML应用）添加样式（字体、间距和颜色等）的计算机语言，由W3C定义和维护。CSS 被分为不同等级：CSS1 现已废弃， CSS2.1 是推荐标准， CSS3 分成多个小模块且正在标准化中。[来源请求]CSS3现在已被大部分现代浏览器支持，而下一版的CSS4仍在开发中
CSS不能单独使用，必须与HTML或XML一起协同工作，为HTML或XML起装饰作用。
CSS最重要的目标是将文件的内容与它的显示分隔开来。在CSS出现前，几乎所有的HTML文件内都包含文件显示的信息，比如字体的颜色、背景应该是怎样的、如何排列、边缘、连线等等都必须一一在HTML文件内列出，有时重复列出。CSS使作者可以将这些信息中的大部分隔离出来，简化HTML文件，这些信息被放在一个辅助的，用CSS语言写的文件中。HTML文件中只包含结构和内容的信息，CSS文件中只包含样式的信息
——维基百科

选择器
作用：选择页面上的某一个或某一类元素

基本选择器
标签选择器：选择某一类标签
1tag_name &#123;&#125;


类选择器：选择所有 class 属性一致的标签，可以跨标签
比如 &lt;h1 class=&quot;style&quot;&gt;&lt;/h1&gt;  与 &lt;h2 class=&quot;style&quot;&gt;&lt;/h2&gt; 可以共存，属性不同类可以相同
1.class_name &#123;&#125;


id 选择器：全局唯一
比如 &lt;h1 id=&quot;style&quot;&gt;&lt;/h1&gt;  与 &lt;h2 id=&quot;style&quot;&gt;&lt;/h2&gt; 不可以共存，id 名全局唯一
但是我在 Vscode 里面书写上述两个是没有报错？下面引用 W3school 对 id 选择器的描述

类选择器还是 ID 选择器？
在类选择器这一章中我们曾讲解过，可以为任意多个元素指定类。前一章中类名 important 被应用到 p 和 h1 元素，而且它还可以应用到更多元素。
区别 1：只能在文档中使用一次
与类不同，在一个 HTML 文档中，ID 选择器会使用一次，而且仅一次。
区别 2：不能使用 ID 词列表
不同于类选择器，ID 选择器不能结合使用，因为 ID 属性不允许有以空格分隔的词列表。
区别 3：ID 能包含更多含义

区别2 中写道 在一个 HTML 文档中，ID 选择器会使用一次，而且仅一次 
但是为什么在代码中多个标签的 id 相同时，也可以显示代码效果。如图、

网上看到的回答是：”在JS进行dom操作是就存在问题了”
1#id_name &#123;&#125;





总结：三者优先级：id 选择器 &gt; 类选择器 &gt; 标签选择器

层次选择器
后代选择器（descendant selector）：子代全选
12/* 表示选择 name1 后代名为 name2 的标签，如果 name2 里面还有标签，里面的标签也同样会选中 */name1 name2 &#123;&#125;
只要是某个元素的后代均会改变

举例说明：下面截取的是代码的主体部分

123456789101112131415&lt;body&gt;    &lt;ul&gt;        &lt;li&gt;列表一&lt;/li&gt;        &lt;li&gt;列表二&lt;/li&gt;    &lt;/ul&gt;    &lt;ol&gt;        &lt;li&gt;列表一&lt;/li&gt;        &lt;li&gt;列表二&lt;/li&gt;        &lt;ul&gt;            &lt;li&gt;列表一&lt;/li&gt;            &lt;li&gt;列表二&lt;/li&gt;        &lt;/ul&gt;    &lt;/ol&gt;&lt;/body&gt;

写法一：
123456&lt;style&gt;    ul li &#123;        font-size: 30px;        color: cadetblue;    &#125;&lt;/style&gt;


写法二：
123456&lt;style&gt;    ol li &#123;        font-size: 30px;        color: cadetblue;    &#125;&lt;/style&gt;


写法三
123456&lt;style&gt;    body li &#123;        font-size: 30px;        color: cadetblue;    &#125;&lt;/style&gt;
下面是三种写法的结果




子选择器：只选择一个子代
12/* 表示选择 name1 后代名为 name2 的标签，如果 name2 里面还有标签，里面的标签也会被选中 */name1&gt;name2 &#123;&#125;

我们知道了后代选择器，子选择器就是后代选择器的弱化版本
它只会选择一代，但是也可以渗透到最里面


兄弟（弟弟）选择器：选择下面最近的一个子代
12/* 表示选择 name1 下面一个(如果下面有多个也只会选择下面最近的一个)名为 name2 的标签，其本身 name1 不会被选择 */name1 + name2 &#123;&#125;

注意细节：
下面这个只会选中 我是第一条
因为 我是第二条 上面隔了一个 &lt;br&gt;标签
由此可见，选择下面最近的一个子代不能隔有其他标签，若有则不会选中最近的一个子代

1234567891011121314151617.ul+li &#123;    font-size: 30px;    color: blue;&#125;&lt;ul class=&quot;ul&quot;&gt;    &lt;li&gt;列表一&lt;/li&gt;    &lt;li&gt;列表二&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;我是第一条&lt;/li&gt;&lt;ul class=&quot;ul&quot;&gt;    &lt;li&gt;列表三&lt;/li&gt;    &lt;li&gt;列表四&lt;/li&gt;&lt;/ul&gt;&lt;br&gt;&lt;li&gt;我是第二条&lt;/li&gt;


通用（弟弟们）选择器：选择下面的所有子代
12/* 表示选择 name1 下面所有(如果下面有多个全部选择)名为 name2 的标签，其本身 name1 不会被选择 */name1~name2 &#123;&#125;

举例，和 兄弟选择器 略有不同
此时只会选中 我是第一条和我是第三条

1234567891011121314151617181920.ul~li &#123;    font-size: 30px;    color: blue;&#125;&lt;ul class=&quot;ul&quot;&gt;    &lt;li&gt;列表一&lt;/li&gt;    &lt;li&gt;列表二&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;我是第一条&lt;/li&gt;&lt;ol&gt;    &lt;ul&gt;        &lt;li&gt;列表三&lt;/li&gt;        &lt;li&gt;列表四&lt;/li&gt;    &lt;/ul&gt;    &lt;li&gt;我是第二条&lt;/li&gt;&lt;/ol&gt;&lt;br&gt;&lt;li&gt;我是第三条&lt;/li&gt;

总结：四者能够穿甲（指能够一直延续到最里面的标签）的有：后代选择、子代选择器



结构伪类选择器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;结构伪类选择器&lt;/title&gt;    &lt;style&gt;        /* 选择 ul 的第一个子元素 */        ul li:first-child &#123;            /*顺序数,因为ul下面第一个是&lt;h1&gt;,所以不会选中*/            font-size: 30px;            background-color: yellow;        &#125;        ul li:first-of-type &#123;            /*类型数*/            font-size: 30px;            background-color: red;        &#125;        /* 选择 ul 的第最后一个子元素 */        ul li:last-child &#123;            /*顺序数,因为ul最后一个是&lt;h1&gt;,所以不会选中*/            font-size: 30px;            background-color: orange;        &#125;        ul li:last-of-type &#123;            /*类型数*/            font-size: 30px;            background-color: blue;        &#125;        /* 选中 p1：定位到父元素，选中当前的第一个元素        选择当前 p 元素的父元素，选中父元素的第一个，并且是当前元素才生效 */        p:nth-child(1) &#123;            /*顺序数,因为p父类body下面第一个是&lt;h1&gt;,所以不会选中*/            font-size: 60px;            background-color: deepskyblue;        &#125;        p:nth-of-type(2) &#123;            /*类型数*/            font-size: 60px;            background-color: blueviolet;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;H1&lt;/h1&gt;    &lt;p&gt;p1&lt;/p&gt;    &lt;p&gt;p2&lt;/p&gt;    &lt;p&gt;p3&lt;/p&gt;    &lt;ul&gt;        &lt;h1&gt;H1&lt;/h1&gt;        &lt;li&gt;li1&lt;/li&gt;        &lt;li&gt;li2&lt;/li&gt;        &lt;li&gt;li3&lt;/li&gt;        &lt;h1&gt;H1&lt;/h1&gt;    &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;

结果


属性选择器（常用）
正则表达式：
=绝对等于
*=包含
^=以什么（=号后面的）开头
&amp;=以什么（=号后面的）结尾

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/08/02/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="RegExp">RegExp</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-02T04:32:33.000Z" title="发表于 2021-08-02 12:32:33">2021-08-02</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-14T14:06:06.736Z" title="更新于 2021-12-14 22:06:06">2021-12-14</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/javaSE/">javaSE</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/java/">java</a></span></div><div class="content">
正则表达式语法
限定符
选择匹配符
分组组合和反向引用
特殊字符
字符匹配符
定位符

元字符
转义号 \\

匹配某些特殊字符需要用到
一个 \ 开头的字符会被当作转义字符处理
Java 的正则表达式中，两个 \\ 代表其他语言的一个 \

需要用到转义符号的字符：* + ( ) $ / \ ? [ ] ^ &#123; &#125;
如匹配 “(“ 写成 \\(
匹配 “.” 写成 \\.

字符匹配符





符号
含义
示例
解释



[ ]
可接受的字符列表
[abcd]
abcd中的任意一个字符


[^ ]
不接受的字符列表
[^abcd]
除 abcd 以外的任一字符，包括数字和特殊符号


-
连字符
A-Z or [AB…Z]
任意大写字母


.
匹配除 \n 以外的任何字符。如果匹配自身，则需要使用\\.
a..b
匹配以 a 开头，b 结尾，中间两个字符任意，长度为 4 的字符串


\\d
匹配单个数字字符，等价于 [0-9]
\\d{3}(\\d)?
匹配 3 或 4 个数字的字符串


\\D
匹配单个非数字字符，等价于 [^0-9]
\\D(\\d)*
匹配以单个非数字开头，后任意个数字的字符串


\\w
匹配单个数字、大小写字母字符，等价于 [0-9a-zA-Z_]
\\d{3}\\w{4}
匹配以 3 个数字开头的长度为 7 的数字字母的字符串


\\W
匹配单个非数字、大小写字母字符，等价于[^0-9a-zA-Z_]
\\W+\\d{2}
匹配以至少 1 个非数字、大小写字母字符开头，2 个数字字符结尾的字符串


\\s
匹配任何空白字符（空格、制符表等）




\\S
匹配任何非空白字符





\\w匹配 4 类：数字，小写字母、大写字母、包括下划线
abc：匹配 abc 字符
(?!)abc：匹配 abc 和 ABC 字符


选择匹配符
一个|

限定符
用于限定前面的字符和组合项连续出现多少次



符号
含义
示例
解释



*
零次或多次匹配前面的字符或子表达式
zo*
zo* 匹配”z”和”zoo”。* 等效于 {0,}


+
一次或多次匹配前面的字符或子表达式
zo+
“zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}


?
零次或一次匹配前面的字符或子表达式
do(es)?
“do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}


&#123;n&#125;
只能输入 n 个字符
[abcd]{3}
由abcd中字母组成的任意长度为 3 的字符串，eg：abc、abd、dda


&#123;n,&#125;
指定至少 n  个匹配
[abcd]{3,}
由abcd中字母组成的任意长度至少为 3 的字符串，eg：abc、adbd、addaa


&#123;n,m&#125;
指定至少 n 个但不多于 m 个匹配
[abcd]{3,5}
由abcd中字母组成的任意长度至少为 3 但不多于 5 的字符串（即 3|4|5个）



定位符



符号
含义
示例
解释



^
指定起始字符
^[0-9]+[a-z]*
以至少一个数字开头，后面任意接小写字母的字符串（也可以没有小写字母字符串）


$
指定结束字符
^[0-9]-[a-z]+$
以一个数字开头后连接 “-”，并以至少一个小写字母结尾的字符串


\\b
匹配目标字符串的边界
abc\b
“abc123abc 4abc“ 会匹配尾部两个 abc，空格分隔会识别为 2 个目标字符串


\\B
匹配目标字符串的非边界
[abcd]{3}
与 \\b正好相反 “abc123abc 4abc” 会匹配头部一个 abc



捕获分组

非命名分组：根据括号个数依次编号为 1、2、3、4… 组，取组的时候用 group(name)

命名分组


group(int group)、group(String name)  重载了，前者通过编号取，后者通过命名取




非捕获分组









(?:pattern)



(?=pattern)



(?!pattern)





</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/07/26/Tree/" title="Tree[realize]">Tree[realize]</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-26T13:51:41.000Z" title="发表于 2021-07-26 21:51:41">2021-07-26</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-18T02:58:20.771Z" title="更新于 2021-08-18 10:58:20">2021-08-18</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/tree-java/">tree - java</a></span></div><div class="content">
二叉树BinaryTree-抽象类
因为树有很多种，有些功能的实现都是一样的，所以把这些实现一样的单独抽取出来放在父类 Tree 

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198public abstract class Tree&lt;E&gt; &#123;    protected int size;   // 节点个数    protected Node&lt;E&gt; root;   // 根节点    protected Comparator&lt;E&gt; comparator;   // 比较器        /*========================父类 Tree 的通抽象函数实现========================*/        // 增加元素    protected abstract void add(E element);    // 删除元素    protected abstract void remove(E element);    // 是否包含元素    protected abstract boolean contains(E element);    /*=====================================================================*/       /*========================父类 Tree 的通用函数实现========================*/        // 元素数量    protected int size() &#123;        return size;    &#125;    // 是否为空    protected boolean isEmpty() &#123;        return size == 0;    &#125;        // 清空所有元素    protected void clear() &#123;        root = null;        size = 0;    &#125;    // 前序遍历    protected void preorderTraversal(Node&lt;E&gt; node, Visitor&lt;E&gt; visitor) &#123;        if (node == null) &#123;            return;        &#125;        visitor.visit(node.element);        preorderTraversal(node.left, visitor);        preorderTraversal(node.right, visitor);    &#125;    // 中序遍历    protected void inorderTraversal(Node&lt;E&gt; node, Visitor&lt;E&gt; visitor) &#123;        if (node == null) &#123;            return;        &#125;        inorderTraversal(node.left, visitor);        visitor.visit(node.element);        inorderTraversal(node.right, visitor);    &#125;    // 后序遍历    protected void postorderTraversal(Node&lt;E&gt; node, Visitor&lt;E&gt; visitor) &#123;        if (node == null) &#123;            return;        &#125;        postorderTraversal(node.left, visitor);        postorderTraversal(node.right, visitor);        visitor.visit(node.element);    &#125;    // 层序遍历    protected void levelOrderTraversal(Node&lt;E&gt; node, Visitor&lt;E&gt; visitor) &#123;        if (node == null) &#123;            return;        &#125;        Queue&lt;Node&lt;E&gt;&gt; queue = new ArrayDeque&lt;&gt;();        queue.add(root);        Node&lt;E&gt; tmp = null;        while (!queue.isEmpty()) &#123;            tmp = queue.poll();            visitor.visit(tmp.element);            if (tmp.left != null) &#123;                queue.add(tmp.left);            &#125;            if (tmp.right != null) &#123;                queue.add(tmp.right);            &#125;        &#125;    &#125;    /**     * 树的高度     */    public int height() &#123;        return height(root);    &#125;    private int height(Node&lt;E&gt; node) &#123;        if (node == null) return 0;        return 1 + Math.max(height(node.left), height(node.right));    &#125;    public int heightIteration() &#123;        return heightIteration(root);    &#125;    private int heightIteration(Node&lt;E&gt; node) &#123;        int height = 0;        Queue&lt;Node&lt;E&gt;&gt; queue = new ArrayDeque&lt;&gt;();        queue.add(node);        int level = queue.size();   // 记录每层节点数量        while (!queue.isEmpty()) &#123;            Node&lt;E&gt; tmp = queue.poll();            if (tmp.left != null) &#123;                queue.add(tmp.left);            &#125;            if (tmp.right != null) &#123;                queue.add((tmp.right));            &#125;            if (0 == --level) &#123;                height++;                level = queue.size();            &#125;        &#125;        return height;    &#125;    /**     * 判断是否为完全二叉树     *///    public boolean isComplete() &#123;//        Queue&lt;Node&lt;E&gt;&gt; queue = new ArrayDeque&lt;&gt;();//        queue.add(root);//        boolean leaf = false;//        while (!queue.isEmpty()) &#123;//            Node&lt;E&gt; tmp = queue.poll();//            if (!tmp.isLeaf() &amp;&amp; leaf) &#123;//                return false;//            &#125;//            if (tmp.hasTowChildren()) &#123;//                queue.add(tmp.left);//                queue.add(tmp.right);//            &#125; else if (tmp.left == null &amp;&amp; tmp.right != null) &#123;//                return false;//            &#125; else &#123;//                leaf = true;//                if (tmp.left != null) &#123;//                    queue.add(tmp.left);//                &#125;//            &#125;//        &#125;//        return true;//    &#125;    public boolean isComplete() &#123;        Queue&lt;Node&lt;E&gt;&gt; queue = new ArrayDeque&lt;&gt;();        queue.add(root);        boolean leaf = false;        while (!queue.isEmpty()) &#123;            Node&lt;E&gt; tmp = queue.poll();            if (leaf &amp;&amp; !tmp.isLeaf()) &#123;                return false;            &#125;            if (tmp.left != null) &#123;         // left != null                queue.add(tmp.left);            &#125; else if (tmp.right != null) &#123; // left == null &amp;&amp; right != null                return false;            &#125;            if (tmp.right != null) &#123;                queue.add(tmp.right);            &#125; else &#123;    // left != null &amp;&amp; left == null                leaf = true;            &#125;        &#125;        return true;    &#125;            /*=====================================================================*/            protected static class Node&lt;E&gt; &#123;        public E element;        public Node&lt;E&gt; left;        public Node&lt;E&gt; right;        public Node&lt;E&gt; parent;        public Node(E element, Node&lt;E&gt; parent) &#123;            this.element = element;            this.parent = parent;        &#125;        // 判断是否为叶子节点        public boolean isLeaf() &#123;            return left == null &amp;&amp; right == null;        &#125;        // 判断是否度为 2        public boolean hasTowChildren() &#123;            return left != null &amp;&amp; right != null;        &#125;    &#125;&#125;
前驱节点
前驱节点（predecessor）：中序遍历时的前一个节点

下面这个树用这个网址生成：http://btv.melezinek.cz/binary-search-tree.html


中序遍历：33 35 38 39 40 44 57 59 60 61 62 67 68 76

比如 44 的前驱节点是 中序遍历的前一个节点 即 40
40 的前驱节点是 39
38 的前驱节点是 35
57 的前驱节点是 44
33 没有前驱节点
62 的前驱节点是 61
实现流程
根据中序遍历的流程，先遍历目标节点的左子树，那么左子树有无会成为首个判定条件


node.left != null

一直找到目标节点左子树的最右节点：node.left.right.right.right......


node.left == null
一直往上找：node.parent.parent......，直到当前节点是它父节点的右节点：（1）找到了这么一个节点，（2）找不到这么一个节点

比如 57 的父节点是 59(59不是它父节点的右边)，继续往上找，然后找到 59 的父节点 62(62是它父节点的右边)，所以 57 的前驱节点就是 62 的父节点 44
比如 33 的父节点是 35(35不是它父节点的右边)，继续往上找，然后找到 44(44没有父节点了)，因此 33 没有前驱结点


总之就是一直往上找父节点，直到当前节点成为了它父节点的右子树，那么它父节点就是目标节点的前驱结点
如果一直往上找，当前节点都是它父节点的左子树(即找到了顶部)，那么目标节点就没有前驱节点



123456789101112131415161718192021/** * 前驱节点 */public Node&lt;E&gt; predecessor(Node&lt;E&gt; node) &#123;    if (node == null) &#123;        return null;    &#125;    Node&lt;E&gt; cur = node.left;    // 如果左子树不空    if (node.left != null) &#123;        while (cur.right != null) &#123;            cur = cur.right;        &#125;        return cur;    &#125;    // 如果左子树为空，一直找父节点，直到在父节点的右子树上    while (node.parent != null &amp;&amp; node != node.parent.right) &#123;        node = node.parent;    &#125;    return node.parent;&#125;






后继节点实现流程
后继节点（successor）和找前驱异曲同工，同样根据中序遍历的流程，后继节点无非就是找目标节点的后一个，那么有无右子树成为首个判定条件


node.right != null

一直找到目标节点左子树的最右节点：node.right.left.left.left......


node.right == null

总之就是一直往上找父节点，直到当前节点成为了它父节点的左子树，那么它父节点就是目标节点的后继结点
如果一直往上找，当前节点都是它父节点的右子树(即找到了顶部)，那么目标节点就没有后继节点



123456789101112131415161718192021/** * 后继节点 */public Node&lt;E&gt; successor(Node&lt;E&gt; node) &#123;    if (node == null) &#123;        return null;    &#125;    Node&lt;E&gt; cur = node.right;    // 如果右子树不为空    if (node.right != null) &#123;        while (cur.left != null) &#123;            cur = cur.left;        &#125;        return cur;    &#125;    // 如果右子树为空，一直找父节点，直到在父节点的左子树上    while (node.parent != null &amp;&amp; node != node.parent.left) &#123;        node = node.parent;    &#125;    return node.parent;&#125;






二叉搜索树节点
BinaryTreeInfo：是别人写的一个工具，这里是引用

AVL 树概念
平衡因子（Balance Factor）：某节点的左右子树的高度差 
AVL 树特点：
每个节点的平衡因子都是：-1 0 1（绝对值 小于等于 1，如果大于1，称为 ”失衡“
每个节点的左右子树高度差不超过 1
搜索、添加、删除的时间复杂度是 O(logn)




平衡对比
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/07/22/data_struct_01/" title="复杂度">复杂度</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-22T04:32:33.000Z" title="发表于 2021-07-22 12:32:33">2021-07-22</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-18T03:05:07.070Z" title="更新于 2021-08-18 11:05:07">2021-08-18</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">C++ - 数据结构</a></span></div><div class="content">
复杂度
时间复杂度
空间复杂度
忽略低阶项和所有常数项系数
O(1)、O(logN)、O(N)、O(N*logN)、O(N^2)、O(N^3)、O(N^k)、O(2^N)、O(3^N)、O(k^N)、O(N!)


额外空间复杂度

实现一个算法流程，在实现过程中，需要开辟一些空间来完成这个算法过程
作为输入参数的空间，不算额外空间
作为输出结果的空间，也不算额外空间
好比题目要求你把这个数组拷贝一份，那么我肯定要申请数组空间，那么这个数组空间也不算额外空间，因为这是题目的需求，我不得不申请数组空间

如何比较两个算法的好坏


首先比较时间复杂度

如果时间复杂度一样，按理说是比较他们的常数项，但是这个不太现实
比如冒泡排序和插入排序，时间复杂度均为 O(N^2^)，但实际上肯定插入排序好，但是插入排序时间复杂度的常数项是随着测试数据改变而变化
所以我们不能靠理论比较，直接用随机数据测试比较
为什么不理论分析？
因为不同常数时间的操作，虽然时间都是固定的，但是还是有快慢，比如，位运算的常数时间小于算术运算的常数时间，这两个运算的常数时间又小于数组寻址的时间
在者理论分析很困难，很难定量分析



最优解


时间复杂度越低越好

空间复杂度越低越好

时间复杂度相同情况，比较空间复杂度

时间空间复杂度相同情况，两者认为相同
不能因为一些局部细节比较两者好坏，即使常数时间可能有快慢，因为这个因素只决定了实现层次的优化和考虑，而和怎么解决这个问题的思想无关


</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/07/22/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/" title="滑动窗口">滑动窗口</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-22T04:32:33.000Z" title="发表于 2021-07-22 12:32:33">2021-07-22</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-18T02:57:35.123Z" title="更新于 2021-08-18 10:57:35">2021-08-18</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">C++ - 数据结构</a></span></div><div class="content">
滑动窗口
T1

假设一个固定大小为 W 的窗口，依次划过 arr
返回每一次滑出状况的最大值
例如：arr = [4,3,5,4,3,3,6,7], W = 3
返回：[5,5,5,4,6,7]

T2

给定一个数组 arr，和一个整数 num
某个 arr 中的子数组 sub，如果想达标，必须满足：
sub 中最大值 - sub 中最小值 &lt;= num
返回 arr 中达标子数组的数量
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/07/20/%E9%9A%8F%E6%9C%BA%E6%95%B0%EF%BC%88C++)/" title="随机数(C++)">随机数(C++)</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-20T04:32:33.000Z" title="发表于 2021-07-20 12:32:33">2021-07-20</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-22T02:20:04.236Z" title="更新于 2021-07-22 10:20:04">2021-07-22</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a></span></div><div class="content">
rand()、srand()、time()、clock()rand()
rand()：随机函数，头文件 #include &lt;cstdlib&gt;有些时候不加也可以编译

看 rand() 函数原型
用户未设定随机数种子时，系统默认的随机数种子为1
123456static unsigned long int next = 1;unsigned int rand() &#123;    next = next * 1103515245 + 12345;    return (unsigned int)(next / 65535) % 32768;&#125;
产生的数范围 [0, RAND_MAX) ，RAND_MAX 是一个符号常量

在 Windows 上是 2^15^-1 = 32,768 - 1【0x7FFF】
在 Linux 上是 2^31^-1 = 2,147,483,648 - 1 【0x7FFFFFFF】


rand() 产生的是伪随机数字，每次执行时是相同的
想要每次结果都不同就要将种子时刻发生变化，我们通过 srand()函数传参来改变它的 next 大小


srand()
它会改变 rand() 函数中的参数 next
1234void srand(unsigned int seed) &#123;    next = seed;&#125;
因此可以通过传入一个 无符号整数 改变 next 值，但是这样比较麻烦，每次都要用户输入
可以选择时间作为参数传入


time()详细查看：C++ 日期 &amp; 时间

time(nullptr) 返回的是一个 无符号整数，值为 从1970年到当前时间的秒数

运行下面代码将会得到当前的 年 时 秒
12345unsigned int times = time(nullptr);cout &lt;&lt; times &lt;&lt; endl;cout &lt;&lt; times / 60 / 60 / 24 / 365 + 1970 &lt;&lt; endl;  // 年cout &lt;&lt; times / 60 % 60 &lt;&lt; endl;   // 时cout &lt;&lt; times % 60 &lt;&lt; endl;   // 秒




clock()
直接返回毫秒

随机数生成
rand()生成 [0, RAND_MAX) 的数

rand() % mod：[0, mod)
rand() % mod + k：[k, mod+k)


有了上面两条就可以推出很多公式了

[0, a)随机数：rand() % a

[a, b)随机数：(rand() % (b - a)) + a
1[a, b) --&gt; [0, b-a)+a --&gt; rand() % (b-a) + a 
(a, b]随机数：(rand() % (b - a)) + a + 1
123(a, b] --&gt; (0, b-a]+a --&gt; [1, b-a+1)+a --&gt; [0, b-a)+(a+1) --&gt; (rand()%(b-a))+a+1# 或者(a, b] --&gt; [a+1, b+1) --&gt; [0, b-a)+(a+1) --&gt; (rand()%(b-a))+a+1
[a, b]随机数：(rand() % (b + 1 - a)) + a
1[a, b] --&gt; [a, b+1) --&gt; [0, b+1-a)+a --&gt; (rand()%(b+1-a))+a
(a, b)随机数：(rand() % (b - a - 1)) + a + 1 
1(a, b) --&gt; [a+1, b) --&gt; [0, b-a-1)+(a+1) --&gt; rand()%(b-a-1)+a+1


浮点随机数（左右边界值是否可取没那么重要了）

[0, 1)浮点随机：rand() / double(RAND_MAX)

[0, a)浮点随机：rand() / double(RAND_MAX) * a

(a, b)浮点随机：(rand() / double(RAND_MAX)) * (b - a) + a
1(a, b) --&gt; 0~1之间浮点数 * (a, b) --&gt; rand()/double(RAND_MAX)*(b-a)+a






</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/07/19/Maven/" title="Maven">Maven</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-18T23:32:33.000Z" title="发表于 2021-07-19 07:32:33">2021-07-19</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-18T02:57:31.634Z" title="更新于 2021-08-18 10:57:31">2021-08-18</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/tools/">tools</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Maven/">Maven</a></span></div><div class="content">
Maven 理解当你正在开发两个项目（A和B），如果 A 项目要使用 B 项目的某一个功能（某个一类）。那么最直接的方法就是将 B项目打包成 jar包，然后在导入 A项目中，这样 A项目就可以使用 B项目里面的功能了。
但是上面这样做非常的麻烦，如果 B项目修复了Bug，A又要重新导入 B项目的 jar包。
回到大局，如果我们需要很多外部 jar包（依赖），一个个手动导入也不是办法

而 Maven就是为了解决项目依赖的问题

Maven 有一个 pom.xml 文件，这个文件就是解决依赖的关键。通过编写该文件，Maven 会根据 pom.xml文件内容下载你需要的 jar包并放在本地的一个仓库。
那么 Maven项目和我们用 IDEA创建的普通 java项目有什么区别，本质没什么区别，个人理解为在普通 java项目上面添加了一个自动解决依赖关系的工具（Maven）
Maven 安装配置
检查 JDK版本 1.7及以上

Maven下载 

这里有 4 种类型的文件

首先明白 bin 和 src 的区别
bin：代表二进制class文件（由java文件编译而成）
src：代表源码（java源码）


zip 和 tar.gz
zip：适用于 Windows
tar.gz：适用于 Linux、MacOs



因此 Windows 平台下下载 bin.zip

配置 Maven 的环境变量

添加一个变量名 MAVEN_HOME （看个人喜好，也可直接添加到 path 中）


添加到 path




检查是否配置成功



切换源和仓库位置
配置好了 Maven环境之后，也简单介绍了 pom.xml文件的作用，项目会根据这个文件下载一些 jar包并且保存到本地一个目录下
但是默认源是国外，网速可能不好，所以可以切换为国内的 阿里源
同时也可以把 jar包的存储路径放到合适的位置

找到 Maven项目路径 –&gt; conf –&gt;  settings.xml

切换为阿里源
这里看到知乎上一篇文章，按照他这个改 将maven源改为国内阿里云镜像
123456789101112131415161718&lt;mirror&gt;    &lt;id&gt;aliyunmaven&lt;/id&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;name&gt;阿里云公共仓库&lt;/name&gt;    &lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;    &lt;id&gt;repo1&lt;/id&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;name&gt;central repo&lt;/name&gt;    &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;    &lt;id&gt;aliyunmaven&lt;/id&gt;    &lt;mirrorOf&gt;apache snapshots&lt;/mirrorOf&gt;    &lt;name&gt;阿里云阿帕奇仓库&lt;/name&gt;    &lt;url&gt;https://maven.aliyun.com/repository/apache-snapshots&lt;/url&gt;&lt;/mirror&gt;


改变 jar包仓库位置



创建 Maven项目
修改好 源 和 仓库位置，下面就创建项目


首先配置 IDEA 环境
全局配置

找到你自己的 Maven目录和仓库位置


创建 Maven项目（java项目）

选择 quickstart


设置 GroupId Artifactld


这一步就是配置了的 Maven环境和项目的参数，在确定一遍是否有错误


最后你可以设置项目保存的位置


进来之后选择箭头指向

过了一段时间下载好之后你就会发现仓库里面的一些 jar 文件





编译项目（使用IDEA的界面操作等同于在终端输入命令）举例添加编译命令

编辑命令


添加一条命令


还可以添加打包命令等等




Maven项目结构
Maven默认约定了一套目录结构，在通过Maven创建了项目以后，项目的目录结构就是以这套目录结构作为模板创建的

1234567891011121314151617$&#123;basedir&#125;|-- pom.xml|-- src|	|-- main|	|	`-- java|	|	`-- resources|	|	`-- filters|	`-- test|	|	`-- java|	|	`-- resources|	|	`-- filters|	`-- it|	`-- assembly|	`-- site`-- LICENSE.txt`-- NOTICE.txt`-- README.txt

src/main/java 项目的源代码
src/main/resources 项目的资源文件
src/main/filters 项目的资源过滤文件
src/main/webapp 如果是web项目，则该目录是web应用源代码所在的目录，比如html文件和web.xml等都在该目录下。
src/test/java 测试代码
src/test/resources 测试相关的资源文件
src/test/filters 测试相关的资源过滤文件
src/it 集成测试代码所在的目录，主要是供别的插件使用的。
src/assembly 组件（Assembly）描述符所在的目录
src/site 站点文件
LICENSE.txt 项目的许可文件
NOTICE.txt 该项目依赖的库的注意事项
README.txt 项目的readme文件


参考：https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/07/14/HTML/" title="HTML">HTML</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-14T01:29:57.000Z" title="发表于 2021-07-14 09:29:57">2021-07-14</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-18T03:04:57.899Z" title="更新于 2021-08-18 11:04:57">2021-08-18</time></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/HTML/">-HTML</a></span></div><div class="content">
元素head 元素
网站信息设置，比如设置内容的字符编码、网站标题

1234567meta		# 字符编码title		# 网站标题stylelinkbasescriptnoscritpt

h、p、strong 元素
h：标题等级
p：段落标签
strong：强调标签


pre
pre：会完整显示包住内容的格式


将保留元素内容里面的排版，注意缩进



p 标签里面可以嵌套 strong 标签，反之不行
pre 标签可以嵌套 code 标签，反之不行

字符实体
在 HTML 中，某些字符是预留的。
在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。
如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。
字符实体类似这样：

12345&amp;entity_name;或者&amp;#entity_number;


不间断空格
上面我们知道了字符实体
HTML 中的常用字符实体是不间断空格(&nbsp;)。
浏览器总是会截短 HTML 页面中的空格。如果您在文本中写 10 个空格，在显示该页面之前，浏览器会删除它们中的 9 个。如需在页面中增加空格的数量，您需要使用 &nbsp; 字符实体

img 元素
img：图片标签



alt 是 img 的必要属性
有些时候图片要进行缩放

可以直接设置 宽 和 高 。但是这样要安装图片原比例等比缩放，比较麻烦
设置 宽 或者 高，另外一个数据浏览器会自动根据图片的宽高比计算出另外一个数据



Web 图片常用格式

jpg：静态图片，不支持透明
png：静态图片，支持透明
gif：静态图片，动态图片、支持透明

HTML中图片属性的高度和宽度单位默认是 px (1个像素）

a 元素
a：定义超链接，打开新的 URL

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/07/13/oh-my-zsh/" title="oh my zsh">oh my zsh</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-13T02:05:07.000Z" title="发表于 2021-07-13 10:05:07">2021-07-13</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-08-20T07:34:55.933Z" title="更新于 2021-08-20 15:34:55">2021-08-20</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%BE%8E%E5%8C%96/">美化</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E8%AE%B0%E5%BD%95/">记录</a></span></div><div class="content">


安装 zsh1$ yum install -y zsh




zsh 的基础上安装 oh my zsh12$ sh -c &quot;$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;$ sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;

上面那个安装不了打开下面网址复制里面内容
1$ https://github.com/ohmyzsh/ohmyzsh/blob/master/tools/install.sh
随便在哪个文件夹新建 install.sh，然后把脚本内容粘贴上去
1$ vim install.sh
赋予执行权限
1$ chmod -x install.sh
执行脚本
1$ ./install.sh

如图安装成功




常用插件
git 插件
当有修改并未提交文件会出现一个小 × 符号


sudo 插件


wd 插件（相当于快捷方式，起名之后直接用 【wd + 名字】 跳转）

能够在常用文件夹之中快速切换访问

12345$ wd add name	# 给当前文件夹起名$ wd name		# 切换到name映射的路径下$ wd rm name	# 删除name的映射快捷方式$ wd list		# 查看现有映射$ wd show 		# 查看当前文件夹映射名称


zsh-syntax-highlighting 插件（命令高亮）
先在配置文件（.zshrc）添加插件名称，然后安装依赖

先克隆会失败，要先把插件名称加到配置文件去，具体原因未知

1$ git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting


zsh-autosuggestions 插件（命令提示补全，按右键补全）
先添加到配置，在安装依赖
1$ git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions



主题
agnoster


amuse


bira


ys


jonathan


xiong-chiamiov-plus


re5et



1234567891011121314151617# ZSH_THEME=&quot;robbyrussell&quot;# ZSH_THEME=&quot;agnoster&quot;# ZSH_THEME=&quot;amuse&quot;# ZSH_THEME=&quot;random&quot;# ZSH_THEME=&quot;bira&quot;# ZSH_THEME=&quot;jonathan&quot;# ZSH_THEME=&quot;ys&quot;# ZSH_THEME=&quot;xiong-chiamiov-plus&quot;ZSH_THEME=&quot;re5et&quot;plugins=(gitsudowdzsh-syntax-highlightingzsh-autosuggestions)
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/06/04/vim/" title="vim">vim</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-06-04T04:32:33.000Z" title="发表于 2021-06-04 12:32:33">2021-06-04</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-19T01:45:37.662Z" title="更新于 2021-07-19 09:45:37">2021-07-19</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/tools/">tools</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/vim/">vim</a></span></div><div class="content">
vim常用命令
[ : ] + [ e ] == 保存文档

[ : ] + [ q ] == 退回

[ : ] + [ w ] + [ q ]== 退回

[ i ] == 光标前面写入

[ a ] == 光标后面写入，可在最后一个字符按a，这样就可以在行尾添加了

[ shift ] + [ a ] == 直接跳到行尾

[ shift ] + [ i ] == 直接跳到行前

[ o ] == 新建下一行并将光标跳到下一行

[ shift ] + [ o ] == 新建上一行并光标跳转

[ h ] [ j ] [ k ] [ l ] == 左，下，上，右

[ x ] == 删除当前字符

[ u ] == 撤销

[ d ] + [ num ] + [ 左 ] == 删除左边 num 个字符

[ d ] + [ num ] + [ 右 ] == 删除右边 num 个字符

[ d ] + [ d ] == 剪切这一行

[ y ] + [ num ] + [ 左 ] == 复制左边 num 个字符

[ y ] + [ num ] + [ 右 ] == 复制右边 num 个字符

[ p ] == 粘贴

[ c ] + [ w ] == 更改这个单词（即删除这个单词并进入写入模式）

[ b ] == 移到光标所在单词的第一个

[ c ] + [ i ] + [ 符号 ] == 将符号内的删除并进入写入模式
EX：”Hello World” 按下 ci” 就会删除 “” 里面的东西并开始写入

[ d ] + [ i ] + [ 符号 ] == 将符号内的删除不进入写入模式

[ 0 ] == 回到这行最开头

[ d ] + [ f ] + [ 符号 ] == 从光标处删除到包括符号的字符

[ y ] + [ f ] + [ 符号 ] == 从光标处复制到包括符号的字符

[ c ] + [ f ] + [ 符号 ] == 从光标处删除到包括符号的字符，并进入写入模式

[ / ] + [ 单词 ] == 即搜索单词并跳转到该单词


插件安装
安装 vim 插件管理器
12curl -fLo ~/.vim/autoload/plug.vim --create-dirs \    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim


安装插件

airline
在 GitHub 上搜索 airline 把地址中 github.com 后面的复制到如图位置





配置文件
放到 /root/.vim/vimrc

123456789101112131415161718192021222324252627# 例如syntax on &quot;代码高亮let mapleader=&quot; &quot;noremap J 5jnoremap K 5knoremap &lt;LEADER&gt;&lt;CR&gt; :nohlsearch&lt;CR&gt; &quot;按下空格然后回车取消搜索高亮map S :w&lt;CR&gt;map R :source $MYVIMRC&lt;CR&gt;set hlsearch &quot;搜索高亮exec &quot;nohlsearch&quot;set incsearch &quot;边搜索边高亮set nonumber &quot;行号set relativenumber &quot;行号(以当前行为基)set nocursorline &quot;所在行下划线set wrap &quot;自动折行取消set showcmd &quot;查看指令set wildmenu &quot;指令选择菜单set ignorecase &quot;忽略大小写搜索call plug#begin(&#x27;~/.vim/plugged&#x27;)Plug &#x27;vim-airline/vim-airline&#x27;call plug#end()


粘贴板
将 vim 粘贴板与系统粘贴板互通


查看是否支持 clipboard 
1vim --version | grep clipboard

-clipboard 表示不支持、+clipboard 表示支持


</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/05/09/HEXO%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="HEXO部署到云服务器">HEXO部署到云服务器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-09T08:05:22.000Z" title="发表于 2021-05-09 16:05:22">2021-05-09</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-07-13T09:44:54.826Z" title="更新于 2021-07-13 17:44:54">2021-07-13</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E8%AE%B0%E5%BD%95/">记录</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器</a></span></div><div class="content">
服务器购买
购买，这里以腾讯云服务器为例子

登录


不记得密码重置密码


重置密码之后用终端登录，用 xshell 为例



git及创建仓库git及用户
安装
1yum install git

查看 git 版本
1&gt;git version

创建一个 git 账户用来管理以后的博客
12345# 创建 git 账户adduser git# 为 git 账户设置密码passwd git
为 git 用户 添加权限
12vim /etc/sudoersgit     ALL=(ALL)       ALL


最后你为 git用户 添加秘钥（我理解为和本地进行身份校准，秘钥不一致就表示不匹配，就无法上传）
12mkdir -p /home/git/.sshvim /home/git/.ssh/authorized_keys
然后把本地的公钥粘贴进去：在本地的 C:\Users\用户名\ .ssh\ 下，如图

如果没有的话就创建秘钥，方法如下
1ssh-keygen -t rsa

上面对 git 用户操作就结束了，下面是创建一个 git仓库（存放博客）



仓库创建
切换到 git用户（重要）
1su git

这里忘记切换的话，后面从本地部署到服务器的时候会报 “权限不够” 错误
而且后面更改很麻烦，要更好很多，一定要先切换到 git用户 再创建仓库


创建仓库
选择一个路径存放：我这里选的是 /home/git/repo
12345mkdir /home/git/repogit init --bare name.git# 这里我的是仓库名是 huiHuiLovesToEatLittleClouds.git# git init --bare huiHuiLovesToEatLittleClouds.git


创建博客存放目录
上面创建了一个仓库用来存放博客，其实并不是真正存放了博客的渲染文件，故我们还需在创建一个文件夹保存真正的博客渲染文件
选择一个路径存放真正能渲染的博客文件：我这里是 /www/wwwroot/Blog_hexo
1mkdir -p /www/wwwroot/Blog_hexo


权限修改（可能不用修改）
现在看下我刚刚创建的 Blog_hexo 这个目录的 所有者和用户组 是 root ，这样的情况就要修改，如果是 git 则不修改，直接跳到 5
然后看下我另外一个博客目录 （hexo）的 所有者和用户组 是 git
这里我们要将 Blog_hexo 的 所有者和用户组 修改为 git

原因：因为我们到时候在本地部署然后上传到服务器的时候是使用 git用户 上传的，不修改的话权限不够，如果想够权限的话直接用 root用户 上传也可以


然后我们修改权限
1chown git:git -R /www/wwwroot/Blog_hexo
仓库和博客目录联系

这里我不太理解其中的逻辑

先梳理一下

仓库是：**/home/git/repo/huiHuiLovesToEatLittleClouds.git**
博客目录是：**/www/wwwroot/Blog_hexo**

然后我们使两者关联起来：先来到仓库，里面有一个 hooks 文件夹，进去创建一个名为 post-receive 文件
12345cd /home/git/repo/huiHuiLovesToEatLittleClouds.git/hooks/vim post-receive# 把下面这个话填进去保存退出# git --work-tree=你的博客目录 --git-dir=你的仓库目录 checkout -fgit --work-tree=/www/wwwroot/Blog_hexo --git-dir=/home/git/repo/huiHuiLovesToEatLittleClouds.git checkout -f

来到这里的话 git 已经配置好了，接下来是 Nginx 的配置



Nginx
安装
1yum install nginx

查看版本
1&gt;nginx -v

找到 nginx 的安装路径
这样是在：**/etc/nginx/** 目录下，找到 nginx.conf 配置文件并修改

server_name：你的域名或服务器IP
root：博客的目录

1vim /etc/nginx/nginx.conf





这里 Nginx 的配置也完成了，下面修改本地的配置文件即可

端口设置
当我们访问一个域名的时候默认是访问它指向的服务器的 80 端口，可以用一个域名对应多个端口



如果需要访问 81 端口：huige.link:81
当然也可以对应2个以上端口

本地
修改配置文件
本地的配置文件（博客的站点配置文件）修改上传仓库为刚刚配置的仓库，具体如图举例




git 表示使用 git 用户上传


本地部署上传到服务器 —— 成功状态



遇到的问题
当我要上传到服务器的时候报错如下


原因及解决如下


原因：由于我当时创建仓库的时候忘记切换到 git用户 创建了所以所有者是 root ，推送的时候没有权限


解决

法一：在创建仓库的时候就使用 git用户

法二：将这个仓库的所有者改为 git，并且仓库里面的子文件夹的所有者也是 git，一直到没有子文件夹为止
如下图这种还是会报错，必须仓库里面的每个文件夹及其子文件夹及其子子文件夹……的所有者均为 git 即可，然后在修改他们的读写执行的权限，看下面（RWX 权限设置）




RWX 权限设置




如果部署过程中遇到了 有关权限 的报错，看下仓库和博客目录是不是 root用户， 因为我们本地使用的是 git用户 进行部署，所以会不够权限。再不行查看文件夹以及文件的 RWX 权限


</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/05/01/MySQL/" title="MySQL基础">MySQL基础</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-01T02:32:33.000Z" title="发表于 2021-05-01 10:32:33">2021-05-01</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-26T06:31:30.480Z" title="更新于 2021-12-26 14:31:30">2021-12-26</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/MySQL/">MySQL</a></span></div><div class="content">

MySQL常用命令汇总



创建用户、删除用户、修改自己密码、修改其他用户密码
1234$ CREATE USER &#x27;user_name&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;user_password&#x27;;$ DROP USER &#x27;user_name&#x27;@&#x27;loaclhost&#x27;;$ SET PASSWORD = PASSWORD(&#x27;新密码&#x27;);$ SET PASSWORD FOR &#x27;user_name&#x27;@&#x27;localhost&#x27; = PASSWORD(&#x27;新密码&#x27;);


MySql安装 - Windows
如果安装过程中，出错了或者想重新再装
sc delete mysql （删除已经安装好的MySQL服务，慎重）


下面用MySQL-5.7.34 例子，注意：exe 文件和 zip 安装不一样


下载 mysql
1https://dev.mysql.com/downloads/mysql/5.7.html
解压后添加环境变量



添加 my.ini 文件
123456789101112[client]port=3306default-character-set=utf8[mysqld]# 设置自己为自己的 mysql 安装目录basedir=D:\Program Files\RELY\mysql-5.7.34-winx64\# 设置为 mysql 的数据目录，这个目录是系统创建，不用认为创建datadir=D:\Program Files\RELY\mysql-5.7.34-winx64\data\port=3306character_set_server=utf8# 跳过安全检查skip-grant-tables


用管理员权限打开 cmd，进入到 mysql 的 bin 目录下
1mysqld -install


初始化数据库
1mysqld --initialize-insecure --user=mysql





启动 mysql 服务
1net start mysql


停止 mysql 服务：net stop mysql


进入 mysql 管理终端
12# 表示当前 root 用户密码为空mysql -u root -p


修改 root 用户密码
1234567use mysql;# 下面语句就是表示 修改 root 用户密码为 123456update user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27; and Host=&#x27;localhost&#x27;;# 刷新权限flush privileges;# 退出（只是退出 mysql 终端）quit


修改 my.ini 文件，再次进入就会进行权限验证了


重新启动 mysql 
123net stop mysqlnet start mysqlmysql -u root -p




最后，全部指令浏览注：如果安装过程出错，清楚 mysql 服务（sc delete mysql），重新按照步骤安装


Windows下安装多个MySQL服务
由于我本机装了MySQL 5 点多
由于某些要求，需要比这个更高的版本，因此上网查找看能不能装两个 MySQL 服务

步骤有点简略，仅仅记录一下过程，前提是要学会怎么装 MySQL
端口不要和原来服务相同
1234567891011121314151617181920212223[mysqld]# 设置3307端口port=3307# 设置mysql的安装目录——文件路径basedir=D:\Program Files\RELY\mysql-8.0.21-winx64# 允许最大连接数max_connections=200# 允许连接失败的次数。max_connect_errors=10# 服务端使用的字符集默认为utf8mb4character-set-server=utf8mb4# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证#mysql_native_passworddefault_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8mb4[client]# 设置mysql客户端连接服务端时默认使用的端口port=3307default-character-set=utf8mb4
初始化数据库，密码在其中
1$ mysqld --initialize --console

安装 MySQL 服务，给他起个名字叫MySQL8，就这一步与单独安装 MySQL 不同，其他基本都相同
1$ mysqld install MySQL8 --defaults-file=&quot;D:\Program Files\RELY\mysql-8.0.21-winx64\my.ini&quot;

启动 mysql 服务


修改密码

然后尝试登陆两个 MySQL 服务

完美收官
MySQL安装 - CentOs
查看系统版本：

12$ uname -a$ uname -m



在某一个位置保存下载 MySQL RPM包
1$ wget https://dev.mysql.com/get/mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar
PS：CentOS7.6 自带的类 mysql 数据库是 mariadb，会跟 mysql 冲突，要先删除

首先查询看有没有 mariadb
1$ rpm -qa | grep mariadb
有就删除
1$ rpm -e --nodeps mariadb-libs




解压 mysql RPM 包
1$  tar -xvf mysql-5.7.26-1.el7.x86_64.rpm-bundle.tar


然后安装 MySQL
1234$ rpm -ivh mysql-community-common-5.7.26-1.el7.x86_64.rpm$ rpm -ivh  mysql-community-libs-5.7.26-1.el7.x86_64.rpm$ rpm -ivh mysql-community-client-5.7.26-1.el7.x86_64.rpm$ rpm -ivh mysql-community-server-5.7.26-1.el7.x86_64.rpm



启动 Mysql
1$ systemctl start mysqld.service


如果启动失败，如下图


出现此错误是由于多次安装mysql。运行命令：
1$ ps -A | grep mysql
使用以下命令终止进程：
1$ sudo pkill mysql
然后运行命令：
1$ ps -A | grep mysqld
还可以通过运行以下命令终止此进程：
1$ sudo pkill mysqld



查看默认分配密码登录
12$ grep &quot;password&quot; /var/log/mysqld.log$ mysql -u root -p[password]



如果输入第一个命令之后是这样的
现在我不知道是什么原因，可能是因为我没卸载干净吧！！



下面解决方法

vim /etc/my.cnf 修改里面代码
加上一行
1skip-grant-tables





修改密码
首先可以设置密码提示（默认 validate_password_policy=1）
1$ mysql&gt; set global validate_password_policy=0;
设置密码
1$ mysql&gt; set password for &#x27;root&#x27;@&#x27;localhost&#x27;=password(&#x27;自己的密码&#x27;);


如果设置不了，如图


12$ use mysql;$ update user set authentication_string=password(&#x27;123456&#x27;) where user=&quot;root&quot;;



设置好了之后刷新使密码生效
1$ mysql&gt; flush privileges;




MySQL卸载 - CentOs
查看 mysql 安装了哪些东西
1$ rpm -qa | grep -i mysql


卸载开始（要用 1 的结果卸载）
1234$ yum remove mysql-community-libs-5.7.26-1.el7.x86_64$ yum remove mysql-community-server-5.7.26-1.el7.x86_64$ yum remove mysql-community-common-5.7.26-1.el7.x86_64$ yum remove mysql-community-client-5.7.26-1.el7.x86_64

然后用 rpm -qa | grep -i mysql查看是否卸载干净


查找 mysql 相关目录
1$ find / -name mysql


删除相关文件（用 3 的结果删除）
1234$ rm -rf /var/lib/mysql$ rm -rf /var/lib/mysql/mysql$ rm -rf /usr/share/mysql$ rm -rf /etc/selinux/targeted/active/modules/100/mysql
删除 /etc/my.cnf
1$ rm -rf /etc/my.cnf


删除/var/log/mysqld.log（如果不删除这个文件，会导致新安装的mysql无法生存新密码，导致无法登陆）
1$ rm -rf /var/log/mysqld.log








数据库命令连接MySQL

登录前，保证 MySQL 服务已经启动

连接到 MySQL 服务（MySQL数据库）的指令
1mysql -h 主机ip -P 端口 -u 用户名 -p密码

-p密码不要有空格
-p后面没有写密码，回车会要求输入密码
如果没有写 -h 主机，默认就是本机
如果没有写 -P 端口，默认就是3306
在实际工作中，端口 3306 是会修改成其他的




图形界面 - Navicat
连接数据库


创建数据库


创建表……


数据库三层结构
所谓安装 MySQL 数据库，就是在主机安装一个数据库管理管理系统（DBMS），这个管理程序可以管理多个数据库。
DBMS（database manage system）

一个数据库中可以创建多个表，以保存数据（信息）

数据库管理系统（DBMS）、数据库和表的关系如图所示

数据库 - 普通表的本质是文件 




SQL语句分类
DDL：数据定义语句 [create 表，库……]
DML：数据操作语句 [增加 insert、修改 update、删除 delete]
DQL：数据查询语句 [select]
DCL：数据控制语句 [管理数据库：比如用户权限 grant revoke]

创建数据库123456CREATE DATABASE [IF NOT EXISTS] db_name[create_specification [, create_specification]...]create_specification:	[DEFAULT] CHARACTER SET charset_name	[DEFAULT] COLLATE collation_name

CHARACTER SET ：指定数据库采用的字符集，如果不指定字符集，默认 utf8
COLLATE ：指定数据库字符集的校对规则
常用的 utf8_bin [区分大小写]
utf8_general_ci [不区分大小写] 
注意默认是 utf8_general_ci




例子
分别创建 3 个数据库，看写法

1234567891011121314# 创建 db02 数据库，并且不设置字符集和校对规则# 字符集默认为 utf8# 校对规则默认为 utf8_general_ciCREATE DATABASE db02;# 创建 db03 数据库# 字符集设置为 utf8# 校对规则为默认CREATE DATABASE db03 CHARACTER SET utf8;# 创建 db04 数据库# 字符集设置为 utf8# 校对规则设置为 utf8_binCREATE DATABASE db04 CHARACTER SET utf8 COLLATE utf8_bin;

创建表
如果创建表的时候没有指定
引擎、字符集、排序规则等参数默认是数据库的字符集和排序规则
比如下面的 db02数据库为 utf8 utf8_general_ci
​                  db04数据库为 utf8 utf8_bin
那么创建表的时候不设置参数的话就默认是数据库的参数



查看删除数据库12345678# 显示数据库语句SHOW DATABASES# 显示数据库创建语句SHOW CREATE DATABASE db_name# 数据库删除语句 DROP DATABASE [IF EXISTS] db_name


备份恢复数据库
备份数据库（DOS下）
1mysqldump -u 用户名 -p -B 数据库1 数据库2 数据库n &gt; 文件名.sql

比如我把数据库 db01 db02 db03 db04 备份到 F 盘下取名为 bak.sql
其实 bak.sql 文件就是对应的 sql 语句



恢复数据库（进入 MySQL命令行）
1sourse 文件名.sql

法一：上面的命令


法二：直接复制备份文件 bak.sql 里面的 sql 语句，然后执行





备份恢复数据库的表
备份数据库的表
1mysqldump -u 用户名 -p 数据库 表1 表2 表n &gt; 文件名.sql

恢复数据表
连接数据库之后，使用需要恢复到的数据库中，然后执行source 路径+文件名.sql
使用哪个数据库就会恢复到哪个数据库中


表表的创建1234567891011CREATE TABLE table_name(    field1 datatype,    field2 datatype,    field3 datatype) character set 字符集 collate 校对规则 engine 存储引擎# field：指定列名 datatype：指定列类型（字段类型）# character set：如不指定则为坐在数据库的字符集# collate：如不指定则为所在数据库的校对规则# engine：引擎

EX：创建 id（整形）、name（字符串）、password（字符串）、birthday（日期），并且字符集设置为 utf8、校对规则为 utf8_bin、引擎为 INNODB

123456CREATE TABLE `user` (		id INT,		`name` VARCHAR(255),		`password` VARCHAR(32),		birthday DATE)		CHARACTER SET utf8 COLLATE utf8_bin ENGINE INNODB;


表数据添加1234-- 单列添加INSERT INTO table_name ( field1, field2,...fieldN ) VALUES(value1, value2,...valueN);-- 多列添加INSERT INTO table_name ( field1, field2,...fieldN ) VALUES(value1, value2,...valueN),(value1, value2,...valueN),.....;




MySql常用数据类型（列类型）


注意：
char(size)：这个 size 表示字符的个数，范围为 [0~255]
varchar(size)：这个size 也表示字符的个数，范围为[0~65535]

用户管理用户创建12345$ CREATE USER &#x27;用户名&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;用户密码&#x27;;# 赋全部权限$ GRANT ALL PRIVILEGES ON *.* TO &#x27;用户名&#x27;@&#x27;登录地址&#x27;;$ FLUSH PRIVILEGES;

下面演示


密码太简单了


密码复杂



给其他用户密码修改
root 用户修改普通用户的密码

1$ SET PASSWORD FOR &#x27;用户名&#x27;@&#x27;登录地址&#x27; = PASSWORD (&#x27;新密码&#x27;);

自己密码修改1$ SET PASSWORD=PASSWORD(&#x27;新密码&#x27;);

查看连接数12mysql&gt; SHOW FULL PROCESSLIST;mysql&gt; SHOW STATUS LIKE &#x27;Threads%&#x27;;

索引12345678910-- 创建索引-- index_name 索引名-- ON table_name(col_name) 表示在表(table_name)的属性(col_name)上建立索引CREATE INDEX index_name ON table_name(col_name)-- 查看表是否创建了索引SHOW INDEX FROM table_name-- 删除索引DROP INDEX index_name ON table_name
索引类型
主键索引：PRIMARY KEY 列自动生成索引
12345-- 建立主键索引ALTER TABLE table_name ADD PRIMARY KEY (col_name)-- 删除主键索引ALTER TABLE table_name DROP PRIMARY KEY


唯一索引：UNIQUE
1CREATE UNIQUE INDEX index_name ON table_name(col_name)


普通索引：INDEX
123456-- 建立普通索引CREATE INDEX index_name ON table_name(col_name)ALTER TABLE table_name ADD INDEX index_name (col_name)-- 删除普通索引DROP INDEX index_name ON table_name


全文索引：FULLTEXT
比如网站搜索一篇文章的内容，模糊查询
MySQL 自带全文索引不好用
开发中考虑使用：全文搜索两个框架：Solr 和 ElasticSearch（ES）



</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/03/27/Battle-of-Tanks/" title="Battle of Tanks">Battle of Tanks</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-27T08:28:58.000Z" title="发表于 2021-03-27 16:28:58">2021-03-27</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-04T07:42:03.688Z" title="更新于 2021-04-04 15:42:03">2021-04-04</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/java/">java</a></span></div><div class="content">
Java绘图坐标体系坐标原点位于左上角，以像素为单位


像素：密度单位
比如屏幕分辨率是 1920x1080 表示每一行有 1920 个像素点，共有 1080 行
所以该屏幕一共有 1920x1080=2,073,600 个像素

线程-基础
程序 Program：为了完成特定任务，用某种语言编写的一组指令的集合，也就是代码
进程：指运行中的程序、进程是一次执行过程，或是正在运行的一个程序、是动态过程，有产生 存在 消亡的过程
线程
由进程创建，是进程的一个实体
一个进程可以拥有多个线程



线程使用继承 Thread 实现多继承
创建一个 Cat 类 每隔 1 秒输出 喵喵
然后分别查看主线程和 Cat 创建的进程

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.ThreadUse;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 9:55 * @ Description: com.ThreadUse * @ Version: 1.0 * 演示通过继承 Thread 类创建线程 */public class Thread01 &#123;    public static void main(String[] args) throws InterruptedException &#123;        // 创建cat对象，可以当成线程使用        Cat cat = new Cat();        cat.start();    // 启动线程 -&gt; 最终会执行 Cat run 方法        // 说明：当 main 线程启动一个子线程 Thread-0 主线程不会阻塞，会继续执行        // 主线程和子线程交替执行        System.out.println(Thread.currentThread().getName());        for (int i = 0; i &lt; 60; i++) &#123;            System.out.println(&quot;主线程 i = &quot; + i);            Thread.sleep(1000);        &#125;    &#125;&#125;/** * 当一个类继承了 Thread 类，该类就可以当做线程使用 * 重写 run 方法，写上自己的业务代码 * run 方法来自 Thread 类实现了Runnable 接口的 run 方法 * *//*    @Override    public void run() &#123;        if (target != null) &#123;            target.run();        &#125;    &#125; */class Cat extends Thread &#123;    private int times = 0;    @Override    public void run() &#123;        while (true) &#123;            System.out.println(&quot;喵喵喵&quot; + (++times) + &quot;，线程名称：&quot; + Thread.currentThread().getName());            // 让该进程休眠 1 秒            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            if (times == 80) &#123;                 break;            &#125;        &#125;    &#125;&#125;

分析：
main 线程会创建一个 Cat 线程
main 函数的线程名为：main
Cat 线程名称为：Thread-0


因为 main 线程执行次数为 60，Thread-0 线程执行次数为80
所以 main 线程先消亡，Thread-0 线程后消亡





这里为何不直接调用 cat.run()，并没有创建新线程

如果调用了 cat.run() 那么下面的代码就要等这个方法执行完成后方可执行（看下图），串行执行了
而且 cat 的线程名称就是 mian 并没有开辟新线程





下面看 start(); 执行源码分析主要执行，无用的省略

12345678// 1	public synchronized void start() &#123;        start0();    &#125;// 2	// start0() 是本地方法，由JVM调用，底层是 C/C++实现	// 真正实现多线程的是 start0() 方法    private native void start0();

通过实现 Runnable 接口实现多线程
说明：由于Java 是单继承的，如果一个类继承了其他类就不能继承 Thread 类了，所以想要实现多线程就可以通过实现 Runnable 接口来实现多线程


12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.ThreadUse;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 11:40 * @ Description: com.ThreadUse * @ Version: 1.0 * 通过实现 Runnable 接口实现多线程 */public class Thread02 &#123;    public static void main(String[] args) &#123;       Dog dog = new Dog();       // 创建一个 Thread 对象，把 dog对象(实现Runnable)，放入 Thread        Thread thread = new Thread(dog);        thread.start();                ThreadProxy threadProxy = new ThreadProxy(dog);        threadProxy.start();    &#125;&#125;class Dog implements Runnable &#123;    @Override    public void run() &#123;        int count = 0;        while (true) &#123;            System.out.println(&quot;汪汪叫：&quot; + (++count) + Thread.currentThread().getName());            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            if (count == 10) &#123;                break;            &#125;        &#125;    &#125;&#125;// 线程代理类，模拟了一个极简的 Thread类class ThreadProxy implements Runnable &#123;    private Runnable target = null;    @Override    public void run() &#123;        if (target != null) &#123;            target.run();        &#125;    &#125;    public ThreadProxy(Runnable target) &#123;        this.target = target;    &#125;    public void start() &#123;        start0();   // 真正实现多线程的方法    &#125;    public void start0() &#123;        run();    &#125;&#125;

上面代码的 ThreadProxy 只是模拟Thread


构造器接受一个实现了 Runnable 类的对象实例 

用户创建线程需要调用 start() 方法

start() 方法再调用 start0() 方法

start0() 方法再调用 run() （这个run方法是传经来的对象）
比如上面代码就是 Dog 的实例 dog


实现两个线程并发123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.ThreadUse;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 12:28 * @ Description: com.ThreadUse * @ Version: 1.0 * main 函数启动两个子线程 */public class Thread03 &#123;    public static void main(String[] args) &#123;        T1 t1 = new T1();        T2 t2 = new T2();        Thread thread1 = new Thread(t1);        Thread thread2 = new Thread(t2);        thread1.start();        thread2.start();    &#125;&#125;class T1 implements Runnable &#123;    private int count = 0;    @Override    public void run() &#123;        do &#123;            System.out.println(&quot;T1:Hello,World &quot; + (++count) + Thread.currentThread().getName());            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125; while (count != 80);    &#125;&#125;class T2 implements Runnable &#123;    private int count = 0;    @Override    public void run() &#123;        do &#123;            System.out.println(&quot;T2:Hello,World &quot; + (++count) + Thread.currentThread().getName());            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125; while (count != 80);    &#125;&#125;// OutT1:Hello,World 1Thread-0T2:Hello,World 1Thread-1T1:Hello,World 2Thread-0T2:Hello,World 2Thread-1T1:Hello,World 3Thread-0T2:Hello,World 3Thread-1................T1:Hello,World 79Thread-0T2:Hello,World 79Thread-1


继承 Thread 和 实现 Runnable 的区别
从java的设计看，这两者本身没有本质的区别，Thread本身就实现了 Runnable 接口
start() -&gt; start0()

实现 Runnable 接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制


12345T3 t3 = new T3();Thread thread1 = new Thread(t3);Thread thread2 = new Thread(t3);thread1.start();thread2.start();


卖票
下面是分别通过 继承和实现接口 两种方法，但都会出现超卖

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.Thread.ThreadUse;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 12:55 * @ Description: com.ThreadUse * @ Version: 1.0 * 使用多线程模拟三个窗口同事售票 100 张 */public class SellTicket &#123;    public static void main(String[] args) &#123;        // 通过继承实现//        SellTicket01 sellTicket01 = new SellTicket01();//        SellTicket01 sellTicket02 = new SellTicket01();//        SellTicket01 sellTicket03 = new SellTicket01();//        sellTicket01.start();//        sellTicket02.start();//        sellTicket03.start();        // 通过接口实现        SellTicket02 sellTicket = new SellTicket02();        Thread thread01 = new Thread(sellTicket);        Thread thread02 = new Thread(sellTicket);        Thread thread03 = new Thread(sellTicket);        thread01.start();        thread02.start();        thread03.start();    &#125;&#125;// 通过继承方式class SellTicket01 extends Thread &#123;    private static int ticketNum = 100; // 让多个线程去销售    @Override    public void run() &#123;        while (true) &#123;            if (ticketNum &lt;= 0) &#123;                System.out.println(&quot;票以售完&quot;);                break;            &#125;            try &#123;                Thread.sleep(50);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;窗口：&quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot; +                    &quot; 剩余票数：&quot; + (--ticketNum));        &#125;    &#125;&#125;// 通过 接口方式class SellTicket02 implements Runnable &#123;    private int ticketNum = 100; // 让多个线程去销售    @Override    public void run() &#123;        while (true) &#123;            if (ticketNum &lt;= 0) &#123;                System.out.println(&quot;票以售完&quot;);                break;            &#125;            try &#123;                Thread.sleep(50);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;窗口：&quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot; +                    &quot; 剩余票数：&quot; + (--ticketNum));        &#125;    &#125;&#125;


线程终止
设置 loop 值实现——通知方式

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.Thread.ThreadExit;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 14:04 * @ Description: com.Thread.ThreadExit * @ Version: 1.0 */public class ThreadExit01 &#123;    public static void main(String[] args) throws InterruptedException &#123;        T t = new T();        t.start();        System.out.println(&quot;主线程休眠 10s&quot;);        Thread.sleep(10000);        t.setLoop(false);    &#125;&#125;class T extends Thread &#123;    private int num = 0;    private boolean loop = true;    @Override    public void run() &#123;        while (loop) &#123;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;T运行中......&quot; + (++num));        &#125;    &#125;    public void setLoop(boolean loop) &#123;        this.loop = loop;    &#125;&#125;// Out主线程休眠 10sT运行中......1T运行中......2T运行中......3T运行中......4T运行中......5T运行中......6T运行中......7T运行中......8T运行中......9T运行中......10Process finished with exit code 0
线程常用方法
setName    // 设置线程名称

getName   // 返回线程名称

start

run    // 调用线程对象 run 方法

setPriority    // 更改线程的优先级
12345678910111213141516    /**  * The minimum priority that a thread can have.  */ public static final int MIN_PRIORITY = 1;   /**  * The default priority that is assigned to a thread.  */ public static final int NORM_PRIORITY = 5;    /**  * The maximum priority that a thread can have.  */ public static final int MAX_PRIORITY = 10;   
getPriority    // 获取线程的优先级

sleep    // 在指定的毫秒数内让当前正在执行的线程休眠

interrupt    // 中断程序

yield    // 线程礼让，让出cpu，让其他线程执行，但礼让时间不确定，故不一定礼让成功

join    // 线程插队，插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.Thread.Method;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 15:25 * @ Description: com.Thread.Method * @ Version: 1.0 */public class ThreadMethod01 &#123;    public static void main(String[] args) throws InterruptedException &#123;        T t = new T();        t.start();        // 主线程吃包子        for (int i = 1; i &lt;= 20; i++) &#123;            Thread.sleep(1000);            System.out.println(&quot;主线程（小弟）吃了 &quot; + i + &quot; 个包子&quot;);            // 主线程吃 5 个包子就让老大吃完 20 个然后在吃            if (i == 5) &#123;                System.out.println(&quot;主线程（小弟）让 包子给 老大吃&quot;);                // join 线程插队                t.join();                // yield 礼让//                Thread.yield();                System.out.println(&quot;老大吃完了，接下来主线程（小弟）吃&quot;);            &#125;        &#125;    &#125;&#125;class T extends Thread &#123;    @Override    public void run() &#123;        for (int i = 1; i &lt;= 20; i++) &#123;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;子线程（老大）吃了 &quot; + i + &quot; 个包子&quot;);        &#125;    &#125;&#125;// Out子线程（老大）吃了 1 个包子主线程（小弟）吃了 1 个包子主线程（小弟）吃了 2 个包子子线程（老大）吃了 2 个包子主线程（小弟）吃了 3 个包子子线程（老大）吃了 3 个包子主线程（小弟）吃了 4 个包子子线程（老大）吃了 4 个包子主线程（小弟）吃了 5 个包子主线程（小弟）让 包子给 老大吃子线程（老大）吃了 5 个包子子线程（老大）吃了 6 个包子子线程（老大）吃了 7 个包子子线程（老大）吃了 8 个包子子线程（老大）吃了 9 个包子子线程（老大）吃了 10 个包子子线程（老大）吃了 11 个包子子线程（老大）吃了 12 个包子子线程（老大）吃了 13 个包子子线程（老大）吃了 14 个包子子线程（老大）吃了 15 个包子子线程（老大）吃了 16 个包子子线程（老大）吃了 17 个包子子线程（老大）吃了 18 个包子子线程（老大）吃了 19 个包子子线程（老大）吃了 20 个包子老大吃完了，接下来主线程（小弟）吃主线程（小弟）吃了 6 个包子主线程（小弟）吃了 7 个包子主线程（小弟）吃了 8 个包子主线程（小弟）吃了 9 个包子主线程（小弟）吃了 10 个包子主线程（小弟）吃了 11 个包子主线程（小弟）吃了 12 个包子主线程（小弟）吃了 13 个包子主线程（小弟）吃了 14 个包子主线程（小弟）吃了 15 个包子主线程（小弟）吃了 16 个包子主线程（小弟）吃了 17 个包子主线程（小弟）吃了 18 个包子主线程（小弟）吃了 19 个包子主线程（小弟）吃了 20 个包子




用户线程和守护线程
用户线程：也叫工作线程，当线程的任务执行完或通知方式
守护线程：一般为工作线程服务，当所有的用户线程结束，守护线程自动结束
常见的守护线程：垃圾回收机制


下面测试如何将一个线程设置为守护线程
ThreadMethod02

12345678910111213141516171819202122232425262728293031323334353637package com.Thread.Method;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 16:03 * @ Description: com.Thread.Method * @ Version: 1.0 */public class ThreadMethod02 &#123;    public static void main(String[] args) throws InterruptedException &#123;        Thread thread = new Thread(new MyDaemonThread());        // 如果我们希望当 main 线程结束以后，子线程自动结束        // 只需将子线程设置为守护线程        thread.setDaemon(true);        thread.start();        for (int i = 1; i &lt;= 5; i++) &#123;            Thread.sleep(1000);            System.out.println(&quot;我是 main&quot;);        &#125;    &#125;&#125;class MyDaemonThread implements Runnable &#123;    @Override    public void run() &#123;        for (; ; ) &#123;            try &#123;                Thread.sleep(50);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;我是MyDaemonThread&quot;);        &#125;    &#125;&#125;


线程生命周期


通过下面代码查看状态

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.Thread.State;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 16:47 * @ Description: com.Thread.State * @ Version: 1.0 */public class ThreadState &#123;    public static void main(String[] args) throws InterruptedException &#123;        T t = new T();        System.out.println(t.getName() + &quot; 状态 &quot; + t.getState());        t.start();        while (Thread.State.TERMINATED != t.getState()) &#123;            System.out.println(t.getName() + &quot; 状态 &quot; + t.getState());            Thread.sleep(1000);        &#125;        System.out.println(t.getName() + &quot; 状态 &quot; + t.getState());    &#125;&#125;class T extends Thread &#123;    @Override    public void run() &#123;       for (int i = 0; i &lt; 10; i++) &#123;           try &#123;               Thread.sleep(1000);           &#125; catch (InterruptedException e) &#123;               e.printStackTrace();           &#125;           System.out.println(&quot;Hi &quot; + i);       &#125;    &#125;&#125;// OutThread-0 状态 NEWThread-0 状态 RUNNABLEThread-0 状态 RUNNABLEHi 0Thread-0 状态 RUNNABLEHi 1Thread-0 状态 TIMED_WAITINGHi 2Thread-0 状态 TIMED_WAITINGHi 3Thread-0 状态 TIMED_WAITINGHi 4Thread-0 状态 TIMED_WAITINGHi 5Thread-0 状态 TIMED_WAITINGHi 6Thread-0 状态 TIMED_WAITINGHi 7Thread-0 状态 TIMED_WAITINGHi 8Thread-0 状态 TIMED_WAITINGHi 9Thread-0 状态 TERMINATED


线程同步机制
Synchronize
在多线程编程中，一些敏感数据不允许被多个线程同时访问，保证数据在任何时刻，最多有一个线程访问，以保证数据的完整性

12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.Thread.Synchronize;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 12:55 * @ Description: com.Thread.Synchronize * @ Version: 1.0 * 使用多线程模拟三个窗口同事售票 100 张 */public class SellTicket &#123;    public static void main(String[] args) &#123;        // 通过继承实现        SellTicket01 sellTicket01 = new SellTicket01();        SellTicket01 sellTicket02 = new SellTicket01();        SellTicket01 sellTicket03 = new SellTicket01();        sellTicket01.start();        sellTicket02.start();        sellTicket03.start();        // 通过接口实现//        SellTicket02 sellTicket = new SellTicket02();//        Thread thread01 = new Thread(sellTicket);//        Thread thread02 = new Thread(sellTicket);//        Thread thread03 = new Thread(sellTicket);//        thread01.start();//        thread02.start();//        thread03.start();    &#125;&#125;class SellTicket01 extends Thread &#123;    private static int ticketNum = 100; // 让多个线程去销售    private boolean loop = true;    static Object object = new Object();    public void sell() &#123;  // 同步方法，在同一时刻，只能有一个线程来执行该方法        synchronized (object) &#123;            if (ticketNum &lt;= 0) &#123;                loop = false;                System.out.println(&quot;票以售完&quot;);                return;            &#125;            try &#123;                Thread.sleep(50);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;窗口：&quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot; +                    &quot; 剩余票数：&quot; + (--ticketNum));        &#125;    &#125;    @Override    public void run() &#123;        while (loop) &#123;            sell();        &#125;    &#125;&#125;class SellTicket02 implements Runnable &#123;    private static int ticketNum = 100; // 让多个线程去销售    private boolean loop = true;    Object object = new Object();    // 同步方法实现加锁    // 这时锁在 this 对象    // 也可以在代码块写 synchronized ，这是同步代码块    public /*synchronized*/ void sell() &#123;  // 同步方法，在同一时刻，只能有一个线程来执行该方法        synchronized (/*this*/ object) &#123;    // 写this或object都可以            if (ticketNum &lt;= 0) &#123;                loop = false;                System.out.println(&quot;票以售完&quot;);                return;            &#125;            try &#123;                Thread.sleep(50);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;窗口：&quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot; +                    &quot; 剩余票数：&quot; + (--ticketNum));        &#125;    &#125;    @Override    public void run() &#123;        while (loop) &#123;            sell();        &#125;    &#125;&#125;


线程死锁
多个线程都占用了对方的锁资源，但不肯相让，导致了死锁


举例

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.Thread.Synchronize;import javax.sound.midi.Soundbank;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 20:06 * @ Description: com.Thread.Synchronize * @ Version: 1.0 */public class DeadLock &#123;    public static void main(String[] args) &#123;        DeadLockDemo deadLockDemo = new DeadLockDemo(true);        DeadLockDemo deadLockDemo1 = new DeadLockDemo(false);        deadLockDemo.start();        deadLockDemo1.start();    &#125;&#125;class DeadLockDemo extends Thread &#123;    private boolean flag;    static Object o1 = new Object();    static Object o2 = new Object();    public DeadLockDemo(boolean flag) &#123;        this.flag = flag;    &#125;    @Override    public void run() &#123;        while (true) &#123;            if (flag) &#123;                synchronized (o1) &#123;                    System.out.println(Thread.currentThread().getName() + &quot; 进入了 1 &quot;);                    synchronized (o2) &#123;                        System.out.println(Thread.currentThread().getName() + &quot; 进入了 2 &quot;);                    &#125;                &#125;            &#125; else &#123;                synchronized (o2) &#123;                    System.out.println(Thread.currentThread().getName() + &quot; 进入了 3 &quot;);                    synchronized (o1) &#123;                        System.out.println(Thread.currentThread().getName() + &quot; 进入了 4 &quot;);                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;


释放锁
当前线程的同步方法、同步代码执行结束
当前线程在同步代码块、同步方法中遇到了 break、return
当前线程在同步代码块、同步方法中出现了未处理的 Error、Exception，导致异常结束
当前线程在同步代码快、同步方法中执行了线程对象的 wait() 方法，当前线程暂停，并释放锁


下面操作不会释放锁


线程执行同步代码块或者同步方法时，程序调用了 Thread.sleep()、Thread.yield() 方法暂停当前线程的执行，不会释放锁
线程执行同步代码块时，其他线程调用了该线程的 suspend() 方法将该线程挂起，该线程不会释放锁

练习
（1）在main方法中启动两个线程
（2）第 1 个线程循环随机打印 100 以内的整数
（3）直到第 2 个线程从键盘读取了 “Q” 命令

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.Homework;import java.util.Scanner;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 21:11 * @ Description: com.Homework * @ Version: 1.0 */public class Homework01 &#123;    public static void main(String[] args) &#123;        T1 t1 = new T1();        Thread thread = new Thread(t1);        thread.start();        T2 t2 = new T2(t1);        Thread thread1 = new Thread(t2);        thread1.start();    &#125;&#125;// 随机输出 1-100 数字class T1 implements Runnable &#123;    private boolean loop = true;    public boolean isLoop() &#123;        return loop;    &#125;    public void setLoop(boolean loop) &#123;        this.loop = loop;    &#125;    @Override    public void run() &#123;        // 输出 1-100 数字        while (loop) &#123;            System.out.println((int) (Math.random() * 100) + 1);            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(&quot;T1 线程退出&quot;);    &#125;&#125;// 输入 Q 上面的线程就会退出class T2 implements Runnable &#123;    private T1 a;    private Scanner scanner = new Scanner(System.in);    public T2(T1 a) &#123;   // 构造器传入 T1 对象        this.a = a;    &#125;    @Override    public void run() &#123;        while (true) &#123;            // 接受到用户的输入            System.out.println(&quot;请输入指令(Q)表示退出 : &quot;);            char key = scanner.next().toUpperCase().charAt(0);            if (key == &#x27;Q&#x27;) &#123;                // 以通知的方式结束 a                a.setLoop(false);                break;            &#125;        &#125;        System.out.println(&quot;T2 线程退出&quot;);    &#125;&#125;





（1）有 2 个用户分别从同一个卡上取钱 总额为 10000
（2）每次都取 1000，当余额不足时，不能取款
（3）不能出现超取现象

12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.Homework;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 21:47 * @ Description: com.Homework * @ Version: 1.0 */public class Homework02 &#123;    public static void main(String[] args) &#123;        T t = new T();        Thread thread1 = new Thread(t);        thread1.setName(&quot;T1&quot;);        Thread thread2 = new Thread(t);        thread2.setName(&quot;T2&quot;);        thread1.start();        thread2.start();    &#125;&#125;// 取款线程class T implements Runnable &#123;    private int money = 10000;    @Override    public void run() &#123;        while (true) &#123;            synchronized (this) &#123;                if (money &lt; 1000) &#123;                    System.out.println(&quot;余额不足！！！&quot;);                    break;                &#125;                money -= 1000;                System.out.println(Thread.currentThread().getName() + &quot; 取出 1000, 当前余额 : &quot; + money);            &#125;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/03/22/STL/" title="STL">STL</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-22T10:30:25.000Z" title="发表于 2021-03-22 18:30:25">2021-03-22</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-18T09:15:02.980Z" title="更新于 2021-04-18 17:15:02">2021-04-18</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a></span></div><div class="content">
vector接口
构造函数

vector    // 采用模板实现类实现，默认构造函数
vector(v.begin(), v.end)    // 拷贝 v[begin(), end())区间的元素
vector(n, elem)    // 构造函数将 n 个 elem 拷贝给本身
vector(const vector &amp;vec)   // 拷贝构造函数


常用赋值

assign(beg, end);    // 将 [begin, end) 区间的数据拷贝赋值给本身
assign(n, elem);    // 将n个elem拷贝赋值给本身
vector&amp; operator=(const vector &amp;vec);    // 重载等号操作符
swap(vec);    // 将vec与本身的元素互换

12345678910111213// 构造vector&lt;int&gt; v1;vector&lt;int&gt; v2(10, 5);	// 10个5vector&lt;int&gt; v3(v2.begin(), v2.end());	// 将v2拷贝到v3// 赋值vector&lt;int&gt; v4;v4.assign(v3.begin(), v3.end());	// 将v3赋值给v4vector&lt;int&gt; v5;v5 = v3;	// 用等号赋值一样的//swap交换v5.swap(v4);	// 将v5和v4内容互换


大小操作

size();     // 返回元素个数
empty();
resize(int num);     // 重新定义容器长度，如果变长，则用默认值填充新位置，如果变短，则超出的部分元素舍弃
resize(int num, elem);
capacity();     // 容器的容量
reserve(int len);    // 预留len和元素长度，预留位置不初始化，元素不可访问


数据存储操作

at(int index);    // 越界抛异常 out_of_range
operator[];    // 越界运行直接报错
front();    // 返回第一个元素
back();    // 返回最后一个元素


插入和删除

insert(const_iterator pos, int count, elem);    // 迭代器指向位置 pos 插入 count 个 元素 elem
insert(const_iterator pos, elem);    // 同上，不过默认插入一个 elem

123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void printVector(vector&lt;int&gt;&amp;v) &#123;    vector&lt;int&gt;::iterator it;    for (it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot;_&quot;;    &#125;    cout &lt;&lt; endl;&#125;int main() &#123;    vector&lt;int&gt; vec;    vec.push_back(1);    vec.push_back(2);    vec.push_back(3);    vec.push_back(4);    vec.insert(vec.begin(), 100);    printVector(vec);    vec.insert(vec.end(),3, 100);    printVector(vec);    return 0;&#125;/* out100_1_2_3_4_100_1_2_3_4_100_100_100_*/



push_back(elem);     // 尾部插入元素
pop_back();    // 删除最后一个元素
erase(const_iterator start, const_iterator end);     // 删除迭代器从 start 到 end 之间的元素
erase(const_iterator pos);     // 删除迭代器指向的元素
clear();     // 删除容器中所有元素




去重 unique


输出函数1234567891011121314151617// 正序void printVector(vector&lt;int&gt;&amp;v) &#123;    vector&lt;int&gt;::iterator it;    for (it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot;_&quot;;    &#125;    cout &lt;&lt; endl;&#125;// 逆序void printVector_reverse(vector&lt;int&gt;&amp;v) &#123;    vector&lt;int&gt;::reverse_iterator it;    for (it = v.rbegin(); it != v.rend(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot;_&quot;;    &#125;    cout &lt;&lt; endl;&#125;


swap
例子




将未使用的空间进行释放
方法如下


作用：

vector(vec)：利用拷贝构造初始匿名对象

然后匿名创建的占用空间就是使用容量
然后匿名对象和 vec 互换
之后匿名对象会自己析构









priority_queue优先队列，int 默认大的优先123456789101112131415161718192021# include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    priority_queue&lt;int&gt;q;    int n = 5;    for (int i = 0; i &lt; n; i++) &#123;        q.push(i);    &#125;    while (!q.empty()) &#123;        cout &lt;&lt; q.top() &lt;&lt; &quot; &quot;;        q.pop();    &#125;    return 0;&#125;// out// 4 3 2 1 0
priority_queue 小的优先写法12345678910111213141516171819202122# include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;&gt;&gt;q;    int n = 5;    for (int i = 0; i &lt; n; i++) &#123;        q.push(i);    &#125;    while (!q.empty()) &#123;        cout &lt;&lt; q.top() &lt;&lt; &quot; &quot;;        q.pop();    &#125;    return 0;&#125;// out//  0 1 2 3 4
结构体优先写法
不同于 sort() 函数

1234567891011121314151617181920212223242526272829303132# include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node &#123;    int val;    bool friend operator&lt;(node x, node y) &#123;        return x.val &lt; y.val;	// 这样反而是 大的 优先        // 小的优先        // return x.val &gt; y.val;    &#125;&#125;;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    priority_queue&lt;node&gt;q;    int n = 5;    for (int i = 0; i &lt; n; i++) &#123;        node tmp&#123;&#125;;        tmp.val = i;        q.push(tmp);    &#125;    while (!q.empty()) &#123;        cout &lt;&lt; q.top().val &lt;&lt; &quot; &quot;;        q.pop();    &#125;    return 0;&#125;// out// 4 3 2 1 0 


sort() 结构体比较写法1sort(v.begin(), v.begin() + k, Cmp);

写在结构体内
123456struct node &#123;    int val;    bool friend operator&lt;(node x, node y) &#123;        return x.val &lt; y.val;	// 小到大排序    &#125;&#125;;
写在结构体外
1234567struct node &#123;    int val;&#125;;bool Cmp(node x, node y) &#123;    return x.val &gt; y.val;  // 大到小排序&#125;






全排列模板
注意 while (next_permutation(左下标, 右下标))
排列的区间是 [左下标, 右下标)
此例子是 [1, 5) 不包括 m[5]

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    int count = 0;    int m[100];    int n;  cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++) &#123;        m[i] = i;    &#125; do &#123;        for (int i = 1; i &lt;= n; i++) &#123;            cout &lt;&lt; m[i] &lt;&lt; &quot; &quot;;        &#125;        count++;        cout &lt;&lt; endl;    &#125; while (next_permutation(m+1, m+5)); // 左闭右开 [m+1, m+5) 之间的数全排列    cout &lt;&lt; &quot;排列总数：&quot; &lt;&lt; count &lt;&lt; endl;    return 0;&#125;101 2 3 4 5 6 7 8 9 10 1 2 4 3 5 6 7 8 9 10 1 3 2 4 5 6 7 8 9 10 1 3 4 2 5 6 7 8 9 10 1 4 2 3 5 6 7 8 9 10 1 4 3 2 5 6 7 8 9 10 2 1 3 4 5 6 7 8 9 10 2 1 4 3 5 6 7 8 9 10 2 3 1 4 5 6 7 8 9 10 2 3 4 1 5 6 7 8 9 10 2 4 1 3 5 6 7 8 9 10 2 4 3 1 5 6 7 8 9 10 3 1 2 4 5 6 7 8 9 10 3 1 4 2 5 6 7 8 9 10 3 2 1 4 5 6 7 8 9 10 3 2 4 1 5 6 7 8 9 10 3 4 1 2 5 6 7 8 9 10 3 4 2 1 5 6 7 8 9 10 4 1 2 3 5 6 7 8 9 10 4 1 3 2 5 6 7 8 9 10 4 2 1 3 5 6 7 8 9 10 4 2 3 1 5 6 7 8 9 10 4 3 1 2 5 6 7 8 9 10 4 3 2 1 5 6 7 8 9 10 排列总数：24


lower_bound( )、upper_bound( )
数组从小到大顺序时
lower_bound(begin, end, num);    // 返回第一个 大于等于 num 的地址
upper_bound(begin, end, num);   // 返回第一个 大于 num 的地址


数组从大到小顺序时，重载lower_bound()和upper_bound() 即可找到第一个小于等于 num 的地址
lower_bound(begin, end, num, greater);    // 返回第一个 小于等于 num 的地址
upper_bound(begin, end, num, greater);     // 返回第一个 小于 num 的地



1234567891011121314151617181920212223242526272829303132333435363738# include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    int m[5];    m[0] = 0;    m[1] = 2;    m[2] = 4;    m[3] = 6;    m[4] = 8;    int pos1 = lower_bound(m, m+5, 4) - m;    int pos2 = upper_bound(m, m + 5, 4) - m;    cout &lt;&lt; &quot;pos1:&quot; &lt;&lt; pos1 &lt;&lt; endl;    cout &lt;&lt; &quot;pos2:&quot; &lt;&lt; pos2 &lt;&lt; endl;    sort(m, m + 5, greater&lt;int&gt;());    for (int i = 0; i &lt; 5; i++) &#123;        cout &lt;&lt; m[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;        int pos3 = lower_bound(m, m+5, 4, greater&lt;int&gt;()) - m;    int pos4 = upper_bound(m, m + 5, 4, greater&lt;int&gt;()) - m;    cout &lt;&lt; &quot;pos3:&quot; &lt;&lt; pos3 &lt;&lt; endl;    cout &lt;&lt; &quot;pos4:&quot; &lt;&lt; pos4 &lt;&lt; endl;    return 0;&#125;// outpos1:2pos2:38 6 4 2 0 pos3:2pos4:3
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/03/17/data%20struct%20two/" title="data struct two">data struct two</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-17T11:02:24.000Z" title="发表于 2021-03-17 19:02:24">2021-03-17</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-05T04:26:36.658Z" title="更新于 2021-04-05 12:26:36">2021-04-05</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="content">
前缀树code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package Trees.TrieTree;/** * @ Author: MingHuiFan * @ Date: 2021/3/3 - 21:09 * @ Description: Trees.PrefixTree * @ Version: 1.0 */public class trieTree &#123;    // 前缀树节点    static class TrieNode &#123;        int pass;   // 记录进过了几次        int end;    // 记录以当前节点为尾的字符串        TrieNode[] nexts;   // 记录 &#x27;a&#x27;-&#x27;z&#x27; 的路径        public TrieNode() &#123;            nexts = new TrieNode[26];        &#125;    &#125;    // 前缀树实现    public static class Trie &#123;        private TrieNode root;        public Trie() &#123;            root = new TrieNode();        &#125;        public int size() &#123;            return root.pass;        &#125;        // 插入一段字符串        public void insert(String word) &#123;            if (word == null) &#123;                return;            &#125;            TrieNode node = root;            node.pass++;            int index = 0;  // 记录字母            char[] chars = word.toCharArray();            for (int i = 0; i &lt; chars.length; i++) &#123;                index = chars[i] - &#x27;a&#x27;; // a 对应 0, b 对应 1.....                if (node.nexts[index] == null) &#123;    // 如果未出现过该字母,则创建                    node.nexts[index] = new TrieNode();                &#125;                node = node.nexts[index];                node.pass++;            &#125;            node.end++;        &#125;        // 删除一段字符        public void delete(String word) &#123;            if (search(word) == 0) &#123;                return;            &#125;            TrieNode node = root;            node.pass--;            char[] chars = word.toCharArray();            int index = 0;            for (int i = 0; i &lt; chars.length; i++) &#123;                index = chars[i] - &#x27;a&#x27;;                if (--node.nexts[index].pass == 0) &#123;                    node.nexts[index] = null;                &#125;                node = node.nexts[index];            &#125;            node.end--;            return;        &#125;        // 查询字符在树中出现的次数        public int search(String word) &#123;            if (word == null) &#123;                return 0;            &#125;            TrieNode node = root;            char[] chars = word.toCharArray();            int index = 0;            for (int i = 0; i &lt; chars.length; i++) &#123;                index = chars[i] - &#x27;a&#x27;;                // 如果未在树中存在该路径则直接返回 0                if (node.nexts[index] == null) &#123;                    return 0;                &#125;                node = node.nexts[index];            &#125;            return node.end;        &#125;        // 所有加入的字符串中，计算有多少个是以 pre 为前缀的        public int prefixNumber(String pre) &#123;            if (pre == null) &#123;                return 0;            &#125;            TrieNode node = root;            char[] chars = pre.toCharArray();            int index = 0;            for (int i = 0; i &lt; chars.length; i++) &#123;                index = chars[i] - &#x27;a&#x27;;                if (node.nexts[index] == null) &#123;                    return 0;                &#125;                node = node.nexts[index];            &#125;            return node.pass;        &#125;    &#125;    public static void main(String[] args) &#123;        Trie trie = new Trie();        String string0 = &quot;abc&quot;;        String string1 = &quot;abc&quot;;        String string2 = &quot;acdefg&quot;;        String string3 = &quot;minghuifan&quot;;        trie.insert(string0);        trie.insert(string1);        trie.insert(string2);        trie.insert(string3);        trie.delete(string1);        System.out.println(trie.size());        System.out.println(trie.search(&quot;abc&quot;));    &#125;&#125;





Hash
out f(in)


in -&gt; 无穷
out -&gt; S（一个范围）

MD5：0 ~ 2^64-1
十六进制为16位的字符串，即每个位表示16中状态(00001111 or 0F)

SHA1：0 ~ 2^128-1
十六进制为32位的字符串



相同的in -&gt; 相同的out
说明哈希函数不随机

不同的输入 -&gt; 相同的输出（哈希碰撞）

输入得到的哈希值都均匀且离散的分布在 S 域上

取模



EX1有40亿个无符号整数的文件，无符号整数范围是(0 ~ 2^32^-1)，给 1G 内存返回出现次数最多的整数

2^32^ = 4,294,967,296 约为 43 亿


布隆过滤器
先引入位图

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package Chapter_9;/** * @ Author: MingHuiFan * @ Date: 2021/3/18 - 18:52 * @ Description: Chapter_9 * @ Version: 1.0 */public class BitArr &#123;    // 加入数组中一共有 N 个数，每个数占 4 字节    // 共有 4N Byte = 4N*8 bit    /**     * 改变第 index 位的 0 1     * @param arr     */    static int bitarr(int[] arr, int index) &#123;        int numIndex = index / 32;  // 定位到数组的哪一位        int bitIndex = index % 32;  // 定位在该数的第多少位        int bit = (arr[numIndex] &gt;&gt; bitIndex) &amp; 1;  // 拿到第 index 位的状态        arr[numIndex] = arr[numIndex] | (1 &lt;&lt; bitIndex);    // 将 index 位的数修改为 1//        arr[numIndex] = arr[numIndex] &amp; (~(1 &lt;&lt; bitIndex));   // 将 index 位的数修改为 0        // 总结：取得第 i 位的 0/1 状态 int bit = (arr[i / 32] &gt;&gt; (i % 32)) &amp; 1        return bit;    &#125;    // 打印二进制数    static void test1() &#123;        int[] arr = &#123;1, 2, 3, 4, 5, 6&#125;;        int sum = 0;        for (int i = 0; i &lt; 192; i++) &#123;            System.out.print(bitarr(arr, i));            if (sum++ % 32 == 31) &#123;                System.out.println();            &#125;        &#125;    &#125;    // 一位一位的改变, 下面写法省略了前面 28 个0    // 1 0001   0~31    // 2 0010   32~63    // 3 0011   64~95    // 4 0100   96~127    static void test2() &#123;        int[] arr = &#123;1, 2, 3, 4&#125;;        bitarr(arr, 1);        bitarr(arr, 32);        bitarr(arr, 66);        bitarr(arr, 96);        for (int i : arr) &#123;            System.out.print(i + &quot;_&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        test1();        test2();    &#125;&#125;/** out * 10000000000000000000000000000000 * 01000000000000000000000000000000 * 11000000000000000000000000000000 * 00100000000000000000000000000000 * 10100000000000000000000000000000 * 01100000000000000000000000000000 * 3_3_7_5_ */

题目：
不安全网页的黑名单包含 100亿 个黑名单网页，每个网页的 URL 最多占用 64B。现在想要实现一个网页过滤系统，利用该系统可以根据网页的 URL 判断该网页是否在黑名单上，请设计该系统。
要求：

该系统允许有万分之一以下的判断失误率
使用的额外空间不要超过 30G


这个问题可以使我们认识布隆过滤器器

分析：
如果我们使用 HashSet 来保存每一个 URL，一个 URL 就是 64B，100亿个就是 6400亿B 约为 640G，显然超出要求的额外空间
通过把 URL 保存起来显然是不行的，无法达到题目要求的 30G 以下额外空间
那么就要用到布隆过滤器

通过例子了解实现
上诉我们已经了解了 位图，那么如果我们用位图中的每一个位置来保存一个 URL 需要的内存约为 640/8G 80G，还超过了 30G
但是我们不需要URL个位置，因此还可以将位图进一步缩小至 30G

如何用位图来保存 URL？

每个 URL 通过 k 个哈希函数计算得到一个哈希值然后在模上m（m为位图数位数），当然也可能出现哈希值相同的情况
然后此时每个哈希值对应位图中的每一位，进行描黑（也就是变为1）
然后对每一个 URL 重复上两个操作



然后每个 URL 都通过多个哈希值找到了对应的位置进行描黑处理了

然后查找方式如下，比如查找 URLx 是否在黑名单上

URLx 通过那 k 个哈希函数然后模上m，得到了 k 个位置
然后看这 k 个位置在位图中是否全是黑的状态（即为1状态）


黑URL -&gt; 白   不存在
白URL -&gt; 黑   存在
为什么黑URL不可能报错成白URL：因为同一个 URL 通过相同的哈希函数得到的哈希值是一样的，那么肯定会描黑这些位置的，那么查找的时候这些位置必全为黑
白URL误报成黑URL：如果白URL计算出来的 K个 哈希值刚好是全黑，也就是说当 位图数m 较小、URL数量多且k较多时候可能位图中的每一个位置都描黑了。
那么我们就要降低白报成黑的概率，尽可能减少误报。


那么如何确定 ①k ②m ③url个数 
先确定 m 然后根据样本量和预期失误率来确定 k



n 样本量
p 预期失误率
只需要这两个参数，与单样本大小无关（比如这道题中的一个URL 64B 这个条件无用）



比如这道题中
n = 100亿
p = 0.01%
m = 19.19n = 20n = 2000亿bit = 25G
k = 14
最后计算出真实失误率 p(真) = 0.006%




一致性哈希原理
并查集
通用写法

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package UnionFind;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Stack;/** * @ Author: MingHuiFan * @ Date: 2021/3/19 - 12:17 * @ Description: UnionFind * @ Version: 1.0 */public class UnionFindUniversal&lt;V&gt; &#123;    /*    将 V 类型数据包装成集合形式     */    private static class Element&lt;V&gt; &#123;        V value;        public Element(V value) &#123;            this.value = value;        &#125;    &#125;    // 并查集    public static class UnionFindSet&lt;V&gt; &#123;        HashMap&lt;V, Element&lt;V&gt;&gt; elementHashMap;        HashMap&lt;Element&lt;V&gt;, Element&lt;V&gt;&gt; fatherMap;        HashMap&lt;Element&lt;V&gt;, Integer&gt; sizeMap;        // 遍历元素，将每个元素都包装成一个集合        public UnionFindSet(List&lt;V&gt; list) &#123;            elementHashMap = new HashMap&lt;&gt;();            fatherMap = new HashMap&lt;&gt;();            sizeMap = new HashMap&lt;&gt;();            for (V value : list) &#123;                Element&lt;V&gt; element = new Element&lt;&gt;(value);                elementHashMap.put(value, element);                fatherMap.put(element, element);                sizeMap.put(element, 1);            &#125;        &#125;        // 给一个元素寻找这个元素所在集合的代表元素        public Element&lt;V&gt; findHead(Element&lt;V&gt; element) &#123;            Stack&lt;Element&lt;V&gt;&gt; path = new Stack&lt;&gt;(); // 用于存放元素            while (element != fatherMap.get(element)) &#123; // 如果该元素不属于                path.push(element); // 如果不是代表元素入栈                element = fatherMap.get(element);            &#125;            while (!path.empty()) &#123;                fatherMap.put(path.pop(), element);            &#125;            return element;        &#125;        public boolean isSameSet(V a, V b) &#123;            // 判断ab是否在集合中            if (elementHashMap.containsKey(a) &amp;&amp; elementHashMap.containsKey(b)) &#123;                return findHead(elementHashMap.get(a)) == findHead(elementHashMap.get(b));            &#125;            return false;        &#125;        public void union(V a, V b) &#123;            if (elementHashMap.containsKey(a) &amp;&amp; elementHashMap.containsKey(b)) &#123;                Element&lt;V&gt; aF = findHead(elementHashMap.get(a));                Element&lt;V&gt; bF = findHead(elementHashMap.get(b));                // 判断两个元素是否在同一集合                if (aF != bF) &#123;                    Element&lt;V&gt; maxSet = sizeMap.get(aF) &gt; sizeMap.get(bF) ? aF : bF;                    Element&lt;V&gt; minSet = maxSet == aF ? bF : aF;                    fatherMap.put(minSet, maxSet);  // 将小集合的父亲变为大集合，实现合并操作                    sizeMap.put(maxSet, sizeMap.get(maxSet) + sizeMap.get(minSet));                    sizeMap.remove(minSet);                &#125;            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        list.add(1);        list.add(2);        list.add(3);        list.add(4);        list.add(5);        UnionFindSet&lt;Integer&gt; u1 = new UnionFindSet&lt;&gt;(list);        u1.union(1, 3);        u1.union(1, 4);        System.out.println(u1.isSameSet(3,4));        System.out.println(u1.isSameSet(1,2));        System.out.println(u1.isSameSet(1,3));    &#125;&#125;/* Outtruefalsetrue */

findHead 函数调用的次数越多 平均时间复杂度越接近 O(1)


KMP
先看下暴力方法

123456789101112131415161718public static int force(String text, String pattern)  &#123;    int tlen = text.length();    int plen = pattern.length();    int ti = 0;    int pi = 0;    // 但凡有一个下标越界都退出    while (pi &lt; plen &amp;&amp; ti &lt; tlen) &#123;        if (text.charAt(ti) == pattern.charAt(pi)) &#123;            ti++;            pi++;        &#125; else &#123;            ti -= pi - 1;   // 退回到下一个位置            pi = 0;         // 匹配串回到 0 位置        &#125;    &#125;    // 如果是匹配串越界了一定是匹配成功    return pi == plen ? ti - pi : -1;&#125;
暴力解法就不多说了，文本串一个一个位置滑动

KMP解法为什么快
其实是在暴力解法中文本串中一个一个位置滑动的基础上进行了加速，可以实现跳跃的滑动


先看一个概念
==某一位置前缀和后缀最大匹配长度==
​        即该位置前的前缀和后缀最大匹配长度，但长度并不包括该位置前面的全部
​        如 ababc 
​        c 位置的前缀后缀最大匹配长度为 2 (前缀：ab、后缀：ab)
​        而不是 4（前缀：abab、后缀：abab）,不包括该位置前面全部字符串
​        如果包括的话那么每个字符位置的前缀后缀的最大匹配长度就是前面的长度

例子



位置 0 前面没有信息 —— 0
位置 1 —— 0
位置 2 —— 0
位置 3 —— 0
位置 4 —— 1 （前缀：a、后缀：a）
位置 5 —— 2 （前缀：ab、后缀：ab）
位置 6 —— 3 （前缀：abc、后缀：abc）


然后引入 next 数组
其实就是上面说的 前缀和后缀的最大匹配长度

例子：求法看上面


然后看 KMP 是如何加速的


绿色的为最大前缀和后缀标识，表示 Y 位置前缀后缀的最大匹配长度为 4
当匹配到 XY 位置发现不匹配

按照暴力匹配的话文本串跳到 i + 1 位置，模式串跳到 0 位置，然后开始新的一轮比较

如果是KMP的话，那么直接滑动到如图位置，然后从 X 位置和 j 位置开始比较即可（本质就是 从 i + 5 的位置和 0 位置开始比较）
但是由于后缀和前缀相等，所以 i + 5 —— X 的位置和 0 —— j 的位置必然匹配，所以直接从 X 和 j 位置开始比对所以就加速了整个比对的过程


如果 X 和 j 又不匹配呢如果 next[j] = 3


如果 X 和 j-1 又不匹配呢
重复上述过程
最坏的结果就是滑动到 0 和 X 比较



这里有个问题需要证明：为什么文本串的 i~K 的任何位置都配不出模式串
假设 i~K 中有位置 M 可以匹配出模式串


则 M(X-1) 必然与 0(j+2) 完全匹配 则下图椭圆区域必然完成一致


那么看 next[Y] 是不是就有问题了，next[Y] 本来是 4 但是你又找到了一个比 4 更长的前缀后缀匹配
矛盾，因为 原next[Y] 不可能计算出错。
所以 i~K 位置不可能与匹配串匹配成功。



code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package String;/** * @ Author: MingHuiFan * @ Date: 2021/3/20 - 15:18 * @ Description: String * @ Version: 1.0 */public class KMP &#123;    /*    KMP    O(N)     */    public static int getIndexOf(String text, String pattern) &#123;        if (text.length() &lt; pattern.length() || text.length() &lt; 1) &#123;            return -1;        &#125;        char[] str1 = text.toCharArray();   // 文本串        char[] str2 = pattern.toCharArray();    // 匹配串        int[] next = getNextArray(str2);    // next 数组        int i1 = 0;        int i2 = 0;        while (i1 &lt; str1.length &amp;&amp; i2 &lt; str2.length) &#123;            if (str1[i1] == str2[i2]) &#123; // 如果字符相等两者同时移动到下一个字符                i1++;                i2++;            &#125; else if (next[i2] == -1) &#123;    // str2 中比对的位置已经无法往前跳了                i1++;            &#125; else &#123;                i2 = next[i2];            &#125;        &#125;        // 只要是 i2 越界了，那么一定匹配成功        // 但是 i1 越界不一定匹配失败，因为 i1 i2 可能同时越界        return i2 == str2.length ? i1 - i2 : -1;    &#125;    /*    next 数组    O(M)     */    public static int[] getNextArray(char[] str2) &#123;        if (str2.length == 1) &#123;            return new int[] &#123;-1&#125;;        &#125;        int[] next = new int[str2.length];        next[0] = -1;        next[1] = 0;        int i = 2;        int cn = 0;        while (i &lt; next.length) &#123;            if (str2[i - 1] == str2[cn]) &#123;                next[i++] = ++cn;            &#125; else if (cn &gt; 0) &#123;   // cn 位置和 i - 1 不匹配，继续向前找                cn = next[cn];            &#125; else &#123;                next[i++] = 0;            &#125;        &#125;        return next;    &#125;    public static void main(String[] args) &#123;            &#125;&#125;


</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/03/08/data%20struct%20one/" title="data struct one">data struct one</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-08T08:31:39.000Z" title="发表于 2021-03-08 16:31:39">2021-03-08</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-04T07:30:47.348Z" title="更新于 2021-04-04 15:30:47">2021-04-04</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="content">
快排
补充：荷兰国旗问题



分析


问题一：


用一个变量 left 标记 &lt;= num 的右边界

此时遍历数组 arr 会出现两种情况

arr[i] &lt;= num：
  arr[i] 和小于等于部分右边界下标的后一个数交换，然后 小于等于区域右扩，i++

arr[i] &gt; num：区域不变, i++



直到越界，如下图例子






问题二：和问题一类似


arr[i] &lt; num，arr[i] 和 &lt; 区域下一个交换，**&lt; 区域右阔，i++**
arr[i] = num，i++
arr[i] &gt; num，arr[i] 和 &gt; 区域前一个交换，**&gt; 区域左扩，i++**



归并排序
时间复杂度：O(N*logN)
空间复杂度：O(N)

Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package Sort;import java.util.Random;/** * @ Author: MingHuiFan * @ Date: 2021/3/8 - 15:05 * @ Description: Sort * @ Version: 1.0 *//** * 时间复杂度分析 *  T(N) = a * T(N/b) + O(N^d) *  T(N) = 2 * T(N/2) + O(N) *  log(a,b) == d   -&gt;  O(N) = O(N*logN) * 空间复杂度：O(N) */public class MergeSort &#123;    // 注意 R 是数组最后一个下标，不是下标加一    public static void process(int[] arr, int L, int R) &#123;        if (L == R) &#123;            return;        &#125;        int mid = L + ((R - L) &gt;&gt; 2);        process(arr, L, mid);   // 左边排序        process(arr, mid + 1, R);   // 右边排序        merge(arr, L, mid, R);  // 整合        return;    &#125;    // 注意这里 R 是数组最后一个下标，不是下标加一    public static void merge(int[] arr, int L, int M, int R) &#123;        int[] help = new int[R - L + 1];        int i = 0;        int left = L;        int right = M + 1;        while (left &lt;= M &amp;&amp; right &lt;= R) &#123;            help[i++] = arr[left] &lt;= arr[right] ? arr[left++] : arr[right++];        &#125;        while (left &lt;= M) &#123;            help[i++] = arr[left++];        &#125;        while (right &lt;= R) &#123;            help[i++] = arr[right++];        &#125;        for (i = 0; i &lt; help.length; i++) &#123;            arr[L + i] = help[i];        &#125;        return;    &#125;    public static void main(String[] args) &#123;        int[] arr = new int[new Random().nextInt(51) + 50]; // 数组大小区间 [50, 100]        for (int i = 0; i &lt;arr.length; i++) &#123;            arr[i] = new Random().nextInt(100) + 100;        &#125;        for (int i = 0; i &lt; arr.length; i++) &#123;            System.out.print(arr[i] + &quot;_&quot;);        &#125;        System.out.println(arr.length);        process(arr, 0, arr.length - 1);        for (int i = 0; i &lt; arr.length; i++) &#123;            System.out.print(arr[i] + &quot;_&quot;);        &#125;    &#125;&#125;


拓展
小和问题-code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package Sort.Merge;import tools.Asserts;import tools.Times;import java.util.Arrays;import java.util.Random;/** * @ Author: MingHuiFan * @ Date: 2021/3/8 - 18:16 * @ Description: Sort.Merge * @ Version: 1.0 */// 小和问题public class SmallSum &#123;    // 小和问题求解函数    public static int smallSum(int[] arr) &#123;        if (arr == null || arr.length &lt; 2) &#123;            return 0;        &#125;        return mergeSort(arr, 0, arr.length - 1);    &#125;    // 递归过程    public static int mergeSort(int[] arr, int l, int r) &#123;        if (l == r) &#123;            return 0;        &#125;        int mid = l + ((r - l) &gt;&gt; 2);        int left = mergeSort(arr, l, mid);  // 左边小和        int right = mergeSort(arr, mid + 1, r); // 右边小和        int sum = merge(arr, l, mid, r);    // 左右合并求小和        return left + right + sum;    &#125;    // 左右两边排序并返回此次左右两边的小和    public static int merge(int[] arr, int l, int m, int r) &#123;        int[] help = new int[r - l + 1];    // 辅助数组        int left = l;        int right = m + 1;        int i = 0;        int res = 0;        // 如果左边不越界并且右边不越界        while (left &lt;= m &amp;&amp; right &lt;= r) &#123;            res += arr[left] &lt; arr[right] ? arr[left] * (r - right + 1) : 0;            help[i++] = arr[left] &lt; arr[right] ? arr[left++] : arr[right++];        &#125;        // 下面两个 while 循环只会进入其一        while (left &lt;= m) &#123;            help[i++] = arr[left++];        &#125;        while (right &lt;= r) &#123;            help[i++] = arr[right++];        &#125;        for (i = 0; i &lt; help.length; i++) &#123;            arr[l + i] = help[i];        &#125;        return res;    &#125;    // 暴力求解小和    public static int force(int[] arr) &#123;        int res = 0;        for (int i = 0; i &lt; arr.length - 1; i++) &#123;            for (int j = i + 1; j &lt; arr.length; j++) &#123;                if (arr[i] &lt; arr[j]) &#123;                    res += arr[i];                &#125;            &#125;        &#125;        return res;    &#125;    public static void main(String[] args) &#123;        int testSum = 100000;   // 测试的次数        // Times测试时间工具        Times.test(&quot;小和计算&quot;, () -&gt; &#123;            for (int test = 0; test &lt; testSum; test++) &#123;                int sum = 100;  // 数组的大小                int[] arr0 = new int[sum];                for (int i = 0; i &lt; arr0.length; i++) &#123;                    arr0[i] = new Random().nextInt(500);                &#125;                int[] arr1 = Arrays.copyOf(arr0, arr0.length);                Asserts.test(force(arr0) == smallSum(arr1));//                System.out.println(Arrays.toString(arr0));//                System.out.println(Arrays.toString(arr1));//                System.out.println(&quot;递归求小和：&quot; + smallSum(arr0));//                System.out.println(&quot;暴力求小和：&quot; + force(arr1));            &#125;        &#125;);    &#125;&#125;


逆序对数量-code
和上面求小和问题是差不多的，这是下面的微小区别



123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package Sort.Merge;import tools.Asserts;import tools.Times;import java.util.Arrays;import java.util.Random;/** * @ Author: MingHuiFan * @ Date: 2021/3/9 - 12:30 * @ Description: Sort.Merge * @ Version: 1.0 */// 逆序对数量public class Reverse &#123;    public static int reverse(int[] arr) &#123;        if (arr == null || arr.length &lt; 2) &#123;            return 0;        &#125;        return mergeSort(arr, 0, arr.length - 1);    &#125;    public static int mergeSort(int[] arr, int l, int r) &#123;        if (l == r) &#123;            return 0;        &#125;        int mid = l + ((r - l) &gt;&gt; 2);        int L = mergeSort(arr, l, mid);        int R = mergeSort(arr, mid + 1, r);        int sum = merge(arr, l, mid, r);        return L + R + sum;    &#125;    public static int merge(int[] arr, int l, int m, int r) &#123;        int[] help = new int[r - l + 1];        int ans = 0;        int left = l;        int right = m + 1;        int i = 0;        while (left &lt;= m &amp;&amp; right &lt;= r) &#123;            ans += arr[left] &gt; arr[right] ? r - right + 1 : 0;            // 大-&gt;小排序 并且 相等要先移右边            help[i++] = arr[left] &gt; arr[right] ? arr[left++] : arr[right++];        &#125;        // 把未排好的排好        while (left &lt;= m) &#123;            help[i++] = arr[left++];        &#125;        while (right &lt;= r) &#123;            help[i++] = arr[right++];        &#125;        for (i = 0; i &lt; help.length; i++) &#123;            arr[l + i] = help[i];        &#125;        return ans;    &#125;    // 暴力求解    public static int force(int[] arr) &#123;        int ans = 0;        for (int i = 0; i &lt; arr.length - 1; i++) &#123;            for (int j = i + 1; j &lt; arr.length; j++) &#123;                if (arr[i] &gt; arr[j]) &#123;                    ans++;                &#125;            &#125;        &#125;        return ans;    &#125;    public static void main(String[] args) &#123;        int testSum = 10000000;        Times.test(&quot;逆序数&quot;, () -&gt; &#123;            for (int test = 0; test &lt; testSum; test++) &#123;                int sum = 5;                int[] arr0 = new int[sum];                for (int i = 0; i &lt; sum; i++) &#123;                    arr0[i] = new Random().nextInt(51) + 50;                &#125;                int[] arr1 = Arrays.copyOf(arr0, arr0.length);                Asserts.test(reverse(arr0) == force(arr1));//                System.out.println(Arrays.toString(arr0));//                System.out.println(Arrays.toString(arr1));//                System.out.print(force(arr0) + &quot;_&quot; + reverse(arr1) + &#x27;\n&#x27;);            &#125;        &#125;);    &#125;&#125;
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/03/04/Linux-notes/" title="Linux_notes">Linux_notes</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-04T13:51:41.000Z" title="发表于 2021-03-04 21:51:41">2021-03-04</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-15T13:35:58.203Z" title="更新于 2021-12-15 21:35:58">2021-12-15</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E8%AE%B0%E5%BD%95/">记录</a></span></div><div class="content">
有趣
火车路过
12$ yum install sl$ sl
动物图案
123$ yum install cowsay$ cowsay$ cowsay -f tux &quot;这是Linux&quot;
2048游戏
12$ wget https://raw.githubusercontent.com/mevdschee/2048.c/master/2048.c # gcc编译即可
贪吃蛇变式
1$ ssh sshtron.zachlatta.com
文字显示
12$ yum install figlet$sudo apt-get install toilet$ figlet 文字
宠物猫
12$ yum install oneko $ oneko
在屏幕上出现一双眼睛，盯着你的鼠标指针
12$ yum install xeyes$ xeyes
不断输出文字
1$ yes Helloween # 这样就会不断输出&quot;Helloween&quot;
factor 分解因数


幽灵打字
12$ yum install pv$ echo &quot;hello world&quot; | pv -qL 10







韩顺平教育






Linux运维工程师：服务器规划、调试优化、市场键控、故障处理、数据备份恢复、日志分析……

Linux嵌入式工程师：linux下驱动开发、嵌入式系统程序开发（C/C++）

Linux应用领域：

服务器：C/C++、pup、java、python、go
嵌入式：机顶盒、数字电视、网络电话、程控交换机、手机、PDA、智能家居、物联网……



基础篇Linux主要发行版：Ubuntu、Redhat、CentOS、Debain(蝶变)、Fedora、SuSE、OpenSUSE(示意图)



VM及安装 CentOS
几个注意点


选择安装位置：分三个区：boot、swap、根分区





网络的三种模式
虚拟机克隆
直接将装好的系统文件夹拷贝即可，然后VM中打开这个文件即可
 

用VM的克隆：克隆时候需要把需要克隆的系统关闭
 其实就是拷贝，克隆的文件可以直接在其他电脑上使用


虚拟机快照
虚拟机迁移和删除
迁移：直接剪切
删除：VM删除、直接删除文件

install vmtoolsRoot用户下安装
用于管理母机和本机的共享文件夹
但是在实际开发中，文件的上传和下载是要使用远程方式完成的




然后终端进去 opt 目录解压这个文件

解压
  

安装：一路回车
  



Linux目录结构







实操篇远程登录Linux

XShell
下载安装后查看 Linux 的 ip
然后 XShell 链接


新建
  

这里填写 Linux 系统的用户名或者Root




填写对应用户的密码
  



XFTP
新建
  

同样用户名和密码
  


Vim


关机重启命令123456shutdown -h now		// 立刻关机shutdown -h 1		// 一分钟后关机shutdown 			// 和上面一行默认是1分钟关机halt 				// 关机reboot				// 重启sync				// 将内存数据同步到磁盘中

用户登录和注销
用户管理
Linux 系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统


创建用户1useradd	用户名		// 添加用户
这样会自动创建一个和用户名同名的家目录，存放在 
/home/用户名

如果想指定家目录的位置则如下例子

12useradd -d /home/test 用户名# 表示用户名的家目录存在放在 /home/test/ 下


设置用户密码1passwd 用户名
注意：如果不写用户名是在当前登录账户更改密码，也就是当前的 root 账户

pwd    // 显示当前绝对路径

删除用户：两种
删除用户，但是保留该用户的家目录
 1userdel 用户名
删除用户以及家目录
 1userdel -r 用户名





查询用户信息1id 用户名


切换用户1su - 用户名

查看当前登录用户信息12who am iwhoami

即使切换了用户，查看也是显示最先登录的用户信息
用户组
系统可以对有共性/权限的多个用户进行统一的管理


新增组：
 1groupadd 组名
删除组
 1groupdel 组名
增加用户的时候直接加上组
 123useradd -g 用户组 用户名如新增一个用户 zwj 并制定到 wudang 组里面去useradd -g wudang zwj
修改用户的组
 1234usermod -g 要放入的组 用户名如将 wudang组的 zwj 修改到 mojiao组里面去step1: groupadd mojiaostep2: usermod -g mojiao zwj




用户和组相关文件

passwd文件：
 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell
 
 Shell解释：
 

shadow文件：
 
 给 king 设置密码在打开看下：此时有了加密口令
 

group文件
 创建用户的时候如果没有之指定组的情况下，会创建一个和用户名相同的组
 



1.如果组里面由用户则不能删除该组

实用指令运行级别

EX：从运行级别 5 到 3（无图形界面）
远程登录也可以切换运行级别




即：

查看运行级别：
  1systemctl get-default
  

改变运行级别
  1systemctl set-default 运行级别
  



重启之后



接下来的每次重启都是进去 运行级别3


注：如果切到无图形化界面（运行级别3）登入不进去root，别使用数字小键盘输入密码（没解锁）

找回 Root 密码

在启动界面按 “e”
 

找到这一行，后面加上 
 1init=/bin/sh
 

然后 Ctrl + X 进入 单用户模式
 

然后在光标闪烁的位置输入下面命令，然后回车
 1mount -o remount,rw /
 

然后输入下面命令
 1passwd
 然后回车输入密码，然后回车后在此输入密码即可
 显示 passwd…..的样式表示密码修改成功
 

然后，在光标闪烁的位置输入下面命令并回车
 1touch /.autorelabel
 

接着在光标闪烁的位置输入下面命令并回车，等待系统自动修改密码，时间可能有点长，完成后，系统会自动重启，新的密码生效
 1exec /sbin/init
 



远程是无法修改 ROOT 密码的

帮助指令
man
 

help
 


文件目录类
pwd 指令
 12# pwdpwd		// 	绝对路径

ls 指令
 12345# lsls		// 显示文件ls -a	// 显示文件包括隐藏文件ls -l	// 列表显示ls -al	// 列表显示包括隐藏文件

cd 指令
 123456# cd# 基本语法# cd 参数cd ~	// 回到当前用户的家目录cd ..	// 回到上一级目录cd /	// 回到根目录
 
 

mkdir 指令
 123456# mkdir# 基本语法：mkdir [选项] 要创建的目录# 创建一个目录mkdir /home/dog		// 在home目录下创建dog目录此时要求home目录存在，不存在创建不成功# 创建多级目录mkdir -p /homg/animal/tiger	 // 此时animal不存在也可以创建

rmdir 指令
 123456# rmdir # 基本语法：rmdir [选项] 要删除的目录# 删除一个空目录rmdir /home/dog# 删除一个非空目录rm -rf /home/animal	// -r递归删除 -f强制删除不提示

touch 指令
 12# touch# 基本语法：touch 文件名称


cp 指令
 12345# cp# 基本语法：cp [选项] source dest# 常用选项：		-r 	递归复制整个文件夹 cp 待拷贝文件或目录 目标目录
 
 

rm 指令
 12345# rm# 基本语法：rm [选项] 要删除的文件或目录# 常用选项# 	-r : 递归删除整个文件夹#		-f : 强制删除不提示
 

mv 指令
 1234# mv # 基本语法：# 	- 重命名：mv oldNameFile newNameFile# 	- 移动文件：mv 需要移动的文件 新目录
 

cat 指令
1234# cat# 基本语法：cat [选项] 要查看的文件# 常用选项： 	-n : 显示行号


more指令


less 指令


echo 指令


head 指令：默认显示文章前 10 行内容


tail 指令（可用于查看日志）：默认显示文章尾部 10 行内容


输出重定向 &gt; 、追加 &gt;&gt; 




ln 指令：类似 win 下的快捷方式




history 指令








时间日期类
date 指令
 
 

cal 指令
 


搜索查找类
find 指令


locate 指令

先执行    updatedb




which 指令




grep 指令
 


压缩解压类
gzip、gunzip 指令：用于解压缩文件



zip、unzip 指令：可压缩文件和目录
1234567# 小结# 不指定路径写法,压缩的和解压的文件都保存在当前用户所在的目录zip -r 要压缩的目录unzip 要解压的xxx.zip# 指定路径写法zip -r 指定目录/xxx.zip 要压缩的目录unzip -d 要解压到的目录 要解压的xxx.zip
123456# 如果要压缩 /home/TEST 目录下的东西，不包含home# 下面这样写的话会把home也压缩进去，包含了homezip -r 存放的目录/xxx.zip /home/TEST# 正确做法# 先进去到/home目录下，下面这样压缩就不会把home也压进去zip -r 存放的目录/xxx.zip TEST




当一个文件夹里面有文件的时候，压缩的时候要使用 zip -r xxx.zip 要压缩的文件夹
不使用 -r 就会只是压缩一个目录，里面的东西进不去



tar 指令



组管理和权限管理组
每一个用户必须属于一个组，不能独立于组外
每一个文件有三个概念
所有者：一般是创建者
所在组：这个文件属于哪一个组，那么这个组里面的用户就对这个文件拥有一定的权限
其他组：不包含该文件的组称为其他组，其他组也对该文件有一定的权限




文件/目录 所有者
查看文件的所有者


修改文件所有者
1chown 用户名 文件



组的创建
文件/目录 所在组
查看文件/目录所在的组：

12ls -ahlll

修改文件所在组：

1chgrp 组名 文件名

EX：修改文件所在组，目录同理


先创建一个组 game
然后使用 root 用户创建文件 SuperMary.txt
查看这个文件属于哪个组 -&gt; root
chgrp game SuperMary.txt


其他组除文件的所有者和所在组的用户外，系统的其他用户都是文件的其它组
改变用户所在组
查看用户所在组

1id 用户名


查看组

123cat /etc/group# 查看是否有mojiao这个组cat /etc/group | grep mojiao
没有组则没有输出


改变用户所在组

1234usermod -g 新组名 用户名# 改变该用户登录的初始目录。# 说明：用户需要有进入到新目录的权限usermod -d 目录名 用户名


权限的基本介绍123ls -lls -lahll

一共十位 
123# 分为四段l    rwx    rwx    rwx类型  所有者  所属组  其他组用户

各位数表示的意义


第 0 位：确定文件类型

l 是链接

d 是目录

c 是 字符设备 文件，如键盘、鼠标

b 是块设备，如硬盘




第 1~3 位确定所有者（该文件的所有者）拥有该文件的权限。—User

第 4~6 位确定所属组（同用户组的）拥有该文件的权限。—Group

第 7~9 位确定其他用户拥有该文件的权限。—Other



各字母表示的意义


r w x 作用到文件
[ r ] : 表示可读
[ w ] : 代表可写，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件的目录有写权限，才能删除该文件
[ x ] : 代表可执行，可以被执行


r w x 作用到目录
[ r ] : 表示可读
[ w ] : 代表可写，可以修改，对目录内 创建 + 删除 + 重命名目录
[ x ] : 代表可执行，可以进入该目录



修改权限
chmod u=rwx,g=rwx,o=x 文件名或目录名
chmod u+w 文件名/目录名
chmod a-w 文件名/目录名
1234567891011   - u：所有者   - g：所有组   - o：其他人   - a：所有人（u，g，o 的总和）2. 通过数字变更权限   &#96;&#96;&#96;shell   chmod 751 文件名&#x2F;目录名   # 上面一句表示将 所有者权限设置为 rwx，所在组设置为 rx，其他组设置为 x
12345678910r=4 w=2	x=1	000 —— 其实就是二进制rwx=7rw =6r x=5r  =4 wx=3 w =2  x=1





修改文件/目录所有者12345chown newowner 文件/目录 #改变所有者chown newowner:newgroup 文件/目录 #改变所有者和所在组# -R 如果是目录，则使其下所有子文件或目录递归生效chown -R newowner 文件/目录 #递归改变所有者chown -R newowner:newgroup 文件/目录 #递归改变所有者和所在组


修改文件/目录所在组12chgrp newgroup 文件/目录 #改变所在组 chgrp -R newgroup 文件/目录 #改变所在组 




定时任务调度crontab 任务调度
crontab 进行 定时任务的设置介绍


概述

任务调度：是指系统在某个时间执行的特定的命令或程序
任务调度分类：
系统工作：有些重要的工作必须周而复始的执行，如病毒扫描
个别用户工作：个别用户希望执行某些特定程序，比如对MySQL数据库的备份




基本语法：
123456crontab [选项]# 常用选项    -e #编辑crontab定时任务    -l #查询crontab任务    -r #删除当前用户所有的crontab任务service crond restart #重启任务调度






使用方法

直接用 crontab -e 编辑crontab定时任务,写执行的语句



先写 shell 脚本，然后在 crontab -e 编辑crontab定时任务
（假如我所在路径是 /home）
123456vim my.sh	# date &gt;&gt; /home/mycal	# cal &gt;&gt; /home/mycalchmod u+x my.shcrontab -e	# */1 * * * * /home/my.sh






at 定时任务
概述

at 命令是一次性定时计划任务，at 的守护进程 atd 会以后台模式运行，检查作业队列来运行

默认情况下，atd 进程每 60s 检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业

at 命令是一次性定时计划 任务，执行完一个任务后不再执行任务了

在使用 at 命令的时候，一定要保证 atd 进程的启动，可以使用相关指令查看
1ps -ef | grep atd




at 命令格式
12at [选项] [时间]ctrl + D #结束 at 命令的输入，按两次


应用


rpm
介绍
rpm 用于互联网下载包的打包及安装工具，它包含在某些 Linux 分发版中。它生成具有 .RPM 拓展名的文件。RPM 是 RedHat Package Manager（RedHat 软件包管理工具）的缩写，类似 Windows 下的 setup.exe。

查询指令
123456789101112rpm -qa #查询所安装的所有 rpm 软件包rpm -qa | morerpm -qa | grep X #如 rpm -qa | grep nginxrpm -q 软件包名 # 查询软件包是否安装rpm -qi 软件包名 # 查询软件包信息rpm -ql 软件包名 # 查询软件包中的文件rpm -qf 文件全路径名 # 查询文件所属的软件包	# rpm -qf /etc/passwd	# rpm -qf /root/install.log
卸载 rpm 包
123rpm -e RPM包的名称	# rpm -e nginx 表示删除 nginx 软件包rpm -e --nodeps RPM包的名称


安装 rpm 包
1234rpm -ivh RPM包全路径名称	# i = install 安装	# v = verbose 提示	# h = hash 	  进度条




yum
介绍
yum 是一个 shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务期自动下载 RPM 包并且安装，可以自动处理依赖关系，并且一次性安装所有依赖的软件包

基本指令
查询 yum 服务器是否有需要安装的软件
1yum list | grep XX软件列表
安装指定 yum 包
1yum install XXX






Linux分区分区


这里截取我虚拟机磁盘分区和服务器分区情况
虚拟机：分了三个区（根分区、boot分区、SWAP分区）
服务器：默认只有一个根分区
UUID：分区的唯一标识符（40bit）
MOUNTPOINT：挂载点



增加一块硬盘
虚拟机添加硬盘
​    

分区

格式化

挂载

设置可以自动挂载


磁盘情况
查询整个情况
1df -h


查询指定目录的磁盘占用情况
1234567du -h /目录	# 默认为当前目录	# -s 指定目录占用大小汇总	# -h 带计量单位	# -a 含文件	# --max-depth=1 子目录深度	# -c 列出明细的同时，增加汇总值




工作实用指令
统计 /etc/ 目录下文件个数
1234ls -l /etc/ | grep &quot;^-&quot; | wc -l# 直接列出来ls -l /etc/ | grep &quot;^-&quot; 
统计 /etc/ 目录下目录的个数
1234ls -l /etc/ | grep &quot;^d&quot; | wc -l#直接列出来ls -l /etc/ | grep &quot;^d&quot;
统计 /etc/ 目录下文件个数，包括子文件夹里的文件
1234ls -lR /etc/ | grep &quot;^-&quot; | wc -l# 直接列出来ls -lR /etc/ | grep &quot;^-&quot; 
统计 /etc/ 目录下目录的个数，包括子文件夹里的目录
1234ls -lR /etc/ | grep &quot;^d&quot; | wc -l#直接列出来ls -lR /etc/ | grep &quot;^d&quot;
以树状显示目录结构
123# 如没安装，先安装yum install treetree /etc/






网络配置定制篇</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/02/28/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E8%AF%BE%E7%A8%8B%E6%8E%A8%E8%8D%90-%E8%AE%A1%E7%A7%91/" title="大二下资料推荐-仅个人推荐">大二下资料推荐-仅个人推荐</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-28T12:30:33.000Z" title="发表于 2021-02-28 20:30:33">2021-02-28</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-04T07:28:42.919Z" title="更新于 2021-04-04 15:28:42">2021-04-04</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E4%B8%AA%E4%BA%BA/">个人</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E4%B8%AA%E4%BA%BA/">个人</a></span></div><div class="content">
仅仅个人推荐，具体看个人风格喜好
更新中……..


概率论与数理统计宋浩：链接点我
小元老师：链接点我
张宇：链接点我
汤家凤：
B站找不到了，百度网盘(/手动滑稽)


基础：

​    链接：https://pan.baidu.com/s/16N6dx9X3jiKVyieJ5j8G1g​    提取码：1502 

强化

​    链接：https://pan.baidu.com/s/1iuARPXy7AzHdrVROBg2bjQ​    提取码：1502 
链接点我

操作系统链接点我
链接点我
链接点我
链接点我

算法设计与分析
这个课内容连接性没那么强，可以单独搜课看，如动态规划DP、分治、贪心等都可以单独搜到

链接点我
这个课算法有点全，可以挑书上的内容看：链接点我
左神（左程云）的课比较进阶：链接点我

计算机组成原理
暂时还没

</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">xiaofan</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/755400668"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/755400668" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:755400668@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到灰灰爱吃小云朵的博客,功能还在完善中！</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/12/25/%E5%AE%9E%E9%AA%8C%E5%85%AD%EF%BC%9ABurpSuite%E6%8D%95%E8%8E%B7%E5%B9%B6%E4%BF%AE%E6%94%B9HTTP%E6%8A%A5%E6%96%87/" title="实验六：BurpSuite 捕获并修改 HTTP 报文">实验六：BurpSuite 捕获并修改 HTTP 报文</a><time datetime="2021-12-25T11:59:33.000Z" title="发表于 2021-12-25 19:59:33">2021-12-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/12/19/CentOS7%20%E5%AE%89%E8%A3%85%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6/" title="CentOS7 安装组件">CentOS7 安装组件</a><time datetime="2021-12-19T07:51:41.000Z" title="发表于 2021-12-19 15:51:41">2021-12-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/12/15/CentOS7%E6%90%AD%E5%BB%BAFTP%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="CentOS7搭建FTP服务器">CentOS7搭建FTP服务器</a><time datetime="2021-12-15T13:51:41.000Z" title="发表于 2021-12-15 21:51:41">2021-12-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/12/08/%E5%AE%9E%E9%AA%8C%E4%BA%94%EF%BC%9AWireshark%E6%8A%93%E5%8C%85/" title="实验五：Wireshark 抓包分析">实验五：Wireshark 抓包分析</a><time datetime="2021-12-08T07:59:33.000Z" title="发表于 2021-12-08 15:59:33">2021-12-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/12/01/SQL20%E9%A2%98/" title="SQL20题">SQL20题</a><time datetime="2021-12-01T02:32:33.000Z" title="发表于 2021-12-01 10:32:33">2021-12-01</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item parent"><a class="card-category-list-link" href="/categories/C/"><span class="card-category-list-name">C</span><span class="card-category-list-count">1</span><i class="fas fa-caret-left "></i></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C/C/"><span class="card-category-list-name">C++</span><span class="card-category-list-count">1</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C/"><span class="card-category-list-name">C++</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Linux/"><span class="card-category-list-name">Linux</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Windows/"><span class="card-category-list-name">Windows</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/javaSE/"><span class="card-category-list-name">javaSE</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/tools/"><span class="card-category-list-name">tools</span><span class="card-category-list-count">3</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/wxy/"><span class="card-category-list-name">wxy</span><span class="card-category-list-count">1</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/CSS/" style="font-size: 1.15em; color: rgb(19, 153, 30)">-CSS</a><a href="/tags/Linux/" style="font-size: 1.38em; color: rgb(62, 153, 141)">Linux</a><a href="/tags/%E8%AE%B0%E5%BD%95/" style="font-size: 1.45em; color: rgb(41, 107, 134)">记录</a><a href="/tags/Linux/" style="font-size: 1.15em; color: rgb(187, 77, 22)">-Linux</a><a href="/tags/Windows/" style="font-size: 1.3em; color: rgb(156, 99, 54)">-Windows</a><a href="/tags/Git/" style="font-size: 1.15em; color: rgb(59, 120, 193)">Git</a><a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 1.15em; color: rgb(198, 98, 92)">服务器</a><a href="/tags/HTML/" style="font-size: 1.15em; color: rgb(86, 166, 112)">-HTML</a><a href="/tags/Maven/" style="font-size: 1.15em; color: rgb(18, 39, 164)">Maven</a><a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 1.15em; color: rgb(173, 146, 8)">软件</a><a href="/tags/C/" style="font-size: 1.3em; color: rgb(191, 5, 15)">C++</a><a href="/tags/tree-java/" style="font-size: 1.15em; color: rgb(96, 17, 192)">tree - java</a><a href="/tags/wxy/" style="font-size: 1.15em; color: rgb(173, 32, 193)">wxy</a><a href="/tags/%E5%A3%81%E7%BA%B8/" style="font-size: 1.15em; color: rgb(127, 135, 85)">壁纸</a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.3em; color: rgb(156, 85, 17)">算法</a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.3em; color: rgb(25, 60, 46)">数据结构</a><a href="/tags/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.22em; color: rgb(129, 18, 12)">C++ - 数据结构</a><a href="/tags/vim/" style="font-size: 1.15em; color: rgb(116, 31, 168)">vim</a><a href="/tags/vlan/" style="font-size: 1.15em; color: rgb(198, 51, 170)">vlan</a><a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 1.15em; color: rgb(120, 167, 105)">汇编</a><a href="/tags/%E5%BA%95%E5%B1%82/" style="font-size: 1.22em; color: rgb(162, 8, 71)">底层</a><a href="/tags/%E4%B8%AA%E4%BA%BA/" style="font-size: 1.15em; color: rgb(49, 64, 139)">个人</a><a href="/tags/route/" style="font-size: 1.22em; color: rgb(179, 146, 161)">route</a><a href="/tags/Burp-Suite/" style="font-size: 1.15em; color: rgb(3, 80, 192)">Burp Suite</a><a href="/tags/java/" style="font-size: 1.3em; color: rgb(185, 175, 66)">java</a><a href="/tags/%E6%96%87%E4%BB%B6/" style="font-size: 1.15em; color: rgb(84, 178, 15)">文件</a><a href="/tags/%E9%80%9A%E4%BF%A1/" style="font-size: 1.15em; color: rgb(142, 101, 75)">通信</a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 1.15em; color: rgb(144, 70, 163)">博客</a><a href="/tags/MySQL/" style="font-size: 1.22em; color: rgb(39, 87, 95)">MySQL</a><a href="/tags/Wireshark/" style="font-size: 1.15em; color: rgb(65, 113, 76)">Wireshark</a><a href="/tags/%E4%B9%A6%E7%B1%8D/" style="font-size: 1.15em; color: rgb(35, 4, 42)">书籍</a><a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 1.15em; color: rgb(65, 27, 75)">链表</a><a href="/tags/LeetCode/" style="font-size: 1.15em; color: rgb(118, 67, 108)">LeetCode</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/12/"><span class="card-archive-list-date">十二月 2021</span><span class="card-archive-list-count">5</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/11/"><span class="card-archive-list-date">十一月 2021</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/10/"><span class="card-archive-list-date">十月 2021</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/09/"><span class="card-archive-list-date">九月 2021</span><span class="card-archive-list-count">3</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/08/"><span class="card-archive-list-date">八月 2021</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/07/"><span class="card-archive-list-date">七月 2021</span><span class="card-archive-list-count">7</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/06/"><span class="card-archive-list-date">六月 2021</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/05/"><span class="card-archive-list-date">五月 2021</span><span class="card-archive-list-count">2</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">43</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2021-02-17T16:00:00.000Z"></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">65.5k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2021-12-26T06:40:04.255Z"></div></div></div></div><div class="card-widget"><div class="item-headline"><i></i><span>访客</span></div><div class="item-content"><script type="text/javascript" id="clstr_globe" src="//clustrmaps.com/globe.js?d=Ti7plTQaKk8zjpyoUXfK29uCDrIzNldAuvoLvSLy1bU"></script></div></div></div></div></main><footer id="footer" style="background: flse"><div id="footer-wrap"><div class="copyright">&copy;2021  <i id="heartbeat" class="fa fas fa-heartbeat"></i> xiaofan</div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn"><span>湘ICP备2021007749号</span></a><div id="running-time"></div><script>setInterval(()=>{let create_time=Math.round(new Date(Date.UTC(2021,01,18,0,0,0)).getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600;}if(second>=24*3600){time[1]=parseInt(second/(24*3600));second%=24*3600;}if(second>=3600){time[2]=parseInt(second/3600);second%=3600;}if(second>=60){time[3]=parseInt(second/60);second%=60;}if(second>0){time[4]=second;}currentTimeHtml='本站已安全运行 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';document.getElementById("running-time").innerHTML=currentTimeHtml;},1000);
</script></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function subtitleType () {
  getScript('https://sdk.jinrishici.com/v2/browser/jinrishici.js').then(() => {
    jinrishici.load(function (result) {
      if (true) {
        var sub = "".length == 0 ? new Array() : "".split(',')
        var content = result.data.content
        var both = sub.unshift(content)
        var typed = new Typed('#subtitle', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('subtitle').innerHTML = result.data.content
      }
    })
  })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'dark',
      })
      true && mermaid.init()
    })
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>'use strict';'serviceWorker'in navigator&&navigator.serviceWorker.register('service-worker.js').then(function(a){a.onupdatefound=function(){var b=a.installing;b.onstatechange=function(){switch(b.state){case'installed':navigator.serviceWorker.controller?console.log('New or updated content is available.'):console.log('Content is now available offline!');break;case'redundant':console.error('The installing service worker became redundant.');}}}}).catch(function(a){console.error('Error during service worker registration:',a)});
</script></body></html>