<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>灰灰爱吃小云朵 - 云层小卖铺</title><meta name="author" content="xiaofan"><meta name="copyright" content="xiaofan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta property="og:type" content="website">
<meta property="og:title" content="灰灰爱吃小云朵">
<meta property="og:url" content="http://755400668.github.io/index.html">
<meta property="og:site_name" content="灰灰爱吃小云朵">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://755400668.github.io/img/%E5%A4%B4%E5%83%8F.gif">
<meta property="article:author" content="xiaofan">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://755400668.github.io/img/%E5%A4%B4%E5%83%8F.gif"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://755400668.github.io/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":500,"languages":{"author":"作者: xiaofan","link":"链接: ","source":"来源: 灰灰爱吃小云朵","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#ffc0cb","bgDark":"#121212","position":"bottom-left"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: false,
  isHome: true,
  isHighlightShrink: true,
  isToc: false,
  postUpdate: '2021-05-10 13:49:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    })(window)</script><link rel="stylesheet" href="/css/mycss/background.css"><link rel="stylesheet" href="/css/mycss/footer.css"><link rel="stylesheet" href="/css/mycss/scroll_bar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/sviptzk/HexoStaticFile@latest/Hexo/css/hideCategory.min.css"><link rel="stylesheet" href="/css/mycss/read.css"><link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.gif" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('https://gitee.com/MingHuifan/image/raw/master/20210221190644.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">灰灰爱吃小云朵</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">灰灰爱吃小云朵</h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://github.com/755400668" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:755400668@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/05/01/MySQL/" title="MySQL基础">MySQL基础</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-01T02:32:33.000Z" title="发表于 2021-05-01 10:32:33">2021-05-01</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-03T02:45:11.791Z" title="更新于 2021-05-03 10:45:11">2021-05-03</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/MySQL/">MySQL</a></span></div><div class="content">
MySQL安装
如果安装过程中，出错了或者想重新再装
sc delete mysql （删除已经安装好的MySQL服务，慎重）


下面用MySQL-5.7.34 例子，注意：exe 文件和 zip 安装不一样


下载 mysql
1https://dev.mysql.com/downloads/mysql/5.7.html


解压后添加环境变量



添加 my.ini 文件
123456789101112[client]port=3306default-character-set=utf8[mysqld]# 设置自己为自己的 mysql 安装目录basedir=D:\Program Files\RELY\mysql-5.7.34-winx64\# 设置为 mysql 的数据目录，这个目录是系统创建，不用认为创建datadir=D:\Program Files\RELY\mysql-5.7.34-winx64\data\port=3306character_set_server=utf8# 跳过安全检查skip-grant-tables


用管理员权限打开 cmd，进入到 mysql 的 bin 目录下
1mysqld -install


初始化数据库
1mysqld --initialize-insecure --user=mysql




启动 mysql 服务
1net start mysql


停止 mysql 服务：net stop mysql


进入 mysql 管理终端
12# 表示当前 root 用户密码为空mysql -u root -p


修改 root 用户密码
1234567use mysql;# 下面语句就是表示 修改 root 用户密码为 123456update user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27; and Host=&#x27;localhost&#x27;;# 刷新权限flush privileges;# 退出（只是退出 mysql 终端）quit


修改 my.ini 文件，再次进入就会进行权限验证了


重新启动 mysql 
123net stop mysqlnet start mysqlmysql -u root -p




最后，全部指令浏览注：如果安装过程出错，清楚 mysql 服务（sc delete mysql），重新按照步骤安装


数据库命令连接MySQL

登录前，保证 MySQL 服务已经启动

连接到 MySQL 服务（MySQL数据库）的指令
1mysql -h 主机ip -P 端口 -u 用户名 -p密码

-p密码不要有空格
-p后面没有写密码，回车会要求输入密码
如果没有写 -h 主机，默认就是本机
如果没有写 -P 端口，默认就是3306
在实际工作中，端口3306是会修改成其他的




Navicat
连接数据库


创建数据库


创建表……


数据库三层结构
所谓安装 MySQL 数据库，就是在主机安装一个数据库管理管理系统（DBMS），这个管理程序可以管理多个数据库。
DBMS（database manage system）

一个数据库中可以创建多个表，以保存数据（信息）

数据库管理系统（DBMS）、数据库和表的关系如图所示

数据库 - 普通表的本质是文件 




SQL语句分类
DDL：数据定义语句 [create 表，库……]
DML：数据操作语句 [增加 insert、修改 update、删除 delete]
DQL：数据查询语句 [select]
DCL：数据控制语句 [管理数据库：比如用户权限 grant revoke]

创建数据库123456CREATE DATABASE [IF NOT EXISTS] db_name[create_specification [, create_specification]...]create_specification:	[DEFAULT] CHARACTER SET charset_name	[DEFAULT] COLLATE collation_name

CHARACTER SET ：指定数据库采用的字符集，如果不指定字符集，默认 utf8
COLLATE ：指定数据库字符集的校对规则
常用的 utf8_bin [区分大小写]
utf8_general_ci [不区分大小写] 
注意默认是 utf8_general_ci




例子
分别创建 3 个数据库，看写法

1234567891011121314# 创建 db02 数据库，并且不设置字符集和校对规则# 字符集默认为 utf8# 校对规则默认为 utf8_general_ciCREATE DATABASE db02;# 创建 db03 数据库# 字符集设置为 utf8# 校对规则为默认CREATE DATABASE db03 CHARACTER SET utf8;# 创建 db04 数据库# 字符集设置为 utf8# 校对规则设置为 utf8_binCREATE DATABASE db04 CHARACTER SET utf8 COLLATE utf8_bin;

创建表
如果创建表的时候没有指定
引擎、字符集、排序规则等参数默认是数据库的字符集和排序规则
比如下面的 db02数据库为 utf8 utf8_general_cin
​                  db04数据库为 utf8 utf8_bin
那么创建表的时候不设置参数的话就默认是数据库的参数



查看删除数据库12345678# 显示数据库语句SHOW DATABASES# 显示数据库创建语句SHOW CREATE DATABASE db_name# 数据库删除语句 DROP DATABASE [IF EXISTS] db_name


备份恢复数据库
备份数据库（DOS下）
1mysqldump -u 用户名 -p -B 数据库1 数据库2 数据库n &gt; 文件名.sql

比如我把数据库 db01 db02 db03 db04 备份到 F 盘下取名为 bak.sql
其实 bak.sql 文件就是对应的 sql 语句



恢复数据库（进入 MySQL命令行）
1sourse 文件名.sql

法一：上面的 命令


法二：直接复制备份文件 bak.sql 里面的 sql 语句，然后执行





备份恢复数据库的表
备份数据库的表
1mysqldump -u 用户名 -p 数据库 表1 表2 表n &gt; 文件名.sql








表表的创建1234567891011CREATE TABLE table_name(    field1 datatype,    field2 datatype,    field3 datatype) character set 字符集 collate 校对规则 engine 存储引擎# field：指定列名 datatype：指定列类型（字段类型）# character set：如不指定则为坐在数据库的字符集# collate：如不指定则为所在数据库的校对规则# engine：引擎

EX：创建 id（整形）、name（字符串）、password（字符串）、birthday（日期），并且字符集设置为 utf8、校对规则为 utf8_bin、引擎为 INNODB

123456CREATE TABLE `user` (		id INT,		`name` VARCHAR(255),		`password` VARCHAR(32),		birthday DATE)		CHARACTER SET utf8 COLLATE utf8_bin ENGINE INNODB;


MySql常用数据类型（列类型）

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/03/27/Battle-of-Tanks/" title="Battle of Tanks">Battle of Tanks</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-27T08:28:58.000Z" title="发表于 2021-03-27 16:28:58">2021-03-27</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-04T07:42:03.688Z" title="更新于 2021-04-04 15:42:03">2021-04-04</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/java/">java</a></span></div><div class="content">
Java绘图坐标体系坐标原点位于左上角，以像素为单位


像素：密度单位
比如屏幕分辨率是 1920x1080 表示每一行有 1920 个像素点，共有 1080 行
所以该屏幕一共有 1920x1080=2,073,600 个像素

线程-基础
程序 Program：为了完成特定任务，用某种语言编写的一组指令的集合，也就是代码
进程：指运行中的程序、进程是一次执行过程，或是正在运行的一个程序、是动态过程，有产生 存在 消亡的过程
线程
由进程创建，是进程的一个实体
一个进程可以拥有多个线程



线程使用继承 Thread 实现多继承
创建一个 Cat 类 每隔 1 秒输出 喵喵
然后分别查看主线程和 Cat 创建的进程

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.ThreadUse;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 9:55 * @ Description: com.ThreadUse * @ Version: 1.0 * 演示通过继承 Thread 类创建线程 */public class Thread01 &#123;    public static void main(String[] args) throws InterruptedException &#123;        // 创建cat对象，可以当成线程使用        Cat cat = new Cat();        cat.start();    // 启动线程 -&gt; 最终会执行 Cat run 方法        // 说明：当 main 线程启动一个子线程 Thread-0 主线程不会阻塞，会继续执行        // 主线程和子线程交替执行        System.out.println(Thread.currentThread().getName());        for (int i = 0; i &lt; 60; i++) &#123;            System.out.println(&quot;主线程 i = &quot; + i);            Thread.sleep(1000);        &#125;    &#125;&#125;/** * 当一个类继承了 Thread 类，该类就可以当做线程使用 * 重写 run 方法，写上自己的业务代码 * run 方法来自 Thread 类实现了Runnable 接口的 run 方法 * *//*    @Override    public void run() &#123;        if (target != null) &#123;            target.run();        &#125;    &#125; */class Cat extends Thread &#123;    private int times = 0;    @Override    public void run() &#123;        while (true) &#123;            System.out.println(&quot;喵喵喵&quot; + (++times) + &quot;，线程名称：&quot; + Thread.currentThread().getName());            // 让该进程休眠 1 秒            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            if (times == 80) &#123;                 break;            &#125;        &#125;    &#125;&#125;

分析：
main 线程会创建一个 Cat 线程
main 函数的线程名为：main
Cat 线程名称为：Thread-0


因为 main 线程执行次数为 60，Thread-0 线程执行次数为80
所以 main 线程先消亡，Thread-0 线程后消亡





这里为何不直接调用 cat.run()，并没有创建新线程

如果调用了 cat.run() 那么下面的代码就要等这个方法执行完成后方可执行（看下图），串行执行了
而且 cat 的线程名称就是 mian 并没有开辟新线程





下面看 start(); 执行源码分析主要执行，无用的省略

12345678// 1	public synchronized void start() &#123;        start0();    &#125;// 2	// start0() 是本地方法，由JVM调用，底层是 C/C++实现	// 真正实现多线程的是 start0() 方法    private native void start0();

通过实现 Runnable 接口实现多线程
说明：由于Java 是单继承的，如果一个类继承了其他类就不能继承 Thread 类了，所以想要实现多线程就可以通过实现 Runnable 接口来实现多线程


12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package com.ThreadUse;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 11:40 * @ Description: com.ThreadUse * @ Version: 1.0 * 通过实现 Runnable 接口实现多线程 */public class Thread02 &#123;    public static void main(String[] args) &#123;       Dog dog = new Dog();       // 创建一个 Thread 对象，把 dog对象(实现Runnable)，放入 Thread        Thread thread = new Thread(dog);        thread.start();                ThreadProxy threadProxy = new ThreadProxy(dog);        threadProxy.start();    &#125;&#125;class Dog implements Runnable &#123;    @Override    public void run() &#123;        int count = 0;        while (true) &#123;            System.out.println(&quot;汪汪叫：&quot; + (++count) + Thread.currentThread().getName());            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            if (count == 10) &#123;                break;            &#125;        &#125;    &#125;&#125;// 线程代理类，模拟了一个极简的 Thread类class ThreadProxy implements Runnable &#123;    private Runnable target = null;    @Override    public void run() &#123;        if (target != null) &#123;            target.run();        &#125;    &#125;    public ThreadProxy(Runnable target) &#123;        this.target = target;    &#125;    public void start() &#123;        start0();   // 真正实现多线程的方法    &#125;    public void start0() &#123;        run();    &#125;&#125;

上面代码的 ThreadProxy 只是模拟Thread


构造器接受一个实现了 Runnable 类的对象实例 

用户创建线程需要调用 start() 方法

start() 方法再调用 start0() 方法

start0() 方法再调用 run() （这个run方法是传经来的对象）
比如上面代码就是 Dog 的实例 dog


实现两个线程并发123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.ThreadUse;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 12:28 * @ Description: com.ThreadUse * @ Version: 1.0 * main 函数启动两个子线程 */public class Thread03 &#123;    public static void main(String[] args) &#123;        T1 t1 = new T1();        T2 t2 = new T2();        Thread thread1 = new Thread(t1);        Thread thread2 = new Thread(t2);        thread1.start();        thread2.start();    &#125;&#125;class T1 implements Runnable &#123;    private int count = 0;    @Override    public void run() &#123;        do &#123;            System.out.println(&quot;T1:Hello,World &quot; + (++count) + Thread.currentThread().getName());            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125; while (count != 80);    &#125;&#125;class T2 implements Runnable &#123;    private int count = 0;    @Override    public void run() &#123;        do &#123;            System.out.println(&quot;T2:Hello,World &quot; + (++count) + Thread.currentThread().getName());            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125; while (count != 80);    &#125;&#125;// OutT1:Hello,World 1Thread-0T2:Hello,World 1Thread-1T1:Hello,World 2Thread-0T2:Hello,World 2Thread-1T1:Hello,World 3Thread-0T2:Hello,World 3Thread-1................T1:Hello,World 79Thread-0T2:Hello,World 79Thread-1


继承 Thread 和 实现 Runnable 的区别
从java的设计看，这两者本身没有本质的区别，Thread本身就实现了 Runnable 接口
start() -&gt; start0()

实现 Runnable 接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制


12345T3 t3 = new T3();Thread thread1 = new Thread(t3);Thread thread2 = new Thread(t3);thread1.start();thread2.start();


卖票
下面是分别通过 继承和实现接口 两种方法，但都会出现超卖

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.Thread.ThreadUse;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 12:55 * @ Description: com.ThreadUse * @ Version: 1.0 * 使用多线程模拟三个窗口同事售票 100 张 */public class SellTicket &#123;    public static void main(String[] args) &#123;        // 通过继承实现//        SellTicket01 sellTicket01 = new SellTicket01();//        SellTicket01 sellTicket02 = new SellTicket01();//        SellTicket01 sellTicket03 = new SellTicket01();//        sellTicket01.start();//        sellTicket02.start();//        sellTicket03.start();        // 通过接口实现        SellTicket02 sellTicket = new SellTicket02();        Thread thread01 = new Thread(sellTicket);        Thread thread02 = new Thread(sellTicket);        Thread thread03 = new Thread(sellTicket);        thread01.start();        thread02.start();        thread03.start();    &#125;&#125;// 通过继承方式class SellTicket01 extends Thread &#123;    private static int ticketNum = 100; // 让多个线程去销售    @Override    public void run() &#123;        while (true) &#123;            if (ticketNum &lt;= 0) &#123;                System.out.println(&quot;票以售完&quot;);                break;            &#125;            try &#123;                Thread.sleep(50);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;窗口：&quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot; +                    &quot; 剩余票数：&quot; + (--ticketNum));        &#125;    &#125;&#125;// 通过 接口方式class SellTicket02 implements Runnable &#123;    private int ticketNum = 100; // 让多个线程去销售    @Override    public void run() &#123;        while (true) &#123;            if (ticketNum &lt;= 0) &#123;                System.out.println(&quot;票以售完&quot;);                break;            &#125;            try &#123;                Thread.sleep(50);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;窗口：&quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot; +                    &quot; 剩余票数：&quot; + (--ticketNum));        &#125;    &#125;&#125;


线程终止
设置 loop 值实现——通知方式

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.Thread.ThreadExit;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 14:04 * @ Description: com.Thread.ThreadExit * @ Version: 1.0 */public class ThreadExit01 &#123;    public static void main(String[] args) throws InterruptedException &#123;        T t = new T();        t.start();        System.out.println(&quot;主线程休眠 10s&quot;);        Thread.sleep(10000);        t.setLoop(false);    &#125;&#125;class T extends Thread &#123;    private int num = 0;    private boolean loop = true;    @Override    public void run() &#123;        while (loop) &#123;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;T运行中......&quot; + (++num));        &#125;    &#125;    public void setLoop(boolean loop) &#123;        this.loop = loop;    &#125;&#125;// Out主线程休眠 10sT运行中......1T运行中......2T运行中......3T运行中......4T运行中......5T运行中......6T运行中......7T运行中......8T运行中......9T运行中......10Process finished with exit code 0
线程常用方法
setName    // 设置线程名称

getName   // 返回线程名称

start

run    // 调用线程对象 run 方法

setPriority    // 更改线程的优先级
12345678910111213141516    /**  * The minimum priority that a thread can have.  */ public static final int MIN_PRIORITY = 1;   /**  * The default priority that is assigned to a thread.  */ public static final int NORM_PRIORITY = 5;    /**  * The maximum priority that a thread can have.  */ public static final int MAX_PRIORITY = 10;   
getPriority    // 获取线程的优先级

sleep    // 在指定的毫秒数内让当前正在执行的线程休眠

interrupt    // 中断程序

yield    // 线程礼让，让出cpu，让其他线程执行，但礼让时间不确定，故不一定礼让成功

join    // 线程插队，插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务
12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.Thread.Method;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 15:25 * @ Description: com.Thread.Method * @ Version: 1.0 */public class ThreadMethod01 &#123;    public static void main(String[] args) throws InterruptedException &#123;        T t = new T();        t.start();        // 主线程吃包子        for (int i = 1; i &lt;= 20; i++) &#123;            Thread.sleep(1000);            System.out.println(&quot;主线程（小弟）吃了 &quot; + i + &quot; 个包子&quot;);            // 主线程吃 5 个包子就让老大吃完 20 个然后在吃            if (i == 5) &#123;                System.out.println(&quot;主线程（小弟）让 包子给 老大吃&quot;);                // join 线程插队                t.join();                // yield 礼让//                Thread.yield();                System.out.println(&quot;老大吃完了，接下来主线程（小弟）吃&quot;);            &#125;        &#125;    &#125;&#125;class T extends Thread &#123;    @Override    public void run() &#123;        for (int i = 1; i &lt;= 20; i++) &#123;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;子线程（老大）吃了 &quot; + i + &quot; 个包子&quot;);        &#125;    &#125;&#125;// Out子线程（老大）吃了 1 个包子主线程（小弟）吃了 1 个包子主线程（小弟）吃了 2 个包子子线程（老大）吃了 2 个包子主线程（小弟）吃了 3 个包子子线程（老大）吃了 3 个包子主线程（小弟）吃了 4 个包子子线程（老大）吃了 4 个包子主线程（小弟）吃了 5 个包子主线程（小弟）让 包子给 老大吃子线程（老大）吃了 5 个包子子线程（老大）吃了 6 个包子子线程（老大）吃了 7 个包子子线程（老大）吃了 8 个包子子线程（老大）吃了 9 个包子子线程（老大）吃了 10 个包子子线程（老大）吃了 11 个包子子线程（老大）吃了 12 个包子子线程（老大）吃了 13 个包子子线程（老大）吃了 14 个包子子线程（老大）吃了 15 个包子子线程（老大）吃了 16 个包子子线程（老大）吃了 17 个包子子线程（老大）吃了 18 个包子子线程（老大）吃了 19 个包子子线程（老大）吃了 20 个包子老大吃完了，接下来主线程（小弟）吃主线程（小弟）吃了 6 个包子主线程（小弟）吃了 7 个包子主线程（小弟）吃了 8 个包子主线程（小弟）吃了 9 个包子主线程（小弟）吃了 10 个包子主线程（小弟）吃了 11 个包子主线程（小弟）吃了 12 个包子主线程（小弟）吃了 13 个包子主线程（小弟）吃了 14 个包子主线程（小弟）吃了 15 个包子主线程（小弟）吃了 16 个包子主线程（小弟）吃了 17 个包子主线程（小弟）吃了 18 个包子主线程（小弟）吃了 19 个包子主线程（小弟）吃了 20 个包子




用户线程和守护线程
用户线程：也叫工作线程，当线程的任务执行完或通知方式
守护线程：一般为工作线程服务，当所有的用户线程结束，守护线程自动结束
常见的守护线程：垃圾回收机制


下面测试如何将一个线程设置为守护线程
ThreadMethod02

12345678910111213141516171819202122232425262728293031323334353637package com.Thread.Method;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 16:03 * @ Description: com.Thread.Method * @ Version: 1.0 */public class ThreadMethod02 &#123;    public static void main(String[] args) throws InterruptedException &#123;        Thread thread = new Thread(new MyDaemonThread());        // 如果我们希望当 main 线程结束以后，子线程自动结束        // 只需将子线程设置为守护线程        thread.setDaemon(true);        thread.start();        for (int i = 1; i &lt;= 5; i++) &#123;            Thread.sleep(1000);            System.out.println(&quot;我是 main&quot;);        &#125;    &#125;&#125;class MyDaemonThread implements Runnable &#123;    @Override    public void run() &#123;        for (; ; ) &#123;            try &#123;                Thread.sleep(50);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;我是MyDaemonThread&quot;);        &#125;    &#125;&#125;


线程生命周期


通过下面代码查看状态

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.Thread.State;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 16:47 * @ Description: com.Thread.State * @ Version: 1.0 */public class ThreadState &#123;    public static void main(String[] args) throws InterruptedException &#123;        T t = new T();        System.out.println(t.getName() + &quot; 状态 &quot; + t.getState());        t.start();        while (Thread.State.TERMINATED != t.getState()) &#123;            System.out.println(t.getName() + &quot; 状态 &quot; + t.getState());            Thread.sleep(1000);        &#125;        System.out.println(t.getName() + &quot; 状态 &quot; + t.getState());    &#125;&#125;class T extends Thread &#123;    @Override    public void run() &#123;       for (int i = 0; i &lt; 10; i++) &#123;           try &#123;               Thread.sleep(1000);           &#125; catch (InterruptedException e) &#123;               e.printStackTrace();           &#125;           System.out.println(&quot;Hi &quot; + i);       &#125;    &#125;&#125;// OutThread-0 状态 NEWThread-0 状态 RUNNABLEThread-0 状态 RUNNABLEHi 0Thread-0 状态 RUNNABLEHi 1Thread-0 状态 TIMED_WAITINGHi 2Thread-0 状态 TIMED_WAITINGHi 3Thread-0 状态 TIMED_WAITINGHi 4Thread-0 状态 TIMED_WAITINGHi 5Thread-0 状态 TIMED_WAITINGHi 6Thread-0 状态 TIMED_WAITINGHi 7Thread-0 状态 TIMED_WAITINGHi 8Thread-0 状态 TIMED_WAITINGHi 9Thread-0 状态 TERMINATED


线程同步机制
Synchronize
在多线程编程中，一些敏感数据不允许被多个线程同时访问，保证数据在任何时刻，最多有一个线程访问，以保证数据的完整性

12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.Thread.Synchronize;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 12:55 * @ Description: com.Thread.Synchronize * @ Version: 1.0 * 使用多线程模拟三个窗口同事售票 100 张 */public class SellTicket &#123;    public static void main(String[] args) &#123;        // 通过继承实现        SellTicket01 sellTicket01 = new SellTicket01();        SellTicket01 sellTicket02 = new SellTicket01();        SellTicket01 sellTicket03 = new SellTicket01();        sellTicket01.start();        sellTicket02.start();        sellTicket03.start();        // 通过接口实现//        SellTicket02 sellTicket = new SellTicket02();//        Thread thread01 = new Thread(sellTicket);//        Thread thread02 = new Thread(sellTicket);//        Thread thread03 = new Thread(sellTicket);//        thread01.start();//        thread02.start();//        thread03.start();    &#125;&#125;class SellTicket01 extends Thread &#123;    private static int ticketNum = 100; // 让多个线程去销售    private boolean loop = true;    static Object object = new Object();    public void sell() &#123;  // 同步方法，在同一时刻，只能有一个线程来执行该方法        synchronized (object) &#123;            if (ticketNum &lt;= 0) &#123;                loop = false;                System.out.println(&quot;票以售完&quot;);                return;            &#125;            try &#123;                Thread.sleep(50);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;窗口：&quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot; +                    &quot; 剩余票数：&quot; + (--ticketNum));        &#125;    &#125;    @Override    public void run() &#123;        while (loop) &#123;            sell();        &#125;    &#125;&#125;class SellTicket02 implements Runnable &#123;    private static int ticketNum = 100; // 让多个线程去销售    private boolean loop = true;    Object object = new Object();    // 同步方法实现加锁    // 这时锁在 this 对象    // 也可以在代码块写 synchronized ，这是同步代码块    public /*synchronized*/ void sell() &#123;  // 同步方法，在同一时刻，只能有一个线程来执行该方法        synchronized (/*this*/ object) &#123;    // 写this或object都可以            if (ticketNum &lt;= 0) &#123;                loop = false;                System.out.println(&quot;票以售完&quot;);                return;            &#125;            try &#123;                Thread.sleep(50);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.println(&quot;窗口：&quot; + Thread.currentThread().getName() + &quot; 售出一张票&quot; +                    &quot; 剩余票数：&quot; + (--ticketNum));        &#125;    &#125;    @Override    public void run() &#123;        while (loop) &#123;            sell();        &#125;    &#125;&#125;


线程死锁
多个线程都占用了对方的锁资源，但不肯相让，导致了死锁


举例

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.Thread.Synchronize;import javax.sound.midi.Soundbank;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 20:06 * @ Description: com.Thread.Synchronize * @ Version: 1.0 */public class DeadLock &#123;    public static void main(String[] args) &#123;        DeadLockDemo deadLockDemo = new DeadLockDemo(true);        DeadLockDemo deadLockDemo1 = new DeadLockDemo(false);        deadLockDemo.start();        deadLockDemo1.start();    &#125;&#125;class DeadLockDemo extends Thread &#123;    private boolean flag;    static Object o1 = new Object();    static Object o2 = new Object();    public DeadLockDemo(boolean flag) &#123;        this.flag = flag;    &#125;    @Override    public void run() &#123;        while (true) &#123;            if (flag) &#123;                synchronized (o1) &#123;                    System.out.println(Thread.currentThread().getName() + &quot; 进入了 1 &quot;);                    synchronized (o2) &#123;                        System.out.println(Thread.currentThread().getName() + &quot; 进入了 2 &quot;);                    &#125;                &#125;            &#125; else &#123;                synchronized (o2) &#123;                    System.out.println(Thread.currentThread().getName() + &quot; 进入了 3 &quot;);                    synchronized (o1) &#123;                        System.out.println(Thread.currentThread().getName() + &quot; 进入了 4 &quot;);                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;


释放锁
当前线程的同步方法、同步代码执行结束
当前线程在同步代码块、同步方法中遇到了 break、return
当前线程在同步代码块、同步方法中出现了未处理的 Error、Exception，导致异常结束
当前线程在同步代码快、同步方法中执行了线程对象的 wait() 方法，当前线程暂停，并释放锁


下面操作不会释放锁


线程执行同步代码块或者同步方法时，程序调用了 Thread.sleep()、Thread.yield() 方法暂停当前线程的执行，不会释放锁
线程执行同步代码块时，其他线程调用了该线程的 suspend() 方法将该线程挂起，该线程不会释放锁

练习
（1）在main方法中启动两个线程
（2）第 1 个线程循环随机打印 100 以内的整数
（3）直到第 2 个线程从键盘读取了 “Q” 命令

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.Homework;import java.util.Scanner;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 21:11 * @ Description: com.Homework * @ Version: 1.0 */public class Homework01 &#123;    public static void main(String[] args) &#123;        T1 t1 = new T1();        Thread thread = new Thread(t1);        thread.start();        T2 t2 = new T2(t1);        Thread thread1 = new Thread(t2);        thread1.start();    &#125;&#125;// 随机输出 1-100 数字class T1 implements Runnable &#123;    private boolean loop = true;    public boolean isLoop() &#123;        return loop;    &#125;    public void setLoop(boolean loop) &#123;        this.loop = loop;    &#125;    @Override    public void run() &#123;        // 输出 1-100 数字        while (loop) &#123;            System.out.println((int) (Math.random() * 100) + 1);            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;        System.out.println(&quot;T1 线程退出&quot;);    &#125;&#125;// 输入 Q 上面的线程就会退出class T2 implements Runnable &#123;    private T1 a;    private Scanner scanner = new Scanner(System.in);    public T2(T1 a) &#123;   // 构造器传入 T1 对象        this.a = a;    &#125;    @Override    public void run() &#123;        while (true) &#123;            // 接受到用户的输入            System.out.println(&quot;请输入指令(Q)表示退出 : &quot;);            char key = scanner.next().toUpperCase().charAt(0);            if (key == &#x27;Q&#x27;) &#123;                // 以通知的方式结束 a                a.setLoop(false);                break;            &#125;        &#125;        System.out.println(&quot;T2 线程退出&quot;);    &#125;&#125;





（1）有 2 个用户分别从同一个卡上取钱 总额为 10000
（2）每次都取 1000，当余额不足时，不能取款
（3）不能出现超取现象

12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.Homework;/** * @ Author: MingHui Fan * @ Date: 2021/3/28 - 21:47 * @ Description: com.Homework * @ Version: 1.0 */public class Homework02 &#123;    public static void main(String[] args) &#123;        T t = new T();        Thread thread1 = new Thread(t);        thread1.setName(&quot;T1&quot;);        Thread thread2 = new Thread(t);        thread2.setName(&quot;T2&quot;);        thread1.start();        thread2.start();    &#125;&#125;// 取款线程class T implements Runnable &#123;    private int money = 10000;    @Override    public void run() &#123;        while (true) &#123;            synchronized (this) &#123;                if (money &lt; 1000) &#123;                    System.out.println(&quot;余额不足！！！&quot;);                    break;                &#125;                money -= 1000;                System.out.println(Thread.currentThread().getName() + &quot; 取出 1000, 当前余额 : &quot; + money);            &#125;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/03/22/STL/" title="STL">STL</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-22T10:30:25.000Z" title="发表于 2021-03-22 18:30:25">2021-03-22</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-18T09:15:02.980Z" title="更新于 2021-04-18 17:15:02">2021-04-18</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a></span></div><div class="content">
vector接口
构造函数

vector    // 采用模板实现类实现，默认构造函数
vector(v.begin(), v.end)    // 拷贝 v[begin(), end())区间的元素
vector(n, elem)    // 构造函数将 n 个 elem 拷贝给本身
vector(const vector &amp;vec)   // 拷贝构造函数


常用赋值

assign(beg, end);    // 将 [begin, end) 区间的数据拷贝赋值给本身
assign(n, elem);    // 将n个elem拷贝赋值给本身
vector&amp; operator=(const vector &amp;vec);    // 重载等号操作符
swap(vec);    // 将vec与本身的元素互换

12345678910111213// 构造vector&lt;int&gt; v1;vector&lt;int&gt; v2(10, 5);	// 10个5vector&lt;int&gt; v3(v2.begin(), v2.end());	// 将v2拷贝到v3// 赋值vector&lt;int&gt; v4;v4.assign(v3.begin(), v3.end());	// 将v3赋值给v4vector&lt;int&gt; v5;v5 = v3;	// 用等号赋值一样的//swap交换v5.swap(v4);	// 将v5和v4内容互换


大小操作

size();     // 返回元素个数
empty();
resize(int num);     // 重新定义容器长度，如果变长，则用默认值填充新位置，如果变短，则超出的部分元素舍弃
resize(int num, elem);
capacity();     // 容器的容量
reserve(int len);    // 预留len和元素长度，预留位置不初始化，元素不可访问


数据存储操作

at(int index);    // 越界抛异常 out_of_range
operator[];    // 越界运行直接报错
front();    // 返回第一个元素
back();    // 返回最后一个元素


插入和删除

insert(const_iterator pos, int count, elem);    // 迭代器指向位置 pos 插入 count 个 元素 elem
insert(const_iterator pos, elem);    // 同上，不过默认插入一个 elem

123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void printVector(vector&lt;int&gt;&amp;v) &#123;    vector&lt;int&gt;::iterator it;    for (it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot;_&quot;;    &#125;    cout &lt;&lt; endl;&#125;int main() &#123;    vector&lt;int&gt; vec;    vec.push_back(1);    vec.push_back(2);    vec.push_back(3);    vec.push_back(4);    vec.insert(vec.begin(), 100);    printVector(vec);    vec.insert(vec.end(),3, 100);    printVector(vec);    return 0;&#125;/* out100_1_2_3_4_100_1_2_3_4_100_100_100_*/



push_back(elem);     // 尾部插入元素
pop_back();    // 删除最后一个元素
erase(const_iterator start, const_iterator end);     // 删除迭代器从 start 到 end 之间的元素
erase(const_iterator pos);     // 删除迭代器指向的元素
clear();     // 删除容器中所有元素




去重 unique


输出函数1234567891011121314151617// 正序void printVector(vector&lt;int&gt;&amp;v) &#123;    vector&lt;int&gt;::iterator it;    for (it = v.begin(); it != v.end(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot;_&quot;;    &#125;    cout &lt;&lt; endl;&#125;// 逆序void printVector_reverse(vector&lt;int&gt;&amp;v) &#123;    vector&lt;int&gt;::reverse_iterator it;    for (it = v.rbegin(); it != v.rend(); it++) &#123;        cout &lt;&lt; *it &lt;&lt; &quot;_&quot;;    &#125;    cout &lt;&lt; endl;&#125;


swap
例子




将未使用的空间进行释放
方法如下


作用：

vector(vec)：利用拷贝构造初始匿名对象

然后匿名创建的占用空间就是使用容量
然后匿名对象和 vec 互换
之后匿名对象会自己析构









priority_queue优先队列，int 默认大的优先123456789101112131415161718192021# include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    priority_queue&lt;int&gt;q;    int n = 5;    for (int i = 0; i &lt; n; i++) &#123;        q.push(i);    &#125;    while (!q.empty()) &#123;        cout &lt;&lt; q.top() &lt;&lt; &quot; &quot;;        q.pop();    &#125;    return 0;&#125;// out// 4 3 2 1 0
priority_queue 小的优先写法12345678910111213141516171819202122# include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;&gt;&gt;q;    int n = 5;    for (int i = 0; i &lt; n; i++) &#123;        q.push(i);    &#125;    while (!q.empty()) &#123;        cout &lt;&lt; q.top() &lt;&lt; &quot; &quot;;        q.pop();    &#125;    return 0;&#125;// out//  0 1 2 3 4
结构体优先写法
不同于 sort() 函数

1234567891011121314151617181920212223242526272829303132# include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct node &#123;    int val;    bool friend operator&lt;(node x, node y) &#123;        return x.val &lt; y.val;	// 这样反而是 大的 优先        // 小的优先        // return x.val &gt; y.val;    &#125;&#125;;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    priority_queue&lt;node&gt;q;    int n = 5;    for (int i = 0; i &lt; n; i++) &#123;        node tmp&#123;&#125;;        tmp.val = i;        q.push(tmp);    &#125;    while (!q.empty()) &#123;        cout &lt;&lt; q.top().val &lt;&lt; &quot; &quot;;        q.pop();    &#125;    return 0;&#125;// out// 4 3 2 1 0 


sort() 结构体比较写法1sort(v.begin(), v.begin() + k, Cmp);

写在结构体内
123456struct node &#123;    int val;    bool friend operator&lt;(node x, node y) &#123;        return x.val &lt; y.val;	// 小到大排序    &#125;&#125;;
写在结构体外
1234567struct node &#123;    int val;&#125;;bool Cmp(node x, node y) &#123;    return x.val &gt; y.val;  // 大到小排序&#125;






全排列模板
注意 while (next_permutation(左下标, 右下标))
排列的区间是 [左下标, 右下标)
此例子是 [1, 5) 不包括 m[5]

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    int count = 0;    int m[100];    int n;  cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++) &#123;        m[i] = i;    &#125; do &#123;        for (int i = 1; i &lt;= n; i++) &#123;            cout &lt;&lt; m[i] &lt;&lt; &quot; &quot;;        &#125;        count++;        cout &lt;&lt; endl;    &#125; while (next_permutation(m+1, m+5)); // 左闭右开 [m+1, m+5) 之间的数全排列    cout &lt;&lt; &quot;排列总数：&quot; &lt;&lt; count &lt;&lt; endl;    return 0;&#125;101 2 3 4 5 6 7 8 9 10 1 2 4 3 5 6 7 8 9 10 1 3 2 4 5 6 7 8 9 10 1 3 4 2 5 6 7 8 9 10 1 4 2 3 5 6 7 8 9 10 1 4 3 2 5 6 7 8 9 10 2 1 3 4 5 6 7 8 9 10 2 1 4 3 5 6 7 8 9 10 2 3 1 4 5 6 7 8 9 10 2 3 4 1 5 6 7 8 9 10 2 4 1 3 5 6 7 8 9 10 2 4 3 1 5 6 7 8 9 10 3 1 2 4 5 6 7 8 9 10 3 1 4 2 5 6 7 8 9 10 3 2 1 4 5 6 7 8 9 10 3 2 4 1 5 6 7 8 9 10 3 4 1 2 5 6 7 8 9 10 3 4 2 1 5 6 7 8 9 10 4 1 2 3 5 6 7 8 9 10 4 1 3 2 5 6 7 8 9 10 4 2 1 3 5 6 7 8 9 10 4 2 3 1 5 6 7 8 9 10 4 3 1 2 5 6 7 8 9 10 4 3 2 1 5 6 7 8 9 10 排列总数：24


lower_bound( )、upper_bound( )
数组从小到大顺序时
lower_bound(begin, end, num);    // 返回第一个 大于等于 num 的地址
upper_bound(begin, end, num);   // 返回第一个 大于 num 的地址


数组从大到小顺序时，重载lower_bound()和upper_bound() 即可找到第一个小于等于 num 的地址
lower_bound(begin, end, num, greater);    // 返回第一个 小于等于 num 的地址
upper_bound(begin, end, num, greater);     // 返回第一个 小于 num 的地



1234567891011121314151617181920212223242526272829303132333435363738# include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123;    ios::sync_with_stdio(false);    cin.tie(nullptr);    int m[5];    m[0] = 0;    m[1] = 2;    m[2] = 4;    m[3] = 6;    m[4] = 8;    int pos1 = lower_bound(m, m+5, 4) - m;    int pos2 = upper_bound(m, m + 5, 4) - m;    cout &lt;&lt; &quot;pos1:&quot; &lt;&lt; pos1 &lt;&lt; endl;    cout &lt;&lt; &quot;pos2:&quot; &lt;&lt; pos2 &lt;&lt; endl;    sort(m, m + 5, greater&lt;int&gt;());    for (int i = 0; i &lt; 5; i++) &#123;        cout &lt;&lt; m[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;        int pos3 = lower_bound(m, m+5, 4, greater&lt;int&gt;()) - m;    int pos4 = upper_bound(m, m + 5, 4, greater&lt;int&gt;()) - m;    cout &lt;&lt; &quot;pos3:&quot; &lt;&lt; pos3 &lt;&lt; endl;    cout &lt;&lt; &quot;pos4:&quot; &lt;&lt; pos4 &lt;&lt; endl;    return 0;&#125;// outpos1:2pos2:38 6 4 2 0 pos3:2pos4:3
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/03/17/data%20struct%20two/" title="data struct two">data struct two</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-17T11:02:24.000Z" title="发表于 2021-03-17 19:02:24">2021-03-17</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-05T04:26:36.658Z" title="更新于 2021-04-05 12:26:36">2021-04-05</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">
前缀树code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131package Trees.TrieTree;/** * @ Author: MingHuiFan * @ Date: 2021/3/3 - 21:09 * @ Description: Trees.PrefixTree * @ Version: 1.0 */public class trieTree &#123;    // 前缀树节点    static class TrieNode &#123;        int pass;   // 记录进过了几次        int end;    // 记录以当前节点为尾的字符串        TrieNode[] nexts;   // 记录 &#x27;a&#x27;-&#x27;z&#x27; 的路径        public TrieNode() &#123;            nexts = new TrieNode[26];        &#125;    &#125;    // 前缀树实现    public static class Trie &#123;        private TrieNode root;        public Trie() &#123;            root = new TrieNode();        &#125;        public int size() &#123;            return root.pass;        &#125;        // 插入一段字符串        public void insert(String word) &#123;            if (word == null) &#123;                return;            &#125;            TrieNode node = root;            node.pass++;            int index = 0;  // 记录字母            char[] chars = word.toCharArray();            for (int i = 0; i &lt; chars.length; i++) &#123;                index = chars[i] - &#x27;a&#x27;; // a 对应 0, b 对应 1.....                if (node.nexts[index] == null) &#123;    // 如果未出现过该字母,则创建                    node.nexts[index] = new TrieNode();                &#125;                node = node.nexts[index];                node.pass++;            &#125;            node.end++;        &#125;        // 删除一段字符        public void delete(String word) &#123;            if (search(word) == 0) &#123;                return;            &#125;            TrieNode node = root;            node.pass--;            char[] chars = word.toCharArray();            int index = 0;            for (int i = 0; i &lt; chars.length; i++) &#123;                index = chars[i] - &#x27;a&#x27;;                if (--node.nexts[index].pass == 0) &#123;                    node.nexts[index] = null;                &#125;                node = node.nexts[index];            &#125;            node.end--;            return;        &#125;        // 查询字符在树中出现的次数        public int search(String word) &#123;            if (word == null) &#123;                return 0;            &#125;            TrieNode node = root;            char[] chars = word.toCharArray();            int index = 0;            for (int i = 0; i &lt; chars.length; i++) &#123;                index = chars[i] - &#x27;a&#x27;;                // 如果未在树中存在该路径则直接返回 0                if (node.nexts[index] == null) &#123;                    return 0;                &#125;                node = node.nexts[index];            &#125;            return node.end;        &#125;        // 所有加入的字符串中，计算有多少个是以 pre 为前缀的        public int prefixNumber(String pre) &#123;            if (pre == null) &#123;                return 0;            &#125;            TrieNode node = root;            char[] chars = pre.toCharArray();            int index = 0;            for (int i = 0; i &lt; chars.length; i++) &#123;                index = chars[i] - &#x27;a&#x27;;                if (node.nexts[index] == null) &#123;                    return 0;                &#125;                node = node.nexts[index];            &#125;            return node.pass;        &#125;    &#125;    public static void main(String[] args) &#123;        Trie trie = new Trie();        String string0 = &quot;abc&quot;;        String string1 = &quot;abc&quot;;        String string2 = &quot;acdefg&quot;;        String string3 = &quot;minghuifan&quot;;        trie.insert(string0);        trie.insert(string1);        trie.insert(string2);        trie.insert(string3);        trie.delete(string1);        System.out.println(trie.size());        System.out.println(trie.search(&quot;abc&quot;));    &#125;&#125;





Hash
out f(in)


in -&gt; 无穷
out -&gt; S（一个范围）

MD5：0 ~ 2^64-1
十六进制为16位的字符串，即每个位表示16中状态(00001111 or 0F)

SHA1：0 ~ 2^128-1
十六进制为32位的字符串



相同的in -&gt; 相同的out
说明哈希函数不随机

不同的输入 -&gt; 相同的输出（哈希碰撞）

输入得到的哈希值都均匀且离散的分布在 S 域上

取模



EX1有40亿个无符号整数的文件，无符号整数范围是(0 ~ 2^32^-1)，给 1G 内存返回出现次数最多的整数

2^32^ = 4,294,967,296 约为 43 亿


布隆过滤器
先引入位图

1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package Chapter_9;/** * @ Author: MingHuiFan * @ Date: 2021/3/18 - 18:52 * @ Description: Chapter_9 * @ Version: 1.0 */public class BitArr &#123;    // 加入数组中一共有 N 个数，每个数占 4 字节    // 共有 4N Byte = 4N*8 bit    /**     * 改变第 index 位的 0 1     * @param arr     */    static int bitarr(int[] arr, int index) &#123;        int numIndex = index / 32;  // 定位到数组的哪一位        int bitIndex = index % 32;  // 定位在该数的第多少位        int bit = (arr[numIndex] &gt;&gt; bitIndex) &amp; 1;  // 拿到第 index 位的状态        arr[numIndex] = arr[numIndex] | (1 &lt;&lt; bitIndex);    // 将 index 位的数修改为 1//        arr[numIndex] = arr[numIndex] &amp; (~(1 &lt;&lt; bitIndex));   // 将 index 位的数修改为 0        // 总结：取得第 i 位的 0/1 状态 int bit = (arr[i / 32] &gt;&gt; (i % 32)) &amp; 1        return bit;    &#125;    // 打印二进制数    static void test1() &#123;        int[] arr = &#123;1, 2, 3, 4, 5, 6&#125;;        int sum = 0;        for (int i = 0; i &lt; 192; i++) &#123;            System.out.print(bitarr(arr, i));            if (sum++ % 32 == 31) &#123;                System.out.println();            &#125;        &#125;    &#125;    // 一位一位的改变, 下面写法省略了前面 28 个0    // 1 0001   0~31    // 2 0010   32~63    // 3 0011   64~95    // 4 0100   96~127    static void test2() &#123;        int[] arr = &#123;1, 2, 3, 4&#125;;        bitarr(arr, 1);        bitarr(arr, 32);        bitarr(arr, 66);        bitarr(arr, 96);        for (int i : arr) &#123;            System.out.print(i + &quot;_&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        test1();        test2();    &#125;&#125;/** out * 10000000000000000000000000000000 * 01000000000000000000000000000000 * 11000000000000000000000000000000 * 00100000000000000000000000000000 * 10100000000000000000000000000000 * 01100000000000000000000000000000 * 3_3_7_5_ */

题目：
不安全网页的黑名单包含 100亿 个黑名单网页，每个网页的 URL 最多占用 64B。现在想要实现一个网页过滤系统，利用该系统可以根据网页的 URL 判断该网页是否在黑名单上，请设计该系统。
要求：

该系统允许有万分之一以下的判断失误率
使用的额外空间不要超过 30G


这个问题可以使我们认识布隆过滤器器

分析：
如果我们使用 HashSet 来保存每一个 URL，一个 URL 就是 64B，100亿个就是 6400亿B 约为 640G，显然超出要求的额外空间
通过把 URL 保存起来显然是不行的，无法达到题目要求的 30G 以下额外空间
那么就要用到布隆过滤器

通过例子了解实现
上诉我们已经了解了 位图，那么如果我们用位图中的每一个位置来保存一个 URL 需要的内存约为 640/8G 80G，还超过了 30G
但是我们不需要URL个位置，因此还可以将位图进一步缩小至 30G

如何用位图来保存 URL？

每个 URL 通过 k 个哈希函数计算得到一个哈希值然后在模上m（m为位图数位数），当然也可能出现哈希值相同的情况
然后此时每个哈希值对应位图中的每一位，进行描黑（也就是变为1）
然后对每一个 URL 重复上两个操作



然后每个 URL 都通过多个哈希值找到了对应的位置进行描黑处理了

然后查找方式如下，比如查找 URLx 是否在黑名单上

URLx 通过那 k 个哈希函数然后模上m，得到了 k 个位置
然后看这 k 个位置在位图中是否全是黑的状态（即为1状态）


黑URL -&gt; 白   不存在
白URL -&gt; 黑   存在
为什么黑URL不可能报错成白URL：因为同一个 URL 通过相同的哈希函数得到的哈希值是一样的，那么肯定会描黑这些位置的，那么查找的时候这些位置必全为黑
白URL误报成黑URL：如果白URL计算出来的 K个 哈希值刚好是全黑，也就是说当 位图数m 较小、URL数量多且k较多时候可能位图中的每一个位置都描黑了。
那么我们就要降低白报成黑的概率，尽可能减少误报。


那么如何确定 ①k ②m ③url个数 
先确定 m 然后根据样本量和预期失误率来确定 k



n 样本量
p 预期失误率
只需要这两个参数，与单样本大小无关（比如这道题中的一个URL 64B 这个条件无用）



比如这道题中
n = 100亿
p = 0.01%
m = 19.19n = 20n = 2000亿bit = 25G
k = 14
最后计算出真实失误率 p(真) = 0.006%




一致性哈希原理
并查集
通用写法

123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package UnionFind;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Stack;/** * @ Author: MingHuiFan * @ Date: 2021/3/19 - 12:17 * @ Description: UnionFind * @ Version: 1.0 */public class UnionFindUniversal&lt;V&gt; &#123;    /*    将 V 类型数据包装成集合形式     */    private static class Element&lt;V&gt; &#123;        V value;        public Element(V value) &#123;            this.value = value;        &#125;    &#125;    // 并查集    public static class UnionFindSet&lt;V&gt; &#123;        HashMap&lt;V, Element&lt;V&gt;&gt; elementHashMap;        HashMap&lt;Element&lt;V&gt;, Element&lt;V&gt;&gt; fatherMap;        HashMap&lt;Element&lt;V&gt;, Integer&gt; sizeMap;        // 遍历元素，将每个元素都包装成一个集合        public UnionFindSet(List&lt;V&gt; list) &#123;            elementHashMap = new HashMap&lt;&gt;();            fatherMap = new HashMap&lt;&gt;();            sizeMap = new HashMap&lt;&gt;();            for (V value : list) &#123;                Element&lt;V&gt; element = new Element&lt;&gt;(value);                elementHashMap.put(value, element);                fatherMap.put(element, element);                sizeMap.put(element, 1);            &#125;        &#125;        // 给一个元素寻找这个元素所在集合的代表元素        public Element&lt;V&gt; findHead(Element&lt;V&gt; element) &#123;            Stack&lt;Element&lt;V&gt;&gt; path = new Stack&lt;&gt;(); // 用于存放元素            while (element != fatherMap.get(element)) &#123; // 如果该元素不属于                path.push(element); // 如果不是代表元素入栈                element = fatherMap.get(element);            &#125;            while (!path.empty()) &#123;                fatherMap.put(path.pop(), element);            &#125;            return element;        &#125;        public boolean isSameSet(V a, V b) &#123;            // 判断ab是否在集合中            if (elementHashMap.containsKey(a) &amp;&amp; elementHashMap.containsKey(b)) &#123;                return findHead(elementHashMap.get(a)) == findHead(elementHashMap.get(b));            &#125;            return false;        &#125;        public void union(V a, V b) &#123;            if (elementHashMap.containsKey(a) &amp;&amp; elementHashMap.containsKey(b)) &#123;                Element&lt;V&gt; aF = findHead(elementHashMap.get(a));                Element&lt;V&gt; bF = findHead(elementHashMap.get(b));                // 判断两个元素是否在同一集合                if (aF != bF) &#123;                    Element&lt;V&gt; maxSet = sizeMap.get(aF) &gt; sizeMap.get(bF) ? aF : bF;                    Element&lt;V&gt; minSet = maxSet == aF ? bF : aF;                    fatherMap.put(minSet, maxSet);  // 将小集合的父亲变为大集合，实现合并操作                    sizeMap.put(maxSet, sizeMap.get(maxSet) + sizeMap.get(minSet));                    sizeMap.remove(minSet);                &#125;            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        list.add(1);        list.add(2);        list.add(3);        list.add(4);        list.add(5);        UnionFindSet&lt;Integer&gt; u1 = new UnionFindSet&lt;&gt;(list);        u1.union(1, 3);        u1.union(1, 4);        System.out.println(u1.isSameSet(3,4));        System.out.println(u1.isSameSet(1,2));        System.out.println(u1.isSameSet(1,3));    &#125;&#125;/* Outtruefalsetrue */

findHead 函数调用的次数越多 平均时间复杂度越接近 O(1)


KMP
先看下暴力方法

123456789101112131415161718public static int force(String text, String pattern)  &#123;    int tlen = text.length();    int plen = pattern.length();    int ti = 0;    int pi = 0;    // 但凡有一个下标越界都退出    while (pi &lt; plen &amp;&amp; ti &lt; tlen) &#123;        if (text.charAt(ti) == pattern.charAt(pi)) &#123;            ti++;            pi++;        &#125; else &#123;            ti -= pi - 1;   // 退回到下一个位置            pi = 0;         // 匹配串回到 0 位置        &#125;    &#125;    // 如果是匹配串越界了一定是匹配成功    return pi == plen ? ti - pi : -1;&#125;
暴力解法就不多说了，文本串一个一个位置滑动

KMP解法为什么快
其实是在暴力解法中文本串中一个一个位置滑动的基础上进行了加速，可以实现跳跃的滑动


先看一个概念
==某一位置前缀和后缀最大匹配长度==
​        即该位置前的前缀和后缀最大匹配长度，但长度并不包括该位置前面的全部
​        如 ababc 
​        c 位置的前缀后缀最大匹配长度为 2 (前缀：ab、后缀：ab)
​        而不是 4（前缀：abab、后缀：abab）,不包括该位置前面全部字符串
​        如果包括的话那么每个字符位置的前缀后缀的最大匹配长度就是前面的长度

例子



位置 0 前面没有信息 —— 0
位置 1 —— 0
位置 2 —— 0
位置 3 —— 0
位置 4 —— 1 （前缀：a、后缀：a）
位置 5 —— 2 （前缀：ab、后缀：ab）
位置 6 —— 3 （前缀：abc、后缀：abc）


然后引入 next 数组
其实就是上面说的 前缀和后缀的最大匹配长度

例子：求法看上面


然后看 KMP 是如何加速的


绿色的为最大前缀和后缀标识，表示 Y 位置前缀后缀的最大匹配长度为 4
当匹配到 XY 位置发现不匹配

按照暴力匹配的话文本串跳到 i + 1 位置，模式串跳到 0 位置，然后开始新的一轮比较

如果是KMP的话，那么直接滑动到如图位置，然后从 X 位置和 j 位置开始比较即可（本质就是 从 i + 5 的位置和 0 位置开始比较）
但是由于后缀和前缀相等，所以 i + 5 —— X 的位置和 0 —— j 的位置必然匹配，所以直接从 X 和 j 位置开始比对所以就加速了整个比对的过程


如果 X 和 j 又不匹配呢如果 next[j] = 3


如果 X 和 j-1 又不匹配呢
重复上述过程
最坏的结果就是滑动到 0 和 X 比较



这里有个问题需要证明：为什么文本串的 i~K 的任何位置都配不出模式串
假设 i~K 中有位置 M 可以匹配出模式串


则 M(X-1) 必然与 0(j+2) 完全匹配 则下图椭圆区域必然完成一致


那么看 next[Y] 是不是就有问题了，next[Y] 本来是 4 但是你又找到了一个比 4 更长的前缀后缀匹配
矛盾，因为 原next[Y] 不可能计算出错。
所以 i~K 位置不可能与匹配串匹配成功。



code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package String;/** * @ Author: MingHuiFan * @ Date: 2021/3/20 - 15:18 * @ Description: String * @ Version: 1.0 */public class KMP &#123;    /*    KMP    O(N)     */    public static int getIndexOf(String text, String pattern) &#123;        if (text.length() &lt; pattern.length() || text.length() &lt; 1) &#123;            return -1;        &#125;        char[] str1 = text.toCharArray();   // 文本串        char[] str2 = pattern.toCharArray();    // 匹配串        int[] next = getNextArray(str2);    // next 数组        int i1 = 0;        int i2 = 0;        while (i1 &lt; str1.length &amp;&amp; i2 &lt; str2.length) &#123;            if (str1[i1] == str2[i2]) &#123; // 如果字符相等两者同时移动到下一个字符                i1++;                i2++;            &#125; else if (next[i2] == -1) &#123;    // str2 中比对的位置已经无法往前跳了                i1++;            &#125; else &#123;                i2 = next[i2];            &#125;        &#125;        // 只要是 i2 越界了，那么一定匹配成功        // 但是 i1 越界不一定匹配失败，因为 i1 i2 可能同时越界        return i2 == str2.length ? i1 - i2 : -1;    &#125;    /*    next 数组    O(M)     */    public static int[] getNextArray(char[] str2) &#123;        if (str2.length == 1) &#123;            return new int[] &#123;-1&#125;;        &#125;        int[] next = new int[str2.length];        next[0] = -1;        next[1] = 0;        int i = 2;        int cn = 0;        while (i &lt; next.length) &#123;            if (str2[i - 1] == str2[cn]) &#123;                next[i++] = ++cn;            &#125; else if (cn &gt; 0) &#123;   // cn 位置和 i - 1 不匹配，继续向前找                cn = next[cn];            &#125; else &#123;                next[i++] = 0;            &#125;        &#125;        return next;    &#125;    public static void main(String[] args) &#123;            &#125;&#125;


</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/03/08/data%20struct%20one/" title="data struct one">data struct one</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-08T08:31:39.000Z" title="发表于 2021-03-08 16:31:39">2021-03-08</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-04T07:30:47.348Z" title="更新于 2021-04-04 15:30:47">2021-04-04</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">
快排
补充：荷兰国旗问题



分析


问题一：


用一个变量 left 标记 &lt;= num 的右边界

此时遍历数组 arr 会出现两种情况

arr[i] &lt;= num：
  arr[i] 和小于等于部分右边界下标的后一个数交换，然后 小于等于区域右扩，i++

arr[i] &gt; num：区域不变, i++



直到越界，如下图例子






问题二：和问题一类似


arr[i] &lt; num，arr[i] 和 &lt; 区域下一个交换，**&lt; 区域右阔，i++**
arr[i] = num，i++
arr[i] &gt; num，arr[i] 和 &gt; 区域前一个交换，**&gt; 区域左扩，i++**



归并排序
时间复杂度：O(N*logN)
空间复杂度：O(N)

Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package Sort;import java.util.Random;/** * @ Author: MingHuiFan * @ Date: 2021/3/8 - 15:05 * @ Description: Sort * @ Version: 1.0 *//** * 时间复杂度分析 *  T(N) = a * T(N/b) + O(N^d) *  T(N) = 2 * T(N/2) + O(N) *  log(a,b) == d   -&gt;  O(N) = O(N*logN) * 空间复杂度：O(N) */public class MergeSort &#123;    // 注意 R 是数组最后一个下标，不是下标加一    public static void process(int[] arr, int L, int R) &#123;        if (L == R) &#123;            return;        &#125;        int mid = L + ((R - L) &gt;&gt; 2);        process(arr, L, mid);   // 左边排序        process(arr, mid + 1, R);   // 右边排序        merge(arr, L, mid, R);  // 整合        return;    &#125;    // 注意这里 R 是数组最后一个下标，不是下标加一    public static void merge(int[] arr, int L, int M, int R) &#123;        int[] help = new int[R - L + 1];        int i = 0;        int left = L;        int right = M + 1;        while (left &lt;= M &amp;&amp; right &lt;= R) &#123;            help[i++] = arr[left] &lt;= arr[right] ? arr[left++] : arr[right++];        &#125;        while (left &lt;= M) &#123;            help[i++] = arr[left++];        &#125;        while (right &lt;= R) &#123;            help[i++] = arr[right++];        &#125;        for (i = 0; i &lt; help.length; i++) &#123;            arr[L + i] = help[i];        &#125;        return;    &#125;    public static void main(String[] args) &#123;        int[] arr = new int[new Random().nextInt(51) + 50]; // 数组大小区间 [50, 100]        for (int i = 0; i &lt;arr.length; i++) &#123;            arr[i] = new Random().nextInt(100) + 100;        &#125;        for (int i = 0; i &lt; arr.length; i++) &#123;            System.out.print(arr[i] + &quot;_&quot;);        &#125;        System.out.println(arr.length);        process(arr, 0, arr.length - 1);        for (int i = 0; i &lt; arr.length; i++) &#123;            System.out.print(arr[i] + &quot;_&quot;);        &#125;    &#125;&#125;


拓展
小和问题-code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package Sort.Merge;import tools.Asserts;import tools.Times;import java.util.Arrays;import java.util.Random;/** * @ Author: MingHuiFan * @ Date: 2021/3/8 - 18:16 * @ Description: Sort.Merge * @ Version: 1.0 */// 小和问题public class SmallSum &#123;    // 小和问题求解函数    public static int smallSum(int[] arr) &#123;        if (arr == null || arr.length &lt; 2) &#123;            return 0;        &#125;        return mergeSort(arr, 0, arr.length - 1);    &#125;    // 递归过程    public static int mergeSort(int[] arr, int l, int r) &#123;        if (l == r) &#123;            return 0;        &#125;        int mid = l + ((r - l) &gt;&gt; 2);        int left = mergeSort(arr, l, mid);  // 左边小和        int right = mergeSort(arr, mid + 1, r); // 右边小和        int sum = merge(arr, l, mid, r);    // 左右合并求小和        return left + right + sum;    &#125;    // 左右两边排序并返回此次左右两边的小和    public static int merge(int[] arr, int l, int m, int r) &#123;        int[] help = new int[r - l + 1];    // 辅助数组        int left = l;        int right = m + 1;        int i = 0;        int res = 0;        // 如果左边不越界并且右边不越界        while (left &lt;= m &amp;&amp; right &lt;= r) &#123;            res += arr[left] &lt; arr[right] ? arr[left] * (r - right + 1) : 0;            help[i++] = arr[left] &lt; arr[right] ? arr[left++] : arr[right++];        &#125;        // 下面两个 while 循环只会进入其一        while (left &lt;= m) &#123;            help[i++] = arr[left++];        &#125;        while (right &lt;= r) &#123;            help[i++] = arr[right++];        &#125;        for (i = 0; i &lt; help.length; i++) &#123;            arr[l + i] = help[i];        &#125;        return res;    &#125;    // 暴力求解小和    public static int force(int[] arr) &#123;        int res = 0;        for (int i = 0; i &lt; arr.length - 1; i++) &#123;            for (int j = i + 1; j &lt; arr.length; j++) &#123;                if (arr[i] &lt; arr[j]) &#123;                    res += arr[i];                &#125;            &#125;        &#125;        return res;    &#125;    public static void main(String[] args) &#123;        int testSum = 100000;   // 测试的次数        // Times测试时间工具        Times.test(&quot;小和计算&quot;, () -&gt; &#123;            for (int test = 0; test &lt; testSum; test++) &#123;                int sum = 100;  // 数组的大小                int[] arr0 = new int[sum];                for (int i = 0; i &lt; arr0.length; i++) &#123;                    arr0[i] = new Random().nextInt(500);                &#125;                int[] arr1 = Arrays.copyOf(arr0, arr0.length);                Asserts.test(force(arr0) == smallSum(arr1));//                System.out.println(Arrays.toString(arr0));//                System.out.println(Arrays.toString(arr1));//                System.out.println(&quot;递归求小和：&quot; + smallSum(arr0));//                System.out.println(&quot;暴力求小和：&quot; + force(arr1));            &#125;        &#125;);    &#125;&#125;


逆序对数量-code
和上面求小和问题是差不多的，这是下面的微小区别



123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293package Sort.Merge;import tools.Asserts;import tools.Times;import java.util.Arrays;import java.util.Random;/** * @ Author: MingHuiFan * @ Date: 2021/3/9 - 12:30 * @ Description: Sort.Merge * @ Version: 1.0 */// 逆序对数量public class Reverse &#123;    public static int reverse(int[] arr) &#123;        if (arr == null || arr.length &lt; 2) &#123;            return 0;        &#125;        return mergeSort(arr, 0, arr.length - 1);    &#125;    public static int mergeSort(int[] arr, int l, int r) &#123;        if (l == r) &#123;            return 0;        &#125;        int mid = l + ((r - l) &gt;&gt; 2);        int L = mergeSort(arr, l, mid);        int R = mergeSort(arr, mid + 1, r);        int sum = merge(arr, l, mid, r);        return L + R + sum;    &#125;    public static int merge(int[] arr, int l, int m, int r) &#123;        int[] help = new int[r - l + 1];        int ans = 0;        int left = l;        int right = m + 1;        int i = 0;        while (left &lt;= m &amp;&amp; right &lt;= r) &#123;            ans += arr[left] &gt; arr[right] ? r - right + 1 : 0;            // 大-&gt;小排序 并且 相等要先移右边            help[i++] = arr[left] &gt; arr[right] ? arr[left++] : arr[right++];        &#125;        // 把未排好的排好        while (left &lt;= m) &#123;            help[i++] = arr[left++];        &#125;        while (right &lt;= r) &#123;            help[i++] = arr[right++];        &#125;        for (i = 0; i &lt; help.length; i++) &#123;            arr[l + i] = help[i];        &#125;        return ans;    &#125;    // 暴力求解    public static int force(int[] arr) &#123;        int ans = 0;        for (int i = 0; i &lt; arr.length - 1; i++) &#123;            for (int j = i + 1; j &lt; arr.length; j++) &#123;                if (arr[i] &gt; arr[j]) &#123;                    ans++;                &#125;            &#125;        &#125;        return ans;    &#125;    public static void main(String[] args) &#123;        int testSum = 10000000;        Times.test(&quot;逆序数&quot;, () -&gt; &#123;            for (int test = 0; test &lt; testSum; test++) &#123;                int sum = 5;                int[] arr0 = new int[sum];                for (int i = 0; i &lt; sum; i++) &#123;                    arr0[i] = new Random().nextInt(51) + 50;                &#125;                int[] arr1 = Arrays.copyOf(arr0, arr0.length);                Asserts.test(reverse(arr0) == force(arr1));//                System.out.println(Arrays.toString(arr0));//                System.out.println(Arrays.toString(arr1));//                System.out.print(force(arr0) + &quot;_&quot; + reverse(arr1) + &#x27;\n&#x27;);            &#125;        &#125;);    &#125;&#125;
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/03/04/Linux-notes/" title="Linux_notes">Linux_notes</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-04T13:51:41.000Z" title="发表于 2021-03-04 21:51:41">2021-03-04</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-04T05:41:33.566Z" title="更新于 2021-05-04 13:41:33">2021-05-04</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E8%AE%B0%E5%BD%95/">记录</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/Linux/">Linux</a></span></div><div class="content">

韩顺平教育






Linux运维工程师：服务器规划、调试优化、市场键控、故障处理、数据备份恢复、日志分析……

Linux嵌入式工程师：linux下驱动开发、嵌入式系统程序开发（C/C++）

Linux应用领域：

服务器：C/C++、pup、java、python、go
嵌入式：机顶盒、数字电视、网络电话、程控交换机、手机、PDA、智能家居、物联网……



基础篇Linux主要发行版：Ubuntu、Redhat、CentOS、Debain(蝶变)、Fedora、SuSE、OpenSUSE(示意图)



VM及安装 CentOS
几个注意点


选择安装位置：分三个区：boot、swap、根分区





网络的三种模式
虚拟机克隆
直接将装好的系统文件夹拷贝即可，然后VM中打开这个文件即可
 

用VM的克隆：克隆时候需要把需要克隆的系统关闭
 其实就是拷贝，克隆的文件可以直接在其他电脑上使用


虚拟机快照
虚拟机迁移和删除
迁移：直接剪切
删除：VM删除、直接删除文件

install vmtoolsRoot用户下安装
用于管理母机和本机的共享文件夹
但是在实际开发中，文件的上传和下载是要使用远程方式完成的




然后终端进去 opt 目录解压这个文件

解压
  

安装：一路回车
  



Linux目录结构







实操篇远程登录Linux

XShell
下载安装后查看 Linux 的 ip
然后 XShell 链接


新建
  

这里填写 Linux 系统的用户名或者Root




填写对应用户的密码
  



XFTP
新建
  

同样用户名和密码
  


Vim


关机重启命令123456shutdown -h now		// 立刻关机shutdown -h 1		// 一分钟后关机shutdown 			// 和上面一行默认是1分钟关机halt 				// 关机reboot				// 重启sync				// 将内存数据同步到磁盘中

用户登录和注销
用户管理
Linux 系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统


创建用户1useradd	用户名		// 添加用户
这样会自动创建一个和用户名同名的家目录，存放在 
/home/用户名

如果想指定家目录的位置则如下例子

12useradd -d /home/test 用户名# 表示用户名的家目录存在放在 /home/test/ 下


设置用户密码1passwd 用户名
注意：如果不写用户名是在当前登录账户更改密码，也就是当前的 root 账户

pwd    // 显示当前绝对路径

删除用户：两种
删除用户，但是保留该用户的家目录
 1userdel 用户名
删除用户以及家目录
 1userdel -r 用户名





查询用户信息1id 用户名


切换用户1su - 用户名

查看当前登录用户信息12who am iwhoami

即使切换了用户，查看也是显示最先登录的用户信息
用户组
系统可以对有共性/权限的多个用户进行统一的管理


新增组：
 1groupadd 组名
删除组
 1groupdel 组名
增加用户的时候直接加上组
 123useradd -g 用户组 用户名如新增一个用户 zwj 并制定到 wudang 组里面去useradd -g wudang zwj
修改用户的组
 1234usermod -g 要放入的组 用户名如将 wudang组的 zwj 修改到 mojiao组里面去step1: groupadd mojiaostep2: usermod -g mojiao zwj




用户和组相关文件

passwd文件：
 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell
 
 Shell解释：
 

shadow文件：
 
 给 king 设置密码在打开看下：此时有了加密口令
 

group文件
 创建用户的时候如果没有之指定组的情况下，会创建一个和用户名相同的组
 



1.如果组里面由用户则不能删除该组

实用指令运行级别

EX：从运行级别 5 到 3（无图形界面）
远程登录也可以切换运行级别




即：

查看运行级别：
  1systemctl get-default
  

改变运行级别
  1systemctl set-default 运行级别
  



重启之后



接下来的每次重启都是进去 运行级别3


注：如果切到无图形化界面（运行级别3）登入不进去root，别使用数字小键盘输入密码（没解锁）

找回 Root 密码

在启动界面按 “e”
 

找到这一行，后面加上 
 1init=/bin/sh
 

然后 Ctrl + X 进入 单用户模式
 

然后在光标闪烁的位置输入下面命令，然后回车
 1mount -o remount,rw /
 

然后输入下面命令
 1passwd
 然后回车输入密码，然后回车后在此输入密码即可
 显示 passwd…..的样式表示密码修改成功
 

然后，在光标闪烁的位置输入下面命令并回车
 1touch /.autorelabel
 

接着在光标闪烁的位置输入下面命令并回车，等待系统自动修改密码，时间可能有点长，完成后，系统会自动重启，新的密码生效
 1exec /sbin/init
 



远程是无法修改 ROOT 密码的

帮助指令
man
 

help
 


文件目录类
pwd 指令
 12# pwdpwd		// 	绝对路径

ls 指令
 12345# lsls		// 显示文件ls -a	// 显示文件包括隐藏文件ls -l	// 列表显示ls -al	// 列表显示包括隐藏文件

cd 指令
 123456# cd# 基本语法# cd 参数cd ~	// 回到当前用户的家目录cd ..	// 回到上一级目录cd /	// 回到根目录
 
 

mkdir 指令
 123456# mkdir# 基本语法：mkdir [选项] 要创建的目录# 创建一个目录mkdir /home/dog		// 在home目录下创建dog目录此时要求home目录存在，不存在创建不成功# 创建多级目录mkdir -p /homg/animal/tiger	 // 此时animal不存在也可以创建

rmdir 指令
 123456# rmdir # 基本语法：rmdir [选项] 要删除的目录# 删除一个空目录rmdir /home/dog# 删除一个非空目录rm -rf /home/animal	// -r递归删除 -f强制删除不提示

touch 指令
 12# touch# 基本语法：touch 文件名称


cp 指令
 12345# cp# 基本语法：cp [选项] source dest# 常用选项：		-r 	递归复制整个文件夹 cp 待拷贝文件或目录 目标目录
 
 

rm 指令
 12345# rm# 基本语法：rm [选项] 要删除的文件或目录# 常用选项# 	-r : 递归删除整个文件夹#		-f : 强制删除不提示
 

mv 指令
 1234# mv # 基本语法：# 	- 重命名：mv oldNameFile newNameFile# 	- 移动文件：mv 需要移动的文件 新目录
 

cat 指令
1234# cat# 基本语法：cat [选项] 要查看的文件# 常用选项： 	-n : 显示行号


more指令


less 指令


echo 指令


head 指令：默认显示文章前 10 行内容


tail 指令（可用于查看日志）：默认显示文章尾部 10 行内容


输出重定向 &gt; 、追加 &gt;&gt; 




ln 指令：类似 win 下的快捷方式




history 指令








时间日期类
date 指令
 
 

cal 指令
 


搜索查找类
find 指令


locate 指令

先执行    updatedb




which 指令




grep 指令
 


压缩解压类
gzip、gunzip 指令：用于解压缩文件



zip、unzip 指令：可压缩文件和目录
1234567# 小结# 不指定路径写法,压缩的和解压的文件都保存在当前用户所在的目录zip -r 要压缩的目录unzip 要解压的xxx.zip# 指定路径写法zip -r 指定目录/xxx.zip 要压缩的目录unzip -d 要解压到的目录 要解压的xxx.zip
123456# 如果要压缩 /home/TEST 目录下的东西，不包含home# 下面这样写的话会把home也压缩进去，包含了homezip -r 存放的目录/xxx.zip /home/TEST# 正确做法# 先进去到/home目录下，下面这样压缩就不会把home也压进去zip -r 存放的目录/xxx.zip TEST




当一个文件夹里面有文件的时候，压缩的时候要使用 zip -r xxx.zip 要压缩的文件夹
不使用 -r 就会只是压缩一个目录，里面的东西进不去



tar 指令



组管理和权限管理组
每一个用户必须属于一个组，不能独立于组外
每一个文件有三个概念
所有者：一般是创建者
所在组：这个文件属于哪一个组，那么这个组里面的用户就对这个文件拥有一定的权限
其他组：不包含该文件的组称为其他组，其他组也对该文件有一定的权限




文件/目录 所有者
查看文件的所有者


修改文件所有者
1chown 用户名 文件



组的创建
文件/目录 所在组
查看文件/目录所在的组：

12ls -ahlll

修改文件所在组：

1chgrp 组名 文件名

EX：修改文件所在组，目录同理


先创建一个组 game
然后使用 root 用户创建文件 SuperMary.txt
查看这个文件属于哪个组 -&gt; root
chgrp game SuperMary.txt


其他组除文件的所有者和所在组的用户外，系统的其他用户都是文件的其它组
改变用户所在组
查看用户所在组

1id 用户名


查看组

123cat /etc/group# 查看是否有mojiao这个组cat /etc/group | grep mojiao
没有组则没有输出


改变用户所在组

1234usermod -g 新组名 用户名# 改变该用户登录的初始目录。# 说明：用户需要有进入到新目录的权限usermod -d 目录名 用户名


权限的基本介绍123ls -lls -lahll

一共十位 
123# 分为四段l    rwx    rwx    rwx类型  所有者  所属组  其他组用户

各位数表示的意义


第 0 位：确定文件类型

l 是链接

d 是目录

c 是 字符设备 文件，如键盘、鼠标

b 是块设备，如硬盘




第 1~3 位确定所有者（该文件的所有者）拥有该文件的权限。—User

第 4~6 位确定所属组（同用户组的）拥有该文件的权限。—Group

第 7~9 位确定其他用户拥有该文件的权限。—Other



各字母表示的意义


r w x 作用到文件
[ r ] : 表示可读
[ w ] : 代表可写，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件的目录有写权限，才能删除该文件
[ x ] : 代表可执行，可以被执行


r w x 作用到目录
[ r ] : 表示可读
[ w ] : 代表可写，可以修改，对目录内 创建 + 删除 + 重命名目录
[ x ] : 代表可执行，可以进入该目录



修改权限
chmod u=rwx,g=rwx,o=x 文件名或目录名
chmod u+w 文件名/目录名
chmod a-w 文件名/目录名
1234567891011   - u：所有者   - g：所有组   - o：其他人   - a：所有人（u，g，o 的总和）2. 通过数字变更权限   &#96;&#96;&#96;shell   chmod 751 文件名&#x2F;目录名   # 上面一句表示将 所有者权限设置为 rwx，所在组设置为 rx，其他组设置为 x
123456789r=4 w=2	x=1	rwx=7rw =6rx =5r  =4wx =3w  =2x  =1




修改文件所有者123chown newowner 文件/目录 改变所有者chown newowner:newgroup 文件/目录 改变所有者和所在组-R 如果是目录，
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/03/03/Tree/" title="Tree">Tree</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-03T13:02:48.000Z" title="发表于 2021-03-03 21:02:48">2021-03-03</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-04T07:22:56.836Z" title="更新于 2021-04-04 15:22:56">2021-04-04</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%A0%91/">树</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><span class="article-meta__link">•</span><a class="article-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="content">
</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/02/28/%E5%A4%A7%E4%BA%8C%E4%B8%8B%E8%AF%BE%E7%A8%8B%E6%8E%A8%E8%8D%90-%E8%AE%A1%E7%A7%91/" title="大二下资料推荐-仅个人推荐">大二下资料推荐-仅个人推荐</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-28T12:30:33.000Z" title="发表于 2021-02-28 20:30:33">2021-02-28</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-04T07:28:42.919Z" title="更新于 2021-04-04 15:28:42">2021-04-04</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E4%B8%AA%E4%BA%BA/">个人</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E4%B8%AA%E4%BA%BA/">个人</a></span></div><div class="content">
仅仅个人推荐，具体看个人风格喜好
更新中……..


概率论与数理统计宋浩：链接点我
小元老师：链接点我
张宇：链接点我
汤家凤：
B站找不到了，百度网盘(/手动滑稽)


基础：

​    链接：https://pan.baidu.com/s/16N6dx9X3jiKVyieJ5j8G1g​    提取码：1502 

强化

​    链接：https://pan.baidu.com/s/1iuARPXy7AzHdrVROBg2bjQ​    提取码：1502 
链接点我

操作系统链接点我
链接点我
链接点我
链接点我

算法设计与分析
这个课内容连接性没那么强，可以单独搜课看，如动态规划DP、分治、贪心等都可以单独搜到

链接点我
这个课算法有点全，可以挑书上的内容看：链接点我
左神（左程云）的课比较进阶：链接点我

计算机组成原理
暂时还没

</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2021/02/25/%E4%B8%80%E4%BA%9B%E8%AE%BE%E7%BD%AE/" title="一些设置">一些设置</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-25T04:45:00.000Z" title="发表于 2021-02-25 12:45:00">2021-02-25</time><span class="article-meta__separator">|</span><i class="fas fa-history"></i><span class="article-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-03-18T15:08:02.706Z" title="更新于 2021-03-18 23:08:02">2021-03-18</time></span><span class="article-meta"><span class="article-meta__separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E8%AE%B0%E5%BD%95/">记录</a></span></div><div class="content">
状态栏显秒
打开注册表 regedit

找到路径
1计算机\HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advanced
新建 DWORD(32位)值(D) 并命名为
1ShowSecondsInSystemClock


然后修改值为 1 


然后重新打开 Windows资源管理器 生效



共享文件夹一些问题
在控制面板打开了网络共享功能

然后去 计算机管理 设置 guest 账户密码


然后在 win7 的 Administrator 账户下进去出现如下情况



刚开始以为是 Administrator 账户的原因，换了一个账户也是同样的情况


解决方法

Guest 的账户已禁用不打勾





</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" data-lazy-src="/img/%E5%A4%B4%E5%83%8F.gif" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">xiaofan</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/755400668"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/755400668" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:755400668@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到灰灰爱吃小云朵的博客,功能还在完善中！</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/05/01/MySQL/" title="MySQL基础">MySQL基础</a><time datetime="2021-05-01T02:32:33.000Z" title="发表于 2021-05-01 10:32:33">2021-05-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/03/27/Battle-of-Tanks/" title="Battle of Tanks">Battle of Tanks</a><time datetime="2021-03-27T08:28:58.000Z" title="发表于 2021-03-27 16:28:58">2021-03-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/03/22/STL/" title="STL">STL</a><time datetime="2021-03-22T10:30:25.000Z" title="发表于 2021-03-22 18:30:25">2021-03-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/03/17/data%20struct%20two/" title="data struct two">data struct two</a><time datetime="2021-03-17T11:02:24.000Z" title="发表于 2021-03-17 19:02:24">2021-03-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2021/03/08/data%20struct%20one/" title="data struct one">data struct one</a><time datetime="2021-03-08T08:31:39.000Z" title="发表于 2021-03-08 16:31:39">2021-03-08</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item parent"><a class="card-category-list-link" href="/categories/C/"><span class="card-category-list-name">C</span><span class="card-category-list-count">1</span><i class="fas fa-caret-left "></i></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C/C/"><span class="card-category-list-name">C++</span><span class="card-category-list-count">1</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/wxy/"><span class="card-category-list-name">wxy</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E4%B8%AA%E4%BA%BA/"><span class="card-category-list-name">个人</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/"><span class="card-category-list-name">笔记</span><span class="card-category-list-count">11</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E8%AF%AD%E6%B3%95/"><span class="card-category-list-name">语法</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E8%BD%AF%E4%BB%B6/"><span class="card-category-list-name">软件</span><span class="card-category-list-count">1</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/Git/" style="font-size: 1.15em; color: rgb(1, 21, 9)">Git</a><a href="/tags/%E8%AE%B0%E5%BD%95/" style="font-size: 1.45em; color: rgb(14, 63, 7)">记录</a><a href="/tags/%E8%BD%AF%E4%BB%B6/" style="font-size: 1.15em; color: rgb(137, 49, 33)">软件</a><a href="/tags/MySQL/" style="font-size: 1.15em; color: rgb(14, 53, 62)">MySQL</a><a href="/tags/C/" style="font-size: 1.25em; color: rgb(43, 69, 113)">C++</a><a href="/tags/%E6%A0%91/" style="font-size: 1.15em; color: rgb(187, 52, 172)">树</a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.35em; color: rgb(196, 23, 78)">数据结构</a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.35em; color: rgb(145, 98, 47)">算法</a><a href="/tags/wxy/" style="font-size: 1.15em; color: rgb(144, 113, 182)">wxy</a><a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 1.15em; color: rgb(140, 38, 87)">汇编</a><a href="/tags/%E5%BA%95%E5%B1%82/" style="font-size: 1.15em; color: rgb(115, 178, 199)">底层</a><a href="/tags/%E4%B8%AA%E4%BA%BA/" style="font-size: 1.15em; color: rgb(173, 11, 74)">个人</a><a href="/tags/java/" style="font-size: 1.25em; color: rgb(74, 152, 30)">java</a><a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 1.15em; color: rgb(113, 176, 168)">博客</a><a href="/tags/Linux/" style="font-size: 1.15em; color: rgb(144, 197, 157)">Linux</a><a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 1.15em; color: rgb(199, 75, 118)">链表</a><a href="/tags/LeetCode/" style="font-size: 1.15em; color: rgb(1, 199, 69)">LeetCode</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/05/"><span class="card-archive-list-date">五月 2021</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/03/"><span class="card-archive-list-date">三月 2021</span><span class="card-archive-list-count">6</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2021/02/"><span class="card-archive-list-date">二月 2021</span><span class="card-archive-list-count">9</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">16</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2021-02-17T16:00:00.000Z"></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">28.2k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2021-05-10T05:49:11.297Z"></div></div></div></div><div class="card-widget"><div class="item-headline"><i></i><span>访客</span></div><div class="item-content"><script type="text/javascript" id="clstr_globe" src="//clustrmaps.com/globe.js?d=Ti7plTQaKk8zjpyoUXfK29uCDrIzNldAuvoLvSLy1bU"></script></div></div></div></div></main><footer id="footer" style="background: flse"><div id="footer-wrap"><div class="copyright">&copy;2021  <i id="heartbeat" class="fa fas fa-heartbeat"></i> xiaofan</div><div class="footer_custom_text">我想从你的窗户里看见月亮<div id="running-time"></div><script>setInterval(()=>{let create_time=Math.round(new Date(Date.UTC(2021,01,18,0,0,0)).getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600;}if(second>=24*3600){time[1]=parseInt(second/(24*3600));second%=24*3600;}if(second>=3600){time[2]=parseInt(second/3600);second%=3600;}if(second>=60){time[3]=parseInt(second/60);second%=60;}if(second>0){time[4]=second;}currentTimeHtml='本站已安全运行 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';document.getElementById("running-time").innerHTML=currentTimeHtml;},1000);
</script></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function subtitleType () {
  getScript('https://sdk.jinrishici.com/v2/browser/jinrishici.js').then(() => {
    jinrishici.load(function (result) {
      if (true) {
        var sub = "".length == 0 ? new Array() : "".split(',')
        var content = result.data.content
        var both = sub.unshift(content)
        var typed = new Typed('#subtitle', {
          strings: sub,
          startDelay: 300,
          typeSpeed: 150,
          loop: true,
          backSpeed: 50,
        })
      } else {
        document.getElementById('subtitle').innerHTML = result.data.content
      }
    })
  })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'dark',
      })
      true && mermaid.init()
    })
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  if (typeof gtag === 'function') {
    gtag('config', '', {'page_path': window.location.pathname});
  }

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>